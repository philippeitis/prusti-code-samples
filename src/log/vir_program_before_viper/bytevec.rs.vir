method builtin$havoc_bool() returns (ret: Bool);

method builtin$havoc_int() returns (ret: Int);

method builtin$havoc_ref() returns (ret: Ref());

struct_predicate closure$0_172$3$14348369837522596991(self){
  true
}


struct_predicate tuple0$(self){
  true
}


method m_closure(0 args)
    returns (_0: Ref(tuple0$))
{
    __t0: Bool
    _1: Ref(closure$0_172$3$14348369837522596991)
    _2: Ref(closure$0_172$3$14348369837522596991)
  label start // 0
    // ========== start ==========
    // Def path: "bytevec::closure"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bytevec.rs:425:1: 431:2 (#0)
    __t0 := copy false
    // Preconditions:
    inhale(Stmt) true
    inhale(Stmt) true
    inhale(Stmt) true
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l2
    // Fold predicates for &mut args and transfer borrow permissions to old
    // Fold the result
    fold acc(tuple0$:None(_0), write)
    obtain acc(tuple0$(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) true
    // Assert type invariants
    assert(Stmt) (tuple0$$inv<Ref(tuple0$),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale true
    // Exhale permissions of postcondition (2/3)
    exhale acc(tuple0$(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_1)
    // [mir] StorageLive(_2)
    // [mir] _2 = [closure@/home/philippe/VSCodeProjects/prusti_0/src/bytevec.rs:426:15: 430:6]
    _2 := builtin$havoc_ref()
    inhale(Stmt) acc(closure$0_172$3$14348369837522596991(_2), write)
    // [mir] FakeRead(ForLet, _2)
    // [mir] _1 = _2
    label l0
    // [mir] StorageDead(_2)
    // [mir] FakeRead(ForLet, _1)
    // [mir] _0 = const ()
    // [mir] StorageDead(_1)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


struct_predicate u32(self){
  (acc(self.val_int, write)) && (true)
}


struct_predicate bool(self){
  (acc(self.val_bool, write)) && (true)
}


struct_predicate closure$0_10$3$6386611317786567673(self){
  true
}


struct_predicate ref$closure$0_10$3$6386611317786567673(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_10$3$6386611317786567673(self.val_ref), write)) && (true))
}


struct_predicate ref$u32(self){
  (acc(self.val_ref, write)) && ((acc(u32(self.val_ref), write)) && (true))
}


struct_predicate closure$0_11$3$6386611317786567673(self){
  true
}


struct_predicate ref$closure$0_11$3$6386611317786567673(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_11$3$6386611317786567673(self.val_ref), write)) && (true))
}


struct_predicate closure$0_13$3$3488527863170877720(self){
  true
}


struct_predicate ref$closure$0_13$3$3488527863170877720(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_13$3$3488527863170877720(self.val_ref), write)) && (true))
}


function m_max(_1: Int, _2: Int): Int
  requires true
  requires true
  ensures (((__result) >= (_1)) && (((__result) >= (_2)) && (true))) && (((!((__result) == (_1)))?((!((__result) == (_2)))?(false):(true)):(true)) && (true))
  ensures [((__result) == (mirror$m_max__$TY$__$int$$$int$$$int$(_1, _2))), (true)]
{
	(!((_1) > (_2)))?(_2):(_1)
}

struct_predicate m_U32Opt$_beg_$_end_Some(self){
  (acc(self.f$0, write)) && ((acc(u32(self.f$0), write)) && (true))
}


enum_predicate m_U32Opt$_beg_$_end_(self){
  discriminant=self.discriminant
  Some: (self.discriminant) == (0) ==> struct_predicate m_U32Opt$_beg_$_end_Some(self){
  (acc(self.f$0, write)) && ((acc(u32(self.f$0), write)) && (true))
}


  None: (self.discriminant) == (1) ==> struct_predicate m_U32Opt$_beg_$_end_None(self){
  true
}


}


struct_predicate ref$m_U32Opt$_beg_$_end_(self){
  (acc(self.val_ref, write)) && ((acc(m_U32Opt$_beg_$_end_(self.val_ref), write)) && (true))
}


method m_clone(1 args)
    returns (_0: Ref(m_U32Opt$_beg_$_end_))
{
    __t0: Bool
    _old$pre$0: Ref(m_U32Opt$_beg_$_end_)
    _1: Ref(ref$m_U32Opt$_beg_$_end_)
  label start // 0
    // ========== start ==========
    // Def path: "bytevec::{impl#1}::clone"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bytevec.rs:97:27: 97:32 (#9)
    __t0 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_U32Opt$_beg_$_end_(_1.val_ref), read)) && (true))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_1)) && (true)
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l2
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_U32Opt$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(m_U32Opt$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) true
    // Assert type invariants
    assert(Stmt) (m_U32Opt$_beg_$_end_$inv<Ref(m_U32Opt$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_U32Opt$_beg_$_end_(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_U32Opt$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] _0 = (*_1)
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_0), write)
    inhale(Stmt) m_U32Opt$_beg_$_end_$$memory_eq$$<Ref(m_U32Opt$_beg_$_end_), Ref(m_U32Opt$_beg_$_end_),Bool>(_1.val_ref, _0)
    label l0
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


struct_predicate isize(self){
  (acc(self.val_int, write)) && (true)
}


struct_predicate tuple2$ref$m_U32Opt$_beg_$_end_$ref$m_U32Opt$_beg_$_end_(self){
  (acc(self.tuple_0, write)) && ((acc(ref$m_U32Opt$_beg_$_end_(self.tuple_0), write)) && ((acc(self.tuple_1, write)) && ((acc(ref$m_U32Opt$_beg_$_end_(self.tuple_1), write)) && (true))))
}


method m_eq(2 args)
    returns (_0: Ref(bool))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    _aux_havoc_ref$m_U32Opt$_beg_$_end_: Ref(ref$m_U32Opt$_beg_$_end_)
    __t18: Int
    __t19: Int
    _old$pre$0: Ref(m_U32Opt$_beg_$_end_)
    _old$pre$1: Ref(m_U32Opt$_beg_$_end_)
    _1: Ref(ref$m_U32Opt$_beg_$_end_)
    _2: Ref(ref$m_U32Opt$_beg_$_end_)
    _3: Ref(isize)
    _4: Ref(ref$m_U32Opt$_beg_$_end_)
    _5: Ref(ref$m_U32Opt$_beg_$_end_)
    _6: Ref(isize)
    _7: Ref(ref$m_U32Opt$_beg_$_end_)
    _8: Ref(ref$m_U32Opt$_beg_$_end_)
    _9: Ref(bool)
    _10: Ref(bool)
    _11: Ref(isize)
    _12: Ref(isize)
    _13: Ref(tuple2$ref$m_U32Opt$_beg_$_end_$ref$m_U32Opt$_beg_$_end_)
    _14: Ref(ref$m_U32Opt$_beg_$_end_)
    _15: Ref(ref$m_U32Opt$_beg_$_end_)
    _16: Ref(isize)
    _17: Ref(isize)
    _18: Ref(ref$u32)
    _19: Ref(ref$u32)
    _20: Ref(u32)
    _21: Ref(u32)
  label start // 0
    // ========== start ==========
    // Def path: "bytevec::{impl#4}::eq"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bytevec.rs:97:10: 97:19 (#11)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_U32Opt$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_U32Opt$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_1)) && ((ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l31
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_U32Opt$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_U32Opt$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    fold acc(bool:None(_0), write)
    obtain acc(bool(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) true
    // Assert type invariants
    assert(Stmt) (bool$inv<Ref(bool),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_U32Opt$_beg_$_end_(_old$pre$0), read)) && ((acc(m_U32Opt$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(bool(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = &'_ (*_1)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_ref, write)
    _5.val_ref := borrow _1.val_ref // L14
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_5.val_ref), read)
    label l0
    // [mir] _4 = &'_ (*_5)
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_ref, write)
    _4.val_ref := borrow _5.val_ref // L8
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_4.val_ref), read)
    label l1
    // [mir] _3 = std::intrinsics::discriminant_value::<U32Opt>(move _4) -> [return: bb1, unwind: bb15]
    label l2
    assert(Stmt) true
    assert(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_4)) && (true)
    exhale (acc(_4.val_ref, write)) && ((true) && (true))
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(isize(_3), write)
    transfer perm _4.val_ref --> old[l2](_4.val_ref) // unchecked: true
    inhale(Stmt) (isize$inv<Ref(isize),Bool>(_3)) && (true)
    inhale(Expr) true
    exhale true
    label l3
    Goto(cfg:3)
  label l4 // 3
    // ========== l4 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    // expire_borrows ReborrowingDAG(L9,L8,L14,)

    if (__t0) && (true) {
    // expire loan L9
} else {}
    if (__t0) && ((__t0) && (true)) {
    // expire loan L8
    transfer perm old[l2](_4.val_ref) --> old[l1](_4.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l1](_4.val_ref)), read)
} else {}
    if (__t0) && ((__t0) && ((__t0) && (true))) {
    // expire loan L14
    exhale acc(m_U32Opt$_beg_$_end_(_5.val_ref), read)
} else {}
    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_4)
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageDead(_5)
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = &'_ (*_2)
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_ref, write)
    _8.val_ref := borrow _2.val_ref // L13
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_8.val_ref), read)
    label l5
    // [mir] _7 = &'_ (*_8)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_ref, write)
    _7.val_ref := borrow _8.val_ref // L12
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_7.val_ref), read)
    label l6
    // [mir] _6 = std::intrinsics::discriminant_value::<U32Opt>(move _7) -> [return: bb2, unwind: bb15]
    label l7
    assert(Stmt) true
    assert(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_7)) && (true)
    exhale (acc(_7.val_ref, write)) && ((true) && (true))
    _6 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(isize(_6), write)
    transfer perm _7.val_ref --> old[l7](_7.val_ref) // unchecked: true
    inhale(Stmt) (isize$inv<Ref(isize),Bool>(_6)) && (true)
    inhale(Expr) true
    exhale true
    label l8
    Goto(cfg:5)
  label l9 // 5
    // ========== l9 ==========
    // MIR edge bb1 --> bb2
    // Expire borrows
    // expire_borrows ReborrowingDAG(L4,L12,L13,)

    if (__t1) && (true) {
    // expire loan L4
} else {}
    if (__t1) && ((__t1) && (true)) {
    // expire loan L12
    transfer perm old[l7](_7.val_ref) --> old[l6](_7.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l6](_7.val_ref)), read)
} else {}
    if (__t1) && ((__t1) && ((__t1) && (true))) {
    // expire loan L13
    exhale acc(m_U32Opt$_beg_$_end_(_8.val_ref), read)
} else {}
    Goto(cfg:6)
  label bb2 // 6
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] StorageDead(_7)
    // [mir] FakeRead(ForLet, _6)
    // [mir] StorageDead(_8)
    // [mir] StorageLive(_9)
    // [mir] switchInt(const true) -> [false: bb4, otherwise: bb5]
    __t15 := copy true
    GotoSwitch([(UnaryOp(Not, Local(__t15: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l10 // 7
    // ========== l10 ==========
    // MIR edge bb2 --> bb5
    Goto(cfg:9)
  label l11 // 8
    // ========== l11 ==========
    // MIR edge bb2 --> bb4
    Goto(cfg:29)
  label bb5 // 9
    // ========== bb5 ==========
    __t3 := copy true
    // [mir] StorageLive(_10)
    // [mir] StorageLive(_11)
    // [mir] _11 = _3
    _11 := builtin$havoc_ref()
    inhale(Stmt) acc(_11.val_int, write)
    unfold acc(isize:None(_3), write)
    _11.val_int := copy _3.val_int
    label l12
    // [mir] StorageLive(_12)
    // [mir] _12 = _6
    _12 := builtin$havoc_ref()
    inhale(Stmt) acc(_12.val_int, write)
    unfold acc(isize:None(_6), write)
    _12.val_int := copy _6.val_int
    label l13
    // [mir] _10 = Eq(move _11, move _12)
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy (_11.val_int) == (_12.val_int)
    // [mir] StorageDead(_12)
    // [mir] StorageDead(_11)
    // [mir] switchInt(move _10) -> [false: bb4, otherwise: bb3]
    __t16 := copy _10.val_bool
    GotoSwitch([(UnaryOp(Not, Local(__t16: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:11)], cfg:10)
  label l14 // 10
    // ========== l14 ==========
    // MIR edge bb5 --> bb3
    Goto(cfg:12)
  label l15 // 11
    // ========== l15 ==========
    // MIR edge bb5 --> bb4
    Goto(cfg:30)
  label bb3 // 12
    // ========== bb3 ==========
    __t4 := copy true
    // [mir] _9 = const true
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy true
    // [mir] goto -> bb6
    Goto(cfg:31)
  label bb4 // 13
    // ========== bb4 ==========
    __t5 := copy true
    // [mir] _9 = const false
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy false
    // [mir] goto -> bb6
    Goto(cfg:14)
  label bb6 // 14
    // ========== bb6 ==========
    __t6 := copy true
    // [mir] StorageDead(_10)
    // [mir] switchInt(move _9) -> [false: bb8, otherwise: bb7]
    __t17 := copy _9.val_bool
    GotoSwitch([(UnaryOp(Not, Local(__t17: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:16)], cfg:15)
  label l16 // 15
    // ========== l16 ==========
    // MIR edge bb6 --> bb7
    Goto(cfg:17)
  label l17 // 16
    // ========== l17 ==========
    // MIR edge bb6 --> bb8
    Goto(cfg:27)
  label bb7 // 17
    // ========== bb7 ==========
    __t7 := copy true
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = &'_ (*_1)
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_ref, write)
    _14.val_ref := borrow _1.val_ref // L5
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_14.val_ref), read)
    label l18
    // [mir] StorageLive(_15)
    // [mir] _15 = &'_ (*_2)
    _15 := builtin$havoc_ref()
    inhale(Stmt) acc(_15.val_ref, write)
    _15.val_ref := borrow _2.val_ref // L10
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_15.val_ref), read)
    label l19
    // [mir] _13 = (move _14, move _15)
    _13 := builtin$havoc_ref()
    inhale(Stmt) acc(tuple2$ref$m_U32Opt$_beg_$_end_$ref$m_U32Opt$_beg_$_end_(_13), write)
    _aux_havoc_ref$m_U32Opt$_beg_$_end_ := builtin$havoc_ref()
    unfold acc(tuple2$ref$m_U32Opt$_beg_$_end_$ref$m_U32Opt$_beg_$_end_:None(_13), write)
    _13.tuple_0 := move _aux_havoc_ref$m_U32Opt$_beg_$_end_
    inhale(Stmt) acc(_13.tuple_0.val_ref, write)
    _13.tuple_0.val_ref := move _14.val_ref
    label l20
    _aux_havoc_ref$m_U32Opt$_beg_$_end_ := builtin$havoc_ref()
    _13.tuple_1 := move _aux_havoc_ref$m_U32Opt$_beg_$_end_
    inhale(Stmt) acc(_13.tuple_1.val_ref, write)
    _13.tuple_1.val_ref := move _15.val_ref
    label l21
    // [mir] StorageDead(_15)
    // [mir] StorageDead(_14)
    // [mir] FakeRead(ForMatchedPlace, _13)
    // [mir] _17 = discriminant((*(_13.0: &U32Opt)))
    _17 := builtin$havoc_ref()
    inhale(Stmt) acc(_17.val_int, write)
    _17.val_int := copy m_U32Opt$_beg_$_end_$$discriminant$$<Ref(m_U32Opt$_beg_$_end_),Int>(_13.tuple_0.val_ref)
    // [mir] switchInt(move _17) -> [0_isize: bb9, otherwise: bb11]
    __t18 := copy _17.val_int
    GotoSwitch([(BinOp(EqCmp, Local(__t18: Int, Position { line: 0, column: 0, id: 0 }), Const(BigInt("0"), Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:19)], cfg:18)
  label l22 // 18
    // ========== l22 ==========
    // MIR edge bb7 --> bb11
    // Expire borrows
    // expire_borrows ReborrowingDAG(L7,L10,L6,L5,)

    if (__t7) && (true) {
    // expire loan L7
    transfer perm _13.tuple_1.val_ref --> old[l21](_15.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && (true)) {
    // expire loan L10
    transfer perm old[l21](_15.val_ref) --> old[l19](_15.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l19](_15.val_ref)), read)
    // drop Acc(old[l19](_15.val_ref), write) (Acc(old[l19](_15.val_ref), write))
    // drop Pred(_13.tuple_0.val_ref, read) (Pred(_13.tuple_0.val_ref, read))
} else {}
    if (__t7) && (true) {
    // expire loan L6
    transfer perm _13.tuple_0.val_ref --> old[l21](_14.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && (true)) {
    // expire loan L5
    transfer perm old[l21](_14.val_ref) --> old[l18](_14.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l18](_14.val_ref)), read)
    // drop Acc(old[l18](_14.val_ref), write) (Acc(old[l18](_14.val_ref), write))
    // drop Pred(_13.tuple_1.val_ref, read) (Pred(_13.tuple_1.val_ref, read))
} else {}
    Goto(cfg:23)
  label l23 // 19
    // ========== l23 ==========
    // MIR edge bb7 --> bb9
    Goto(cfg:20)
  label bb9 // 20
    // ========== bb9 ==========
    __t8 := copy true
    // [mir] _16 = discriminant((*(_13.1: &U32Opt)))
    _16 := builtin$havoc_ref()
    inhale(Stmt) acc(_16.val_int, write)
    _16.val_int := copy m_U32Opt$_beg_$_end_$$discriminant$$<Ref(m_U32Opt$_beg_$_end_),Int>(_13.tuple_1.val_ref)
    // [mir] switchInt(move _16) -> [0_isize: bb10, otherwise: bb11]
    __t19 := copy _16.val_int
    GotoSwitch([(BinOp(EqCmp, Local(__t19: Int, Position { line: 0, column: 0, id: 0 }), Const(BigInt("0"), Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:22)], cfg:21)
  label l24 // 21
    // ========== l24 ==========
    // MIR edge bb9 --> bb11
    // Expire borrows
    // expire_borrows ReborrowingDAG(L7,L10,L6,L5,)

    if (__t7) && (true) {
    // expire loan L7
    transfer perm _13.tuple_1.val_ref --> old[l21](_15.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && (true)) {
    // expire loan L10
    transfer perm old[l21](_15.val_ref) --> old[l19](_15.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l19](_15.val_ref)), read)
    // drop Acc(old[l19](_15.val_ref), write) (Acc(old[l19](_15.val_ref), write))
    // drop Pred(_13.tuple_0.val_ref, read) (Pred(_13.tuple_0.val_ref, read))
} else {}
    if (__t7) && (true) {
    // expire loan L6
    transfer perm _13.tuple_0.val_ref --> old[l21](_14.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && (true)) {
    // expire loan L5
    transfer perm old[l21](_14.val_ref) --> old[l18](_14.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l18](_14.val_ref)), read)
    // drop Acc(old[l18](_14.val_ref), write) (Acc(old[l18](_14.val_ref), write))
    // drop Pred(_13.tuple_1.val_ref, read) (Pred(_13.tuple_1.val_ref, read))
} else {}
    Goto(cfg:32)
  label l25 // 22
    // ========== l25 ==========
    // MIR edge bb9 --> bb10
    Goto(cfg:24)
  label bb11 // 23
    // ========== bb11 ==========
    __t9 := copy true
    // [mir] _0 = const true
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_bool, write)
    _0.val_bool := copy true
    // [mir] goto -> bb13
    Goto(cfg:26)
  label bb10 // 24
    // ========== bb10 ==========
    __t10 := copy true
    // [mir] falseEdge -> [real: bb12, imaginary: bb11]
    Goto(cfg:25)
  label bb12 // 25
    // ========== bb12 ==========
    __t11 := copy true
    // [mir] StorageLive(_18)
    // [mir] _18 = &'_ (((*(_13.0: &U32Opt)) as Some).0: u32)
    _18 := builtin$havoc_ref()
    inhale(Stmt) acc(_18.val_ref, write)
    unfold acc(m_U32Opt$_beg_$_end_:Some(EnumVariantIndex("Some"))(_13.tuple_0.val_ref), read)
    unfold acc(m_U32Opt$_beg_$_end_Some:None(_13.tuple_0.val_ref[enum_Some]), read)
    _18.val_ref := borrow _13.tuple_0.val_ref[enum_Some].f$0 // L11
    inhale(Stmt) acc(u32(_18.val_ref), read)
    label l26
    // [mir] StorageLive(_19)
    // [mir] _19 = &'_ (((*(_13.1: &U32Opt)) as Some).0: u32)
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_ref, write)
    unfold acc(m_U32Opt$_beg_$_end_:Some(EnumVariantIndex("Some"))(_13.tuple_1.val_ref), read)
    unfold acc(m_U32Opt$_beg_$_end_Some:None(_13.tuple_1.val_ref[enum_Some]), read)
    _19.val_ref := borrow _13.tuple_1.val_ref[enum_Some].f$0 // L15
    inhale(Stmt) acc(u32(_19.val_ref), read)
    label l27
    // [mir] StorageLive(_20)
    // [mir] _20 = (*_18)
    _20 := builtin$havoc_ref()
    inhale(Stmt) acc(_20.val_int, write)
    unfold acc(u32:None(_18.val_ref), read)
    _20.val_int := copy _18.val_ref.val_int
    label l28
    // expire_borrows ReborrowingDAG(L11,L6,L5,)

    if (__t11) && (true) {
    // expire loan L11
    fold acc(u32:None(_18.val_ref), read)
    exhale acc(u32(_18.val_ref), read)
} else {}
    if (__t7) && ((__t11) && (true)) {
    // expire loan L6
    transfer perm _13.tuple_0.val_ref --> old[l21](_14.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && ((__t11) && (true))) {
    // expire loan L5
    transfer perm old[l21](_14.val_ref) --> old[l18](_14.val_ref) // unchecked: false
    fold acc(m_U32Opt$_beg_$_end_Some:None(old[l18](_14.val_ref)[enum_Some]), read)
    fold acc(m_U32Opt$_beg_$_end_:Some(EnumVariantIndex("Some"))(old[l18](_14.val_ref)), read)
    exhale acc(m_U32Opt$_beg_$_end_(old[l18](_14.val_ref)), read)
} else {}
    // [mir] StorageLive(_21)
    // [mir] _21 = (*_19)
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_int, write)
    unfold acc(u32:None(_19.val_ref), read)
    _21.val_int := copy _19.val_ref.val_int
    label l29
    // expire_borrows ReborrowingDAG(L15,L7,L10,)

    if (__t11) && (true) {
    // expire loan L15
    fold acc(u32:None(_19.val_ref), read)
    exhale acc(u32(_19.val_ref), read)
} else {}
    if (__t7) && ((__t11) && (true)) {
    // expire loan L7
    transfer perm _13.tuple_1.val_ref --> old[l21](_15.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && ((__t11) && (true))) {
    // expire loan L10
    transfer perm old[l21](_15.val_ref) --> old[l19](_15.val_ref) // unchecked: false
    fold acc(m_U32Opt$_beg_$_end_Some:None(old[l19](_15.val_ref)[enum_Some]), read)
    fold acc(m_U32Opt$_beg_$_end_:Some(EnumVariantIndex("Some"))(old[l19](_15.val_ref)), read)
    exhale acc(m_U32Opt$_beg_$_end_(old[l19](_15.val_ref)), read)
} else {}
    // [mir] _0 = Eq(move _20, move _21)
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_bool, write)
    _0.val_bool := copy (_20.val_int) == (_21.val_int)
    // [mir] StorageDead(_21)
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_18)
    // [mir] goto -> bb13
    Goto(cfg:33)
  label bb13 // 26
    // ========== bb13 ==========
    __t12 := copy true
    // [mir] StorageDead(_13)
    // [mir] goto -> bb14
    Goto(cfg:34)
  label bb8 // 27
    // ========== bb8 ==========
    __t13 := copy true
    // [mir] _0 = const false
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_bool, write)
    _0.val_bool := copy false
    // [mir] goto -> bb14
    Goto(cfg:28)
  label bb14 // 28
    // ========== bb14 ==========
    __t14 := copy true
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l30 // 29
    // ========== l30 ==========
    unfold acc(isize:None(_3), write)
    unfold acc(isize:None(_6), write)
    Goto(cfg:13)
  label l32 // 30
    // ========== l32 ==========
    // drop Acc(_10.val_bool, write) (Acc(_10.val_bool, write))
    // drop Acc(_11.val_int, write) (Acc(_11.val_int, write))
    // drop Acc(_12.val_int, write) (Acc(_12.val_int, write))
    Goto(cfg:13)
  label l33 // 31
    // ========== l33 ==========
    // drop Acc(_11.val_int, write) (Acc(_11.val_int, write))
    // drop Acc(_10.val_bool, write) (Acc(_10.val_bool, write))
    // drop Acc(_12.val_int, write) (Acc(_12.val_int, write))
    Goto(cfg:14)
  label l34 // 32
    // ========== l34 ==========
    // drop Acc(_16.val_int, write) (Acc(_16.val_int, write))
    Goto(cfg:23)
  label l35 // 33
    // ========== l35 ==========
    // drop Acc(_18.val_ref, write) (Acc(_18.val_ref, write))
    // drop Acc(_19.val_ref, write) (Acc(_19.val_ref, write))
    // drop Acc(_16.val_int, write) (Acc(_16.val_int, write))
    // drop Acc(old[l18](_14.val_ref), write) (Acc(old[l18](_14.val_ref), write))
    // drop Acc(_21.val_int, write) (Acc(_21.val_int, write))
    // drop Acc(old[l19](_15.val_ref), write) (Acc(old[l19](_15.val_ref), write))
    // drop Acc(_20.val_int, write) (Acc(_20.val_int, write))
    Goto(cfg:26)
  label l36 // 34
    // ========== l36 ==========
    // drop Acc(_15.val_ref, write) (Acc(_15.val_ref, write))
    // drop Acc(_13.tuple_1.val_ref, write) (Acc(_13.tuple_1.val_ref, write))
    // drop Acc(_17.val_int, write) (Acc(_17.val_int, write))
    // drop Acc(_14.val_ref, write) (Acc(_14.val_ref, write))
    // drop Acc(_13.tuple_0.val_ref, write) (Acc(_13.tuple_0.val_ref, write))
    // drop Acc(_13.tuple_0, write) (Acc(_13.tuple_0, write))
    // drop Acc(_13.tuple_1, write) (Acc(_13.tuple_1, write))
    Goto(cfg:28)
  label end_of_method
}


method m_ne(2 args)
    returns (_0: Ref(bool))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    _aux_havoc_ref$m_U32Opt$_beg_$_end_: Ref(ref$m_U32Opt$_beg_$_end_)
    __t18: Int
    __t19: Int
    _old$pre$0: Ref(m_U32Opt$_beg_$_end_)
    _old$pre$1: Ref(m_U32Opt$_beg_$_end_)
    _1: Ref(ref$m_U32Opt$_beg_$_end_)
    _2: Ref(ref$m_U32Opt$_beg_$_end_)
    _3: Ref(isize)
    _4: Ref(ref$m_U32Opt$_beg_$_end_)
    _5: Ref(ref$m_U32Opt$_beg_$_end_)
    _6: Ref(isize)
    _7: Ref(ref$m_U32Opt$_beg_$_end_)
    _8: Ref(ref$m_U32Opt$_beg_$_end_)
    _9: Ref(bool)
    _10: Ref(bool)
    _11: Ref(isize)
    _12: Ref(isize)
    _13: Ref(tuple2$ref$m_U32Opt$_beg_$_end_$ref$m_U32Opt$_beg_$_end_)
    _14: Ref(ref$m_U32Opt$_beg_$_end_)
    _15: Ref(ref$m_U32Opt$_beg_$_end_)
    _16: Ref(isize)
    _17: Ref(isize)
    _18: Ref(ref$u32)
    _19: Ref(ref$u32)
    _20: Ref(u32)
    _21: Ref(u32)
  label start // 0
    // ========== start ==========
    // Def path: "bytevec::{impl#4}::ne"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bytevec.rs:97:10: 97:19 (#11)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_U32Opt$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_U32Opt$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_1)) && ((ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l31
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_U32Opt$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_U32Opt$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    fold acc(bool:None(_0), write)
    obtain acc(bool(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) true
    // Assert type invariants
    assert(Stmt) (bool$inv<Ref(bool),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_U32Opt$_beg_$_end_(_old$pre$0), read)) && ((acc(m_U32Opt$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(bool(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = &'_ (*_1)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_ref, write)
    _5.val_ref := borrow _1.val_ref // L8
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_5.val_ref), read)
    label l0
    // [mir] _4 = &'_ (*_5)
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_ref, write)
    _4.val_ref := borrow _5.val_ref // L9
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_4.val_ref), read)
    label l1
    // [mir] _3 = std::intrinsics::discriminant_value::<U32Opt>(move _4) -> [return: bb1, unwind: bb15]
    label l2
    assert(Stmt) true
    assert(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_4)) && (true)
    exhale (acc(_4.val_ref, write)) && ((true) && (true))
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(isize(_3), write)
    transfer perm _4.val_ref --> old[l2](_4.val_ref) // unchecked: true
    inhale(Stmt) (isize$inv<Ref(isize),Bool>(_3)) && (true)
    inhale(Expr) true
    exhale true
    label l3
    Goto(cfg:3)
  label l4 // 3
    // ========== l4 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    // expire_borrows ReborrowingDAG(L10,L9,L8,)

    if (__t0) && (true) {
    // expire loan L10
} else {}
    if (__t0) && ((__t0) && (true)) {
    // expire loan L9
    transfer perm old[l2](_4.val_ref) --> old[l1](_4.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l1](_4.val_ref)), read)
} else {}
    if (__t0) && ((__t0) && ((__t0) && (true))) {
    // expire loan L8
    exhale acc(m_U32Opt$_beg_$_end_(_5.val_ref), read)
} else {}
    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_4)
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageDead(_5)
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = &'_ (*_2)
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_ref, write)
    _8.val_ref := borrow _2.val_ref // L11
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_8.val_ref), read)
    label l5
    // [mir] _7 = &'_ (*_8)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_ref, write)
    _7.val_ref := borrow _8.val_ref // L15
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_7.val_ref), read)
    label l6
    // [mir] _6 = std::intrinsics::discriminant_value::<U32Opt>(move _7) -> [return: bb2, unwind: bb15]
    label l7
    assert(Stmt) true
    assert(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_7)) && (true)
    exhale (acc(_7.val_ref, write)) && ((true) && (true))
    _6 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(isize(_6), write)
    transfer perm _7.val_ref --> old[l7](_7.val_ref) // unchecked: true
    inhale(Stmt) (isize$inv<Ref(isize),Bool>(_6)) && (true)
    inhale(Expr) true
    exhale true
    label l8
    Goto(cfg:5)
  label l9 // 5
    // ========== l9 ==========
    // MIR edge bb1 --> bb2
    // Expire borrows
    // expire_borrows ReborrowingDAG(L6,L15,L11,)

    if (__t1) && (true) {
    // expire loan L6
} else {}
    if (__t1) && ((__t1) && (true)) {
    // expire loan L15
    transfer perm old[l7](_7.val_ref) --> old[l6](_7.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l6](_7.val_ref)), read)
} else {}
    if (__t1) && ((__t1) && ((__t1) && (true))) {
    // expire loan L11
    exhale acc(m_U32Opt$_beg_$_end_(_8.val_ref), read)
} else {}
    Goto(cfg:6)
  label bb2 // 6
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] StorageDead(_7)
    // [mir] FakeRead(ForLet, _6)
    // [mir] StorageDead(_8)
    // [mir] StorageLive(_9)
    // [mir] switchInt(const true) -> [false: bb4, otherwise: bb5]
    __t15 := copy true
    GotoSwitch([(UnaryOp(Not, Local(__t15: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l10 // 7
    // ========== l10 ==========
    // MIR edge bb2 --> bb5
    Goto(cfg:9)
  label l11 // 8
    // ========== l11 ==========
    // MIR edge bb2 --> bb4
    Goto(cfg:29)
  label bb5 // 9
    // ========== bb5 ==========
    __t3 := copy true
    // [mir] StorageLive(_10)
    // [mir] StorageLive(_11)
    // [mir] _11 = _3
    _11 := builtin$havoc_ref()
    inhale(Stmt) acc(_11.val_int, write)
    unfold acc(isize:None(_3), write)
    _11.val_int := copy _3.val_int
    label l12
    // [mir] StorageLive(_12)
    // [mir] _12 = _6
    _12 := builtin$havoc_ref()
    inhale(Stmt) acc(_12.val_int, write)
    unfold acc(isize:None(_6), write)
    _12.val_int := copy _6.val_int
    label l13
    // [mir] _10 = Eq(move _11, move _12)
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy (_11.val_int) == (_12.val_int)
    // [mir] StorageDead(_12)
    // [mir] StorageDead(_11)
    // [mir] switchInt(move _10) -> [false: bb4, otherwise: bb3]
    __t16 := copy _10.val_bool
    GotoSwitch([(UnaryOp(Not, Local(__t16: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:11)], cfg:10)
  label l14 // 10
    // ========== l14 ==========
    // MIR edge bb5 --> bb3
    Goto(cfg:12)
  label l15 // 11
    // ========== l15 ==========
    // MIR edge bb5 --> bb4
    Goto(cfg:30)
  label bb3 // 12
    // ========== bb3 ==========
    __t4 := copy true
    // [mir] _9 = const true
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy true
    // [mir] goto -> bb6
    Goto(cfg:31)
  label bb4 // 13
    // ========== bb4 ==========
    __t5 := copy true
    // [mir] _9 = const false
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy false
    // [mir] goto -> bb6
    Goto(cfg:14)
  label bb6 // 14
    // ========== bb6 ==========
    __t6 := copy true
    // [mir] StorageDead(_10)
    // [mir] switchInt(move _9) -> [false: bb8, otherwise: bb7]
    __t17 := copy _9.val_bool
    GotoSwitch([(UnaryOp(Not, Local(__t17: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:16)], cfg:15)
  label l16 // 15
    // ========== l16 ==========
    // MIR edge bb6 --> bb7
    Goto(cfg:17)
  label l17 // 16
    // ========== l17 ==========
    // MIR edge bb6 --> bb8
    Goto(cfg:27)
  label bb7 // 17
    // ========== bb7 ==========
    __t7 := copy true
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = &'_ (*_1)
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_ref, write)
    _14.val_ref := borrow _1.val_ref // L7
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_14.val_ref), read)
    label l18
    // [mir] StorageLive(_15)
    // [mir] _15 = &'_ (*_2)
    _15 := builtin$havoc_ref()
    inhale(Stmt) acc(_15.val_ref, write)
    _15.val_ref := borrow _2.val_ref // L12
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_15.val_ref), read)
    label l19
    // [mir] _13 = (move _14, move _15)
    _13 := builtin$havoc_ref()
    inhale(Stmt) acc(tuple2$ref$m_U32Opt$_beg_$_end_$ref$m_U32Opt$_beg_$_end_(_13), write)
    _aux_havoc_ref$m_U32Opt$_beg_$_end_ := builtin$havoc_ref()
    unfold acc(tuple2$ref$m_U32Opt$_beg_$_end_$ref$m_U32Opt$_beg_$_end_:None(_13), write)
    _13.tuple_0 := move _aux_havoc_ref$m_U32Opt$_beg_$_end_
    inhale(Stmt) acc(_13.tuple_0.val_ref, write)
    _13.tuple_0.val_ref := move _14.val_ref
    label l20
    _aux_havoc_ref$m_U32Opt$_beg_$_end_ := builtin$havoc_ref()
    _13.tuple_1 := move _aux_havoc_ref$m_U32Opt$_beg_$_end_
    inhale(Stmt) acc(_13.tuple_1.val_ref, write)
    _13.tuple_1.val_ref := move _15.val_ref
    label l21
    // [mir] StorageDead(_15)
    // [mir] StorageDead(_14)
    // [mir] FakeRead(ForMatchedPlace, _13)
    // [mir] _17 = discriminant((*(_13.0: &U32Opt)))
    _17 := builtin$havoc_ref()
    inhale(Stmt) acc(_17.val_int, write)
    _17.val_int := copy m_U32Opt$_beg_$_end_$$discriminant$$<Ref(m_U32Opt$_beg_$_end_),Int>(_13.tuple_0.val_ref)
    // [mir] switchInt(move _17) -> [0_isize: bb9, otherwise: bb11]
    __t18 := copy _17.val_int
    GotoSwitch([(BinOp(EqCmp, Local(__t18: Int, Position { line: 0, column: 0, id: 0 }), Const(BigInt("0"), Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:19)], cfg:18)
  label l22 // 18
    // ========== l22 ==========
    // MIR edge bb7 --> bb11
    // Expire borrows
    // expire_borrows ReborrowingDAG(L5,L12,L4,L7,)

    if (__t7) && (true) {
    // expire loan L5
    transfer perm _13.tuple_1.val_ref --> old[l21](_15.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && (true)) {
    // expire loan L12
    transfer perm old[l21](_15.val_ref) --> old[l19](_15.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l19](_15.val_ref)), read)
    // drop Acc(old[l19](_15.val_ref), write) (Acc(old[l19](_15.val_ref), write))
    // drop Pred(_13.tuple_0.val_ref, read) (Pred(_13.tuple_0.val_ref, read))
} else {}
    if (__t7) && (true) {
    // expire loan L4
    transfer perm _13.tuple_0.val_ref --> old[l21](_14.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && (true)) {
    // expire loan L7
    transfer perm old[l21](_14.val_ref) --> old[l18](_14.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l18](_14.val_ref)), read)
    // drop Acc(old[l18](_14.val_ref), write) (Acc(old[l18](_14.val_ref), write))
    // drop Pred(_13.tuple_1.val_ref, read) (Pred(_13.tuple_1.val_ref, read))
} else {}
    Goto(cfg:23)
  label l23 // 19
    // ========== l23 ==========
    // MIR edge bb7 --> bb9
    Goto(cfg:20)
  label bb9 // 20
    // ========== bb9 ==========
    __t8 := copy true
    // [mir] _16 = discriminant((*(_13.1: &U32Opt)))
    _16 := builtin$havoc_ref()
    inhale(Stmt) acc(_16.val_int, write)
    _16.val_int := copy m_U32Opt$_beg_$_end_$$discriminant$$<Ref(m_U32Opt$_beg_$_end_),Int>(_13.tuple_1.val_ref)
    // [mir] switchInt(move _16) -> [0_isize: bb10, otherwise: bb11]
    __t19 := copy _16.val_int
    GotoSwitch([(BinOp(EqCmp, Local(__t19: Int, Position { line: 0, column: 0, id: 0 }), Const(BigInt("0"), Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:22)], cfg:21)
  label l24 // 21
    // ========== l24 ==========
    // MIR edge bb9 --> bb11
    // Expire borrows
    // expire_borrows ReborrowingDAG(L5,L12,L4,L7,)

    if (__t7) && (true) {
    // expire loan L5
    transfer perm _13.tuple_1.val_ref --> old[l21](_15.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && (true)) {
    // expire loan L12
    transfer perm old[l21](_15.val_ref) --> old[l19](_15.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l19](_15.val_ref)), read)
    // drop Acc(old[l19](_15.val_ref), write) (Acc(old[l19](_15.val_ref), write))
    // drop Pred(_13.tuple_0.val_ref, read) (Pred(_13.tuple_0.val_ref, read))
} else {}
    if (__t7) && (true) {
    // expire loan L4
    transfer perm _13.tuple_0.val_ref --> old[l21](_14.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && (true)) {
    // expire loan L7
    transfer perm old[l21](_14.val_ref) --> old[l18](_14.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l18](_14.val_ref)), read)
    // drop Acc(old[l18](_14.val_ref), write) (Acc(old[l18](_14.val_ref), write))
    // drop Pred(_13.tuple_1.val_ref, read) (Pred(_13.tuple_1.val_ref, read))
} else {}
    Goto(cfg:32)
  label l25 // 22
    // ========== l25 ==========
    // MIR edge bb9 --> bb10
    Goto(cfg:24)
  label bb11 // 23
    // ========== bb11 ==========
    __t9 := copy true
    // [mir] _0 = const false
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_bool, write)
    _0.val_bool := copy false
    // [mir] goto -> bb13
    Goto(cfg:26)
  label bb10 // 24
    // ========== bb10 ==========
    __t10 := copy true
    // [mir] falseEdge -> [real: bb12, imaginary: bb11]
    Goto(cfg:25)
  label bb12 // 25
    // ========== bb12 ==========
    __t11 := copy true
    // [mir] StorageLive(_18)
    // [mir] _18 = &'_ (((*(_13.0: &U32Opt)) as Some).0: u32)
    _18 := builtin$havoc_ref()
    inhale(Stmt) acc(_18.val_ref, write)
    unfold acc(m_U32Opt$_beg_$_end_:Some(EnumVariantIndex("Some"))(_13.tuple_0.val_ref), read)
    unfold acc(m_U32Opt$_beg_$_end_Some:None(_13.tuple_0.val_ref[enum_Some]), read)
    _18.val_ref := borrow _13.tuple_0.val_ref[enum_Some].f$0 // L13
    inhale(Stmt) acc(u32(_18.val_ref), read)
    label l26
    // [mir] StorageLive(_19)
    // [mir] _19 = &'_ (((*(_13.1: &U32Opt)) as Some).0: u32)
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_ref, write)
    unfold acc(m_U32Opt$_beg_$_end_:Some(EnumVariantIndex("Some"))(_13.tuple_1.val_ref), read)
    unfold acc(m_U32Opt$_beg_$_end_Some:None(_13.tuple_1.val_ref[enum_Some]), read)
    _19.val_ref := borrow _13.tuple_1.val_ref[enum_Some].f$0 // L14
    inhale(Stmt) acc(u32(_19.val_ref), read)
    label l27
    // [mir] StorageLive(_20)
    // [mir] _20 = (*_18)
    _20 := builtin$havoc_ref()
    inhale(Stmt) acc(_20.val_int, write)
    unfold acc(u32:None(_18.val_ref), read)
    _20.val_int := copy _18.val_ref.val_int
    label l28
    // expire_borrows ReborrowingDAG(L13,L4,L7,)

    if (__t11) && (true) {
    // expire loan L13
    fold acc(u32:None(_18.val_ref), read)
    exhale acc(u32(_18.val_ref), read)
} else {}
    if (__t7) && ((__t11) && (true)) {
    // expire loan L4
    transfer perm _13.tuple_0.val_ref --> old[l21](_14.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && ((__t11) && (true))) {
    // expire loan L7
    transfer perm old[l21](_14.val_ref) --> old[l18](_14.val_ref) // unchecked: false
    fold acc(m_U32Opt$_beg_$_end_Some:None(old[l18](_14.val_ref)[enum_Some]), read)
    fold acc(m_U32Opt$_beg_$_end_:Some(EnumVariantIndex("Some"))(old[l18](_14.val_ref)), read)
    exhale acc(m_U32Opt$_beg_$_end_(old[l18](_14.val_ref)), read)
} else {}
    // [mir] StorageLive(_21)
    // [mir] _21 = (*_19)
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_int, write)
    unfold acc(u32:None(_19.val_ref), read)
    _21.val_int := copy _19.val_ref.val_int
    label l29
    // expire_borrows ReborrowingDAG(L14,L5,L12,)

    if (__t11) && (true) {
    // expire loan L14
    fold acc(u32:None(_19.val_ref), read)
    exhale acc(u32(_19.val_ref), read)
} else {}
    if (__t7) && ((__t11) && (true)) {
    // expire loan L5
    transfer perm _13.tuple_1.val_ref --> old[l21](_15.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && ((__t11) && (true))) {
    // expire loan L12
    transfer perm old[l21](_15.val_ref) --> old[l19](_15.val_ref) // unchecked: false
    fold acc(m_U32Opt$_beg_$_end_Some:None(old[l19](_15.val_ref)[enum_Some]), read)
    fold acc(m_U32Opt$_beg_$_end_:Some(EnumVariantIndex("Some"))(old[l19](_15.val_ref)), read)
    exhale acc(m_U32Opt$_beg_$_end_(old[l19](_15.val_ref)), read)
} else {}
    // [mir] _0 = Ne(move _20, move _21)
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_bool, write)
    _0.val_bool := copy !((_20.val_int) == (_21.val_int))
    // [mir] StorageDead(_21)
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_18)
    // [mir] goto -> bb13
    Goto(cfg:33)
  label bb13 // 26
    // ========== bb13 ==========
    __t12 := copy true
    // [mir] StorageDead(_13)
    // [mir] goto -> bb14
    Goto(cfg:34)
  label bb8 // 27
    // ========== bb8 ==========
    __t13 := copy true
    // [mir] _0 = const true
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_bool, write)
    _0.val_bool := copy true
    // [mir] goto -> bb14
    Goto(cfg:28)
  label bb14 // 28
    // ========== bb14 ==========
    __t14 := copy true
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l30 // 29
    // ========== l30 ==========
    unfold acc(isize:None(_6), write)
    unfold acc(isize:None(_3), write)
    Goto(cfg:13)
  label l32 // 30
    // ========== l32 ==========
    // drop Acc(_11.val_int, write) (Acc(_11.val_int, write))
    // drop Acc(_12.val_int, write) (Acc(_12.val_int, write))
    // drop Acc(_10.val_bool, write) (Acc(_10.val_bool, write))
    Goto(cfg:13)
  label l33 // 31
    // ========== l33 ==========
    // drop Acc(_12.val_int, write) (Acc(_12.val_int, write))
    // drop Acc(_11.val_int, write) (Acc(_11.val_int, write))
    // drop Acc(_10.val_bool, write) (Acc(_10.val_bool, write))
    Goto(cfg:14)
  label l34 // 32
    // ========== l34 ==========
    // drop Acc(_16.val_int, write) (Acc(_16.val_int, write))
    Goto(cfg:23)
  label l35 // 33
    // ========== l35 ==========
    // drop Acc(_20.val_int, write) (Acc(_20.val_int, write))
    // drop Acc(_21.val_int, write) (Acc(_21.val_int, write))
    // drop Acc(_16.val_int, write) (Acc(_16.val_int, write))
    // drop Acc(_19.val_ref, write) (Acc(_19.val_ref, write))
    // drop Acc(_18.val_ref, write) (Acc(_18.val_ref, write))
    // drop Acc(old[l18](_14.val_ref), write) (Acc(old[l18](_14.val_ref), write))
    // drop Acc(old[l19](_15.val_ref), write) (Acc(old[l19](_15.val_ref), write))
    Goto(cfg:26)
  label l36 // 34
    // ========== l36 ==========
    // drop Acc(_14.val_ref, write) (Acc(_14.val_ref, write))
    // drop Acc(_13.tuple_1.val_ref, write) (Acc(_13.tuple_1.val_ref, write))
    // drop Acc(_17.val_int, write) (Acc(_17.val_int, write))
    // drop Acc(_15.val_ref, write) (Acc(_15.val_ref, write))
    // drop Acc(_13.tuple_0.val_ref, write) (Acc(_13.tuple_0.val_ref, write))
    // drop Acc(_13.tuple_0, write) (Acc(_13.tuple_0, write))
    // drop Acc(_13.tuple_1, write) (Acc(_13.tuple_1, write))
    Goto(cfg:28)
  label end_of_method
}


struct_predicate m_Global$_beg_$_end_(self){
  true
}


struct_predicate raw_ref$bool(self);


struct_predicate m_PhantomData$_beg_$bool$_end_(self){
  true
}


struct_predicate m_Unique$_beg_$bool$_end_(self){
  (acc(self.f$pointer, write)) && ((acc(raw_ref$bool(self.f$pointer), write)) && ((acc(self.f$_marker, write)) && ((acc(m_PhantomData$_beg_$bool$_end_(self.f$_marker), write)) && (true))))
}


struct_predicate usize(self){
  (acc(self.val_int, write)) && (true)
}


struct_predicate m_RawVec$_beg_$bool$_sep_$m_Global$_beg_$_end_$_end_(self){
  (acc(self.f$ptr, write)) && ((acc(m_Unique$_beg_$bool$_end_(self.f$ptr), write)) && ((acc(self.f$cap, write)) && ((acc(usize(self.f$cap), write)) && ((acc(self.f$alloc, write)) && ((acc(m_Global$_beg_$_end_(self.f$alloc), write)) && (true))))))
}


struct_predicate m_Vec$_beg_$bool$_sep_$m_Global$_beg_$_end_$_end_(self){
  (acc(self.f$buf, write)) && ((acc(m_RawVec$_beg_$bool$_sep_$m_Global$_beg_$_end_$_end_(self.f$buf), write)) && ((acc(self.f$len, write)) && ((acc(usize(self.f$len), write)) && (true))))
}


struct_predicate m_BoolArr32$_beg_$_end_(self){
  (acc(self.f$v, write)) && ((acc(m_Vec$_beg_$bool$_sep_$m_Global$_beg_$_end_$_end_(self.f$v), write)) && (true))
}


struct_predicate closure$0_35$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_35$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_35$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate ref$usize(self){
  (acc(self.val_ref, write)) && ((acc(usize(self.val_ref), write)) && (true))
}


struct_predicate ref$m_BoolArr32$_beg_$_end_(self){
  (acc(self.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(self.val_ref), write)) && (true))
}


function m_len(_1: Ref(m_BoolArr32$_beg_$_end_)): Int
  requires (acc(m_BoolArr32$_beg_$_end_(_1), read)) && (true)
  requires true
  ensures ((__result) == (32)) && (true)


struct_predicate closure$0_38$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_38$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_38$3$7086023393399750873(self.val_ref), write)) && (true))
}


function builtin$unreach_bool(): Bool
  requires false


struct_predicate closure$0_39$3$6414429129475785409(self){
  true
}


struct_predicate ref$closure$0_39$3$6414429129475785409(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_39$3$6414429129475785409(self.val_ref), write)) && (true))
}


struct_predicate ref$ref$m_BoolArr32$_beg_$_end_(self){
  (acc(self.val_ref, write)) && ((acc(ref$m_BoolArr32$_beg_$_end_(self.val_ref), write)) && (true))
}


function m_lookup(_1: Ref(m_BoolArr32$_beg_$_end_), _2: Int): Bool
  requires (acc(m_BoolArr32$_beg_$_end_(_1), read)) && (true)
  requires (((0) <= (_2)) && (((_2) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_1))) && (true))) && (true)
  ensures true


struct_predicate tuple2$usize$bool(self){
  (acc(self.tuple_0, write)) && ((acc(usize(self.tuple_0), write)) && ((acc(self.tuple_1, write)) && ((acc(bool(self.tuple_1), write)) && (true))))
}


struct_predicate ref$bool(self){
  (acc(self.val_ref, write)) && ((acc(bool(self.val_ref), write)) && (true))
}


struct_predicate closure$0_64$3$8254256417185142312(self){
  true
}


struct_predicate closure$0_61$3$1829153966109688439(self){
  true
}


struct_predicate never(self);


struct_predicate closure$0_30$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_30$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_30$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_29$3$17634659329014786422(self){
  true
}


struct_predicate ref$closure$0_29$3$17634659329014786422(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_29$3$17634659329014786422(self.val_ref), write)) && (true))
}


struct_predicate closure$0_31$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_31$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_31$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_32$3$9259802854487030539(self){
  true
}


struct_predicate ref$closure$0_32$3$9259802854487030539(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_32$3$9259802854487030539(self.val_ref), write)) && (true))
}


struct_predicate closure$0_62$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_62$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_62$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_61$3$1829153966109688439(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_61$3$1829153966109688439(self.val_ref), write)) && (true))
}


struct_predicate closure$0_63$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_63$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_63$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_66$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_66$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_66$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_65$3$4992723542144595505(self){
  true
}


struct_predicate ref$closure$0_65$3$4992723542144595505(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_65$3$4992723542144595505(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_64$3$8254256417185142312(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_64$3$8254256417185142312(self.val_ref), write)) && (true))
}


struct_predicate closure$0_67$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_67$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_67$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_68$3$7279065880264243578(self){
  true
}


struct_predicate ref$closure$0_68$3$7279065880264243578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_68$3$7279065880264243578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_42$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_42$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_42$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_43$3$10245730116646881837(self){
  true
}


struct_predicate ref$closure$0_43$3$10245730116646881837(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_43$3$10245730116646881837(self.val_ref), write)) && (true))
}


struct_predicate closure$0_47$3$1273041844366931000(self){
  true
}


struct_predicate ref$closure$0_47$3$1273041844366931000(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_47$3$1273041844366931000(self.val_ref), write)) && (true))
}


struct_predicate closure$0_48$3$16112694639705422395(self){
  true
}


struct_predicate ref$closure$0_48$3$16112694639705422395(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_48$3$16112694639705422395(self.val_ref), write)) && (true))
}


struct_predicate ref$ref$bool(self){
  (acc(self.val_ref, write)) && ((acc(ref$bool(self.val_ref), write)) && (true))
}


struct_predicate closure$0_50$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_50$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_50$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_49$3$11407978568441892602(self){
  true
}


struct_predicate ref$closure$0_49$3$11407978568441892602(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_49$3$11407978568441892602(self.val_ref), write)) && (true))
}


struct_predicate closure$0_51$3$10245730116646881837(self){
  true
}


struct_predicate ref$closure$0_51$3$10245730116646881837(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_51$3$10245730116646881837(self.val_ref), write)) && (true))
}


struct_predicate closure$0_52$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_52$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_52$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_53$3$13497568945637489157(self){
  true
}


struct_predicate ref$closure$0_53$3$13497568945637489157(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_53$3$13497568945637489157(self.val_ref), write)) && (true))
}


struct_predicate closure$0_45$3$10154693838962823040(self){
  true
}


struct_predicate ref$closure$0_45$3$10154693838962823040(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_45$3$10154693838962823040(self.val_ref), write)) && (true))
}


struct_predicate closure$0_57$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_57$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_57$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_56$3$11193632173961701755(self){
  true
}


struct_predicate ref$closure$0_56$3$11193632173961701755(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_56$3$11193632173961701755(self.val_ref), write)) && (true))
}


struct_predicate closure$0_58$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_58$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_58$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_59$3$7279065880264243578(self){
  true
}


struct_predicate ref$closure$0_59$3$7279065880264243578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_59$3$7279065880264243578(self.val_ref), write)) && (true))
}


method m_flip_bits(1 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    _old$l13$0: Ref(bool)
    __t21: Bool
    __t22: Bool
    __t23: Bool
    _1: Ref(m_BoolArr32$_beg_$_end_)
    _2: Ref(m_BoolArr32$_beg_$_end_)
    _3: Ref(usize)
    _4: Ref(tuple0$)
    _5: Ref(tuple0$)
    _6: Ref(bool)
    _7: Ref(usize)
    _8: Ref(tuple0$)
    _9: Ref(bool)
    _10: Ref(closure$0_61$3$1829153966109688439)
    _11: Ref(ref$usize)
    _12: Ref(tuple0$)
    _13: Ref(bool)
    _14: Ref(closure$0_64$3$8254256417185142312)
    _15: Ref(ref$usize)
    _16: Ref(ref$m_BoolArr32$_beg_$_end_)
    _17: Ref(ref$m_BoolArr32$_beg_$_end_)
    _18: Ref(bool)
    _19: Ref(ref$m_BoolArr32$_beg_$_end_)
    _20: Ref(usize)
    _21: Ref(usize)
    _22: Ref(tuple2$usize$bool)
    _23: Ref(ref$bool)
    _24: Ref(ref$m_BoolArr32$_beg_$_end_)
    _25: Ref(usize)
    _26: Ref(tuple2$usize$bool)
    _27: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "bytevec::{impl#0}::flip_bits"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bytevec.rs:199:5: 220:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    __t16 := copy false
    // Preconditions:
    inhale(Stmt) (acc(m_BoolArr32$_beg_$_end_(_1), write)) && (true)
    inhale(Stmt) true
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_1)) && (true)
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l21
    // Fold predicates for &mut args and transfer borrow permissions to old
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_484867423a9d4da69dec2e9eb158073c_101: Int  :: (((0) <= (_2_forall_484867423a9d4da69dec2e9eb158073c_101)) && (((_2_forall_484867423a9d4da69dec2e9eb158073c_101) < (32)) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_484867423a9d4da69dec2e9eb158073c_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1, (31) - (_2_forall_484867423a9d4da69dec2e9eb158073c_101)))):(false))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale true
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_2)
    // [mir] _2 = BoolArr32::zero() -> [return: bb1, unwind: bb20]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _2 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_2), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_2)) && (true)
    inhale(Expr) (forall _2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101: Int  :: (((0) <= (_2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101)) && (((_2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2, _2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _2)
    // [mir] StorageLive(_3)
    // [mir] _3 = const 0_usize
    _3 := builtin$havoc_ref()
    inhale(Stmt) acc(_3.val_int, write)
    _3.val_int := copy 0
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb19]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] _7 = _3
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_int, write)
    _7.val_int := copy _3.val_int
    label l2
    // [mir] _6 = Lt(move _7, const 32_usize)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_bool, write)
    _6.val_bool := copy (_7.val_int) < (32)
    // [mir] StorageDead(_7)
    // [mir] FakeRead(ForMatchedPlace, _6)
    // [mir] switchInt(_6) -> [false: bb5, otherwise: bb4]
    __t17 := copy _6.val_bool
    GotoSwitch([(Local(__t17: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:29)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_8)
    // [mir] StorageLive(_9)
    // [mir] _9 = const false
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy false
    // [mir] switchInt(move _9) -> [false: bb8, otherwise: bb7]
    __t18 := copy _9.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_6), write)
    obtain acc(bool(_6), write)
    fold acc(usize:None(_3), write)
    obtain acc(usize(_3), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_2), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_1), read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_3), write) in _3.val_int))) && ((((unfolding acc(usize:None(_3), write) in _3.val_int)) < (32)) && (true))) && ((forall _2_forall_86120235b0324ba58d30e24cf5669724_101: Int  :: (((0) <= (_2_forall_86120235b0324ba58d30e24cf5669724_101)) && (((_2_forall_86120235b0324ba58d30e24cf5669724_101) < ((unfolding acc(usize:None(_3), write) in _3.val_int))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2, _2_forall_86120235b0324ba58d30e24cf5669724_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1, (31) - (_2_forall_86120235b0324ba58d30e24cf5669724_101)))):(false))) && (true))
    assert(Expr) true
    exhale (acc(bool(_6), write)) && ((acc(usize(_3), write)) && ((acc(m_BoolArr32$_beg_$_end_(_2), write)) && ((acc(m_BoolArr32$_beg_$_end_(_1), read)) && (true))))
    __t21 := builtin$havoc_bool()
    __t12 := builtin$havoc_bool()
    __t3 := builtin$havoc_bool()
    _3 := builtin$havoc_ref()
    __t23 := builtin$havoc_bool()
    __t19 := builtin$havoc_bool()
    __t6 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    _23 := builtin$havoc_ref()
    _9 := builtin$havoc_ref()
    __t2 := builtin$havoc_bool()
    _20 := builtin$havoc_ref()
    _7 := builtin$havoc_ref()
    __t22 := builtin$havoc_bool()
    __t10 := builtin$havoc_bool()
    __t8 := builtin$havoc_bool()
    _26 := builtin$havoc_ref()
    _24 := builtin$havoc_ref()
    __t20 := builtin$havoc_bool()
    _18 := builtin$havoc_ref()
    __t13 := builtin$havoc_bool()
    _13 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    __t7 := builtin$havoc_bool()
    _25 := builtin$havoc_ref()
    _22 := builtin$havoc_ref()
    _19 := builtin$havoc_ref()
    _21 := builtin$havoc_ref()
    _6 := builtin$havoc_ref()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_6), write)) && ((acc(usize(_3), write)) && ((acc(m_BoolArr32$_beg_$_end_(_2), write)) && ((acc(m_BoolArr32$_beg_$_end_(_1), read)) && (true))))
    inhale(Expr) true
    inhale(Expr) (((0) <= ((unfolding acc(usize:None(_3), write) in _3.val_int))) && ((((unfolding acc(usize:None(_3), write) in _3.val_int)) < (32)) && (true))) && ((forall _2_forall_86120235b0324ba58d30e24cf5669724_101: Int  :: (((0) <= (_2_forall_86120235b0324ba58d30e24cf5669724_101)) && (((_2_forall_86120235b0324ba58d30e24cf5669724_101) < ((unfolding acc(usize:None(_3), write) in _3.val_int))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2, _2_forall_86120235b0324ba58d30e24cf5669724_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1, (31) - (_2_forall_86120235b0324ba58d30e24cf5669724_101)))):(false))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _8 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_8)
    // [mir] StorageLive(_12)
    // [mir] StorageLive(_13)
    // [mir] _13 = const false
    _13 := builtin$havoc_ref()
    inhale(Stmt) acc(_13.val_bool, write)
    _13.val_bool := copy false
    // [mir] switchInt(move _13) -> [false: bb11, otherwise: bb10]
    __t19 := copy _13.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _12 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_13)
    // [mir] StorageDead(_12)
    // [mir] StorageLive(_18)
    // [mir] StorageLive(_19)
    // [mir] _19 = &'_ _1
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_ref, write)
    _19.val_ref := borrow _1 // L4
    exhale acc(m_BoolArr32$_beg_$_end_(_1), write-read)
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_19.val_ref), read)
    label l5
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = _3
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_int, write)
    unfold acc(usize:None(_3), write)
    _21.val_int := copy _3.val_int
    label l6
    // [mir] _22 = CheckedSub(const 31_usize, _21)
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.tuple_0, write)
    inhale(Stmt) acc(_22.tuple_0.val_int, write)
    inhale(Stmt) acc(_22.tuple_1, write)
    inhale(Stmt) acc(_22.tuple_1.val_bool, write)
    _22.tuple_0.val_int := copy (31) - (_21.val_int)
    _22.tuple_1.val_bool := copy false
    // [mir] assert(!move (_22.1: bool), "attempt to compute `{} - {}`, which would overflow", const 31_usize, move _21) -> [success: bb13, unwind: bb19]
    __t20 := copy _22.tuple_1.val_bool
    // Rust assertion: attempt to subtract with overflow
    assert(Stmt) !(__t20)
    Goto(cfg:17)
  label loop2_group3_bb13 // 17
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] _20 = move (_22.0: usize)
    _20 := move _22.tuple_0
    label l7
    // [mir] StorageDead(_21)
    // [mir] _18 = BoolArr32::lookup(move _19, move _20) -> [return: bb14, unwind: bb19]
    label l8
    _18 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_18), write)
    unfold acc(bool:None(_18), write)
    inhale(Stmt) (_18.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_19.val_ref, _20.val_int))
    transfer perm _19.val_ref --> old[l8](_19.val_ref) // unchecked: false
    Goto(cfg:18)
  label l9 // 18
    // ========== l9 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    // expire_borrows ReborrowingDAG(L10,L4,)

    if (__t10) && (true) {
    // expire loan L10
} else {}
    if (__t9) && ((__t10) && (true)) {
    // expire loan L4
    transfer perm old[l8](_19.val_ref) --> old[l5](_19.val_ref) // unchecked: false
    exhale acc(m_BoolArr32$_beg_$_end_(old[l5](_19.val_ref)), read)
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_1), write-read)
} else {}
    Goto(cfg:19)
  label loop2_group3_bb14 // 19
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_19)
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] _24 = &'_ mut _2
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(_24.val_ref, write)
    _24.val_ref := mut borrow _2 // L5
    label l10
    // [mir] StorageLive(_25)
    // [mir] _25 = _3
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_int, write)
    _25.val_int := copy _3.val_int
    label l11
    // [mir] _23 = BoolArr32::index_mut(move _24, move _25) -> [return: bb15, unwind: bb19]
    label l12
    assert(Stmt) (((0) <= (_25.val_int)) && (((_25.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_24.val_ref))) && (true))) && (true)
    fold acc(usize:None(_25), write)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_24)) && ((usize$inv<Ref(usize),Bool>(_25)) && (true))
    exhale (acc(_24.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_24.val_ref), write)) && ((acc(usize(_25), write)) && (true)))
    _23 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_23.val_ref, write)) && (acc(bool(_23.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_23)) && (true)
    inhale(Expr) (((unfolding acc(bool:None(_23.val_ref), write) in _23.val_ref.val_bool)) == (old[l12](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _25.val_int)))) && (true)
    exhale true
    label l13
    Goto(cfg:20)
  label loop2_group3_bb15 // 20
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_25)
    // [mir] StorageDead(_24)
    // [mir] (*_23) = move _18
    _23.val_ref := move _18
    label l14
    // expire_borrows ReborrowingDAG(L8,L9,L5,)

    if (__t11) && (true) {
    // expire loan L8
    _old$l13$0 := move _23.val_ref
    inhale(Stmt) (((acc(bool(_old$l13$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l13$0))) && ((true) && (true))) Some(L8) --* (((acc(m_BoolArr32$_beg_$_end_(old[l12](_24.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l12](_24.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l12](_24.val_ref))) == (old[l12](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_24.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l12](_24.val_ref), old[l12](_25.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l13$0), write) in _old$l13$0.val_bool)))) && ((forall _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103: Int  :: (((0) <= (_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) && (((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l12](_24.val_ref)))) && ((!((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) == (old[l12](_25.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l12](_24.val_ref), _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) == (old[l12](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103))))) && (true)))) && (true)))
    fold acc(bool:None(_old$l13$0), write)
    apply[L8] ((acc(bool(_old$l13$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l13$0))) && ((true) && (true)) --* ((acc(m_BoolArr32$_beg_$_end_(old[l12](_24.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l12](_24.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l12](_24.val_ref))) == (old[l12](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_24.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l12](_24.val_ref), old[l12](_25.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l13$0), write) in _old$l13$0.val_bool)))) && ((forall _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103: Int  :: (((0) <= (_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) && (((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l12](_24.val_ref)))) && ((!((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) == (old[l12](_25.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l12](_24.val_ref), _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) == (old[l12](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103))))) && (true)))) && (true))
    
} else {}
    if (__t11) && ((__t11) && (true)) {
    // expire loan L9
} else {}
    if (__t11) && ((__t11) && ((__t11) && (true))) {
    // expire loan L5
    transfer perm old[l12](_24.val_ref) --> old[l10](_24.val_ref) // unchecked: false
    transfer perm old[l10](_24.val_ref) --> _2 // unchecked: false
} else {}
    // [mir] StorageDead(_18)
    // [mir] StorageDead(_23)
    // [mir] _26 = CheckedAdd(_3, const 1_usize)
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.tuple_0, write)
    inhale(Stmt) acc(_26.tuple_0.val_int, write)
    inhale(Stmt) acc(_26.tuple_1, write)
    inhale(Stmt) acc(_26.tuple_1.val_bool, write)
    _26.tuple_0.val_int := copy (_3.val_int) + (1)
    _26.tuple_1.val_bool := copy false
    // [mir] assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_usize) -> [success: bb16, unwind: bb19]
    __t21 := copy _26.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t21)
    Goto(cfg:21)
  label loop2_group3_bb16 // 21
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _3 = move (_26.0: usize)
    _3 := move _26.tuple_0
    label l15
    // [mir] _5 = const ()
    // [mir] StorageDead(_6)
    // [mir] goto -> bb2
    Goto(cfg:22)
  label loop2_group4_bb2 // 22
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb19]
    Goto(cfg:23)
  label loop2_group4_bb3 // 23
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] _7 = _3
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_int, write)
    _7.val_int := copy _3.val_int
    label l16
    // [mir] _6 = Lt(move _7, const 32_usize)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_bool, write)
    _6.val_bool := copy (_7.val_int) < (32)
    // [mir] StorageDead(_7)
    // [mir] FakeRead(ForMatchedPlace, _6)
    // [mir] switchInt(_6) -> [false: bb5, otherwise: bb4]
    __t22 := copy _6.val_bool
    GotoSwitch([(Local(__t22: Bool, Position { line: 0, column: 0, id: 0 }), cfg:25)], cfg:24)
  label l17 // 24
    // ========== l17 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:32)
  label l18 // 25
    // ========== l18 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:26)
  label loop2_group5_bb4 // 26
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:27)
  label loop2_group5_bb6 // 27
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_8)
    // [mir] StorageLive(_9)
    // [mir] _9 = const false
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy false
    // [mir] switchInt(move _9) -> [false: bb8, otherwise: bb7]
    __t23 := copy _9.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:28)
  label loop2_end_body // 28
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_6), write)
    obtain acc(bool(_6), write)
    fold acc(usize:None(_3), write)
    obtain acc(usize(_3), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_2), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_1), read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_3), write) in _3.val_int))) && ((((unfolding acc(usize:None(_3), write) in _3.val_int)) < (32)) && (true))) && ((forall _2_forall_86120235b0324ba58d30e24cf5669724_101: Int  :: (((0) <= (_2_forall_86120235b0324ba58d30e24cf5669724_101)) && (((_2_forall_86120235b0324ba58d30e24cf5669724_101) < ((unfolding acc(usize:None(_3), write) in _3.val_int))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2, _2_forall_86120235b0324ba58d30e24cf5669724_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1, (31) - (_2_forall_86120235b0324ba58d30e24cf5669724_101)))):(false))) && (true))
    assert(Expr) true
    exhale (acc(bool(_6), write)) && ((acc(usize(_3), write)) && ((acc(m_BoolArr32$_beg_$_end_(_2), write)) && ((acc(m_BoolArr32$_beg_$_end_(_1), read)) && (true))))
    inhale(Stmt) false
    Return
  label bb5 // 29
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _4 = const ()
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_4)
    // [mir] _0 = move _2
    _0 := move _2
    label l19
    // [mir] StorageDead(_3)
    // [mir] drop(_2) -> [return: bb17, unwind: bb20]
    Goto(cfg:30)
  label bb17 // 30
    // ========== bb17 ==========
    __t15 := copy true
    // [mir] StorageDead(_2)
    // [mir] drop(_1) -> [return: bb18, unwind: bb21]
    Goto(cfg:31)
  label bb18 // 31
    // ========== bb18 ==========
    __t16 := copy true
    // [mir] return
    Goto(cfg:1)
  label l20 // 32
    // ========== l20 ==========
    // drop Acc(_20.val_int, write) (Acc(_20.val_int, write))
    // drop Acc(_19.val_ref, write) (Acc(_19.val_ref, write))
    // drop Acc(_26.tuple_0, write) (Acc(_26.tuple_0, write))
    // drop Acc(_22.tuple_1.val_bool, write) (Acc(_22.tuple_1.val_bool, write))
    // drop Acc(_22.tuple_0, write) (Acc(_22.tuple_0, write))
    // drop Acc(_26.tuple_1.val_bool, write) (Acc(_26.tuple_1.val_bool, write))
    // drop Acc(_23.val_ref, write) (Acc(_23.val_ref, write))
    // drop Acc(_13.val_bool, write) (Acc(_13.val_bool, write))
    // drop Acc(_21.val_int, write) (Acc(_21.val_int, write))
    // drop Acc(old[l5](_19.val_ref), write) (Acc(old[l5](_19.val_ref), write))
    // drop Acc(_22.tuple_1, write) (Acc(_22.tuple_1, write))
    // drop Acc(_26.tuple_1, write) (Acc(_26.tuple_1, write))
    Goto(cfg:29)
  label end_of_method
}


struct_predicate closure$0_86$3$1829153966109688439(self){
  true
}


struct_predicate closure$0_93$3$349836440838010910(self){
  true
}


struct_predicate closure$0_102$3$10449248484265987484(self){
  true
}


struct_predicate closure$0_89$3$7338871186369032412(self){
  true
}


struct_predicate closure$0_87$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_87$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_87$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_86$3$1829153966109688439(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_86$3$1829153966109688439(self.val_ref), write)) && (true))
}


struct_predicate closure$0_88$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_88$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_88$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_90$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_90$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_90$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_89$3$7338871186369032412(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_89$3$7338871186369032412(self.val_ref), write)) && (true))
}


struct_predicate closure$0_91$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_91$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_91$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_92$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_92$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_92$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_95$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_95$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_95$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_94$3$15414164260987694629(self){
  true
}


struct_predicate ref$closure$0_94$3$15414164260987694629(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_94$3$15414164260987694629(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_93$3$349836440838010910(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_93$3$349836440838010910(self.val_ref), write)) && (true))
}


struct_predicate closure$0_96$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_96$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_96$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_97$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_97$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_97$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_98$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_98$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_98$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_99$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_99$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_99$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_100$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_100$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_100$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_101$3$7102803714084766812(self){
  true
}


struct_predicate ref$closure$0_101$3$7102803714084766812(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_101$3$7102803714084766812(self.val_ref), write)) && (true))
}


struct_predicate closure$0_104$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_104$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_104$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_103$3$660500970111813152(self){
  true
}


struct_predicate ref$closure$0_103$3$660500970111813152(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_103$3$660500970111813152(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_102$3$10449248484265987484(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_102$3$10449248484265987484(self.val_ref), write)) && (true))
}


struct_predicate closure$0_105$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_105$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_105$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_106$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_106$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_106$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_107$3$9259802854487030539(self){
  true
}


struct_predicate ref$closure$0_107$3$9259802854487030539(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_107$3$9259802854487030539(self.val_ref), write)) && (true))
}


struct_predicate closure$0_70$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_70$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_70$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_73$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_73$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_73$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_72$3$8513623857961795843(self){
  true
}


struct_predicate ref$closure$0_72$3$8513623857961795843(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_72$3$8513623857961795843(self.val_ref), write)) && (true))
}


struct_predicate closure$0_74$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_74$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_74$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_75$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_75$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_75$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_76$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_76$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_76$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_77$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_77$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_77$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_78$3$7102803714084766812(self){
  true
}


struct_predicate ref$closure$0_78$3$7102803714084766812(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_78$3$7102803714084766812(self.val_ref), write)) && (true))
}


struct_predicate closure$0_81$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_81$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_81$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_80$3$660500970111813152(self){
  true
}


struct_predicate ref$closure$0_80$3$660500970111813152(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_80$3$660500970111813152(self.val_ref), write)) && (true))
}


struct_predicate closure$0_82$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_82$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_82$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_83$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_83$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_83$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_84$3$9259802854487030539(self){
  true
}


struct_predicate ref$closure$0_84$3$9259802854487030539(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_84$3$9259802854487030539(self.val_ref), write)) && (true))
}


method m_shl(2 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    __t21: Bool
    _preserve$0: Ref(AuxRef)
    __t22: Bool
    __t23: Bool
    __t24: Bool
    __t25: Bool
    _old$l15$0: Ref(bool)
    __t26: Bool
    __t27: Bool
    __t28: Bool
    _old$pre$0: Ref(m_BoolArr32$_beg_$_end_)
    _1: Ref(ref$m_BoolArr32$_beg_$_end_)
    _2: Ref(usize)
    _3: Ref(m_BoolArr32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_86$3$1829153966109688439)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_89$3$7338871186369032412)
    _16: Ref(ref$usize)
    _17: Ref(ref$usize)
    _18: Ref(tuple0$)
    _19: Ref(bool)
    _20: Ref(closure$0_93$3$349836440838010910)
    _21: Ref(ref$usize)
    _22: Ref(ref$usize)
    _23: Ref(ref$m_BoolArr32$_beg_$_end_)
    _24: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _25: Ref(tuple0$)
    _26: Ref(bool)
    _27: Ref(closure$0_102$3$10449248484265987484)
    _28: Ref(ref$usize)
    _29: Ref(ref$m_BoolArr32$_beg_$_end_)
    _30: Ref(bool)
    _31: Ref(ref$m_BoolArr32$_beg_$_end_)
    _32: Ref(usize)
    _33: Ref(usize)
    _34: Ref(usize)
    _35: Ref(tuple2$usize$bool)
    _36: Ref(ref$bool)
    _37: Ref(ref$m_BoolArr32$_beg_$_end_)
    _38: Ref(usize)
    _39: Ref(tuple2$usize$bool)
    _40: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "bytevec::{impl#0}::shl"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bytevec.rs:236:5: 266:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    __t16 := copy false
    __t17 := copy false
    __t18 := copy false
    __t19 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_1.val_ref), read)) && ((acc(usize(_2), write)) && (true)))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_1)) && ((usize$inv<Ref(usize),Bool>(_2)) && (true))
    inhale(Expr) ((0) <= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l23
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BoolArr32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_a50ca7b9e42141ce8c6e93f52947f251_101: Int  :: ((((0) <= (_2_forall_a50ca7b9e42141ce8c6e93f52947f251_101)) && (((_2_forall_a50ca7b9e42141ce8c6e93f52947f251_101) < (32)) && (true))) && ((((old[pre]((unfolding acc(usize:None(_2), write) in _2.val_int))) <= (_2_forall_a50ca7b9e42141ce8c6e93f52947f251_101)) && (((!(false))?(((_2_forall_a50ca7b9e42141ce8c6e93f52947f251_101) - (old[pre]((unfolding acc(usize:None(_2), write) in _2.val_int)))) >= (0)):(false)) && (((!(false))?(((_2_forall_a50ca7b9e42141ce8c6e93f52947f251_101) - (old[pre]((unfolding acc(usize:None(_2), write) in _2.val_int)))) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_a50ca7b9e42141ce8c6e93f52947f251_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$0, (_2_forall_a50ca7b9e42141ce8c6e93f52947f251_101) - (old[pre]((unfolding acc(usize:None(_2), write) in _2.val_int)))))):(false))) && ((forall _2_forall_e1acf97b0b6241d5963959ab6e48583e_101: Int  :: (((0) <= (_2_forall_e1acf97b0b6241d5963959ab6e48583e_101)) && (((_2_forall_e1acf97b0b6241d5963959ab6e48583e_101) < (old[pre]((unfolding acc(usize:None(_2), write) in _2.val_int)))) && (((_2_forall_e1acf97b0b6241d5963959ab6e48583e_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_e1acf97b0b6241d5963959ab6e48583e_101)))) && (true))
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BoolArr32$_beg_$_end_(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BoolArr32::zero() -> [return: bb1, unwind: bb25]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101: Int  :: (((0) <= (_2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101)) && (((_2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = _2
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    unfold acc(usize:None(_2), write)
    _4.val_int := copy _2.val_int
    label l2
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb24]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l3
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t20 := copy _7.val_bool
    GotoSwitch([(Local(__t20: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l4 // 7
    // ========== l4 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:33)
  label l5 // 8
    // ========== l5 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t21 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    fold acc(usize:None(_2), write)
    obtain acc(usize(_2), read)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && (((((unfolding acc(usize:None(_2), write) in _2.val_int)) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && ((forall _2_forall_cf72806affd94af38503c16b504c0dc8_101: Int  :: ((((0) <= (_2_forall_cf72806affd94af38503c16b504c0dc8_101)) && (((_2_forall_cf72806affd94af38503c16b504c0dc8_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (((_2_forall_cf72806affd94af38503c16b504c0dc8_101) >= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (true)))) && (((((unfolding acc(usize:None(_2), write) in _2.val_int)) <= (_2_forall_cf72806affd94af38503c16b504c0dc8_101)) && (((!(false))?(((_2_forall_cf72806affd94af38503c16b504c0dc8_101) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?(((_2_forall_cf72806affd94af38503c16b504c0dc8_101) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_cf72806affd94af38503c16b504c0dc8_101)) == ((unfolding acc(usize:None(_2), write) in m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, (_2_forall_cf72806affd94af38503c16b504c0dc8_101) - (_2.val_int))))):(false))) && ((forall _2_forall_09cbc0246ec04d76ab969ec00dddd5aa_101: Int  :: (((0) <= (_2_forall_09cbc0246ec04d76ab969ec00dddd5aa_101)) && (((_2_forall_09cbc0246ec04d76ab969ec00dddd5aa_101) < ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (((_2_forall_09cbc0246ec04d76ab969ec00dddd5aa_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_09cbc0246ec04d76ab969ec00dddd5aa_101)))) && (true))))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    __t17 := builtin$havoc_bool()
    _39 := builtin$havoc_ref()
    __t9 := builtin$havoc_bool()
    __t22 := builtin$havoc_bool()
    _38 := builtin$havoc_ref()
    __t24 := builtin$havoc_bool()
    __t14 := builtin$havoc_bool()
    __t28 := builtin$havoc_bool()
    __t3 := builtin$havoc_bool()
    __t16 := builtin$havoc_bool()
    _37 := builtin$havoc_ref()
    _7 := builtin$havoc_ref()
    _33 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    __t7 := builtin$havoc_bool()
    __t2 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    _8 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    _14 := builtin$havoc_ref()
    __t12 := builtin$havoc_bool()
    _31 := builtin$havoc_ref()
    _4 := builtin$havoc_ref()
    _34 := builtin$havoc_ref()
    __t26 := builtin$havoc_bool()
    __t27 := builtin$havoc_bool()
    _35 := builtin$havoc_ref()
    _36 := builtin$havoc_ref()
    _19 := builtin$havoc_ref()
    __t15 := builtin$havoc_bool()
    __t8 := builtin$havoc_bool()
    _10 := builtin$havoc_ref()
    __t13 := builtin$havoc_bool()
    _30 := builtin$havoc_ref()
    __t6 := builtin$havoc_bool()
    _26 := builtin$havoc_ref()
    __t25 := builtin$havoc_bool()
    _32 := builtin$havoc_ref()
    __t23 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    inhale(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && (((((unfolding acc(usize:None(_2), write) in _2.val_int)) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && ((forall _2_forall_cf72806affd94af38503c16b504c0dc8_101: Int  :: ((((0) <= (_2_forall_cf72806affd94af38503c16b504c0dc8_101)) && (((_2_forall_cf72806affd94af38503c16b504c0dc8_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (((_2_forall_cf72806affd94af38503c16b504c0dc8_101) >= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (true)))) && (((((unfolding acc(usize:None(_2), write) in _2.val_int)) <= (_2_forall_cf72806affd94af38503c16b504c0dc8_101)) && (((!(false))?(((_2_forall_cf72806affd94af38503c16b504c0dc8_101) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?(((_2_forall_cf72806affd94af38503c16b504c0dc8_101) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_cf72806affd94af38503c16b504c0dc8_101)) == ((unfolding acc(usize:None(_2), write) in m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, (_2_forall_cf72806affd94af38503c16b504c0dc8_101) - (_2.val_int))))):(false))) && ((forall _2_forall_09cbc0246ec04d76ab969ec00dddd5aa_101: Int  :: (((0) <= (_2_forall_09cbc0246ec04d76ab969ec00dddd5aa_101)) && (((_2_forall_09cbc0246ec04d76ab969ec00dddd5aa_101) < ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (((_2_forall_09cbc0246ec04d76ab969ec00dddd5aa_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_09cbc0246ec04d76ab969ec00dddd5aa_101)))) && (true))))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t22 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_18)
    // [mir] StorageLive(_19)
    // [mir] _19 = const false
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_bool, write)
    _19.val_bool := copy false
    // [mir] switchInt(move _19) -> [false: bb14, otherwise: bb13]
    __t23 := copy _19.val_bool
    // Ignore default target bb13, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:17)
  label loop2_group3_bb14 // 17
    // ========== loop2_group3_bb14 ==========
    __t10 := copy true
    // [mir] _18 = const ()
    // [mir] goto -> bb15
    Goto(cfg:18)
  label loop2_group3_bb15 // 18
    // ========== loop2_group3_bb15 ==========
    __t11 := copy true
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_18)
    // [mir] StorageLive(_25)
    // [mir] StorageLive(_26)
    // [mir] _26 = const false
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.val_bool, write)
    _26.val_bool := copy false
    // [mir] switchInt(move _26) -> [false: bb17, otherwise: bb16]
    __t24 := copy _26.val_bool
    // Ignore default target bb16, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:19)
  label loop2_group3_bb17 // 19
    // ========== loop2_group3_bb17 ==========
    __t12 := copy true
    // [mir] _25 = const ()
    // [mir] goto -> bb18
    Goto(cfg:20)
  label loop2_group3_bb18 // 20
    // ========== loop2_group3_bb18 ==========
    __t13 := copy true
    // [mir] StorageDead(_26)
    // [mir] StorageDead(_25)
    // [mir] StorageLive(_30)
    // [mir] StorageLive(_31)
    // [mir] _31 = &'_ (*_1)
    _31 := builtin$havoc_ref()
    inhale(Stmt) acc(_31.val_ref, write)
    _31.val_ref := borrow _1.val_ref // L13
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_31.val_ref), read)
    label l6
    // [mir] StorageLive(_32)
    // [mir] StorageLive(_33)
    // [mir] _33 = _4
    _33 := builtin$havoc_ref()
    inhale(Stmt) acc(_33.val_int, write)
    unfold acc(usize:None(_4), write)
    _33.val_int := copy _4.val_int
    label l7
    // [mir] StorageLive(_34)
    // [mir] _34 = _2
    _34 := builtin$havoc_ref()
    inhale(Stmt) acc(_34.val_int, write)
    unfold acc(usize:None(_2), write)
    _34.val_int := copy _2.val_int
    label l8
    // [mir] _35 = CheckedSub(_33, _34)
    _35 := builtin$havoc_ref()
    inhale(Stmt) acc(_35.tuple_0, write)
    inhale(Stmt) acc(_35.tuple_0.val_int, write)
    inhale(Stmt) acc(_35.tuple_1, write)
    inhale(Stmt) acc(_35.tuple_1.val_bool, write)
    _35.tuple_0.val_int := copy (_33.val_int) - (_34.val_int)
    _35.tuple_1.val_bool := copy false
    // [mir] assert(!move (_35.1: bool), "attempt to compute `{} - {}`, which would overflow", move _33, move _34) -> [success: bb19, unwind: bb24]
    __t25 := copy _35.tuple_1.val_bool
    // Rust assertion: attempt to subtract with overflow
    assert(Stmt) !(__t25)
    Goto(cfg:21)
  label loop2_group3_bb19 // 21
    // ========== loop2_group3_bb19 ==========
    __t14 := copy true
    // [mir] _32 = move (_35.0: usize)
    _32 := move _35.tuple_0
    label l9
    // [mir] StorageDead(_34)
    // [mir] StorageDead(_33)
    // [mir] _30 = BoolArr32::lookup(move _31, move _32) -> [return: bb20, unwind: bb24]
    label l10
    _30 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_30), write)
    unfold acc(bool:None(_30), write)
    inhale(Stmt) (_30.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_31.val_ref, _32.val_int))
    transfer perm _31.val_ref --> old[l10](_31.val_ref) // unchecked: false
    Goto(cfg:22)
  label l11 // 22
    // ========== l11 ==========
    // MIR edge bb19 --> bb20
    // Expire borrows
    // expire_borrows ReborrowingDAG(L16,L13,)

    if (__t14) && (true) {
    // expire loan L16
} else {}
    if (__t13) && ((__t14) && (true)) {
    // expire loan L13
    transfer perm old[l10](_31.val_ref) --> old[l6](_31.val_ref) // unchecked: false
    exhale acc(m_BoolArr32$_beg_$_end_(old[l6](_31.val_ref)), read)
} else {}
    Goto(cfg:23)
  label loop2_group3_bb20 // 23
    // ========== loop2_group3_bb20 ==========
    __t15 := copy true
    // [mir] StorageDead(_32)
    // [mir] StorageDead(_31)
    // [mir] StorageLive(_36)
    // [mir] StorageLive(_37)
    // [mir] _37 = &'_ mut _3
    _37 := builtin$havoc_ref()
    inhale(Stmt) acc(_37.val_ref, write)
    _37.val_ref := mut borrow _3 // L9
    label l12
    // [mir] StorageLive(_38)
    // [mir] _38 = _4
    _38 := builtin$havoc_ref()
    inhale(Stmt) acc(_38.val_int, write)
    _38.val_int := copy _4.val_int
    label l13
    // [mir] _36 = BoolArr32::index_mut(move _37, move _38) -> [return: bb21, unwind: bb24]
    label l14
    assert(Stmt) (((0) <= (_38.val_int)) && (((_38.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_37.val_ref))) && (true))) && (true)
    fold acc(usize:None(_38), write)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_37)) && ((usize$inv<Ref(usize),Bool>(_38)) && (true))
    exhale (acc(_37.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_37.val_ref), write)) && ((acc(usize(_38), write)) && (true)))
    _36 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_36.val_ref, write)) && (acc(bool(_36.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_36)) && (true)
    inhale(Expr) (((unfolding acc(bool:None(_36.val_ref), write) in _36.val_ref.val_bool)) == (old[l14](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_37.val_ref, _38.val_int)))) && (true)
    exhale true
    label l15
    Goto(cfg:24)
  label loop2_group3_bb21 // 24
    // ========== loop2_group3_bb21 ==========
    __t16 := copy true
    // [mir] StorageDead(_38)
    // [mir] StorageDead(_37)
    // [mir] (*_36) = move _30
    _36.val_ref := move _30
    label l16
    // expire_borrows ReborrowingDAG(L14,L15,L9,)

    if (__t15) && (true) {
    // expire loan L14
    _old$l15$0 := move _36.val_ref
    inhale(Stmt) (((acc(bool(_old$l15$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l15$0))) && ((true) && (true))) Some(L14) --* (((acc(m_BoolArr32$_beg_$_end_(old[l14](_37.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l14](_37.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_37.val_ref))) == (old[l14](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_37.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_37.val_ref), old[l14](_38.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l15$0), write) in _old$l15$0.val_bool)))) && ((forall _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103: Int  :: (((0) <= (_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) && (((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_37.val_ref)))) && ((!((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) == (old[l14](_38.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_37.val_ref), _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) == (old[l14](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_37.val_ref, _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103))))) && (true)))) && (true)))
    fold acc(bool:None(_old$l15$0), write)
    apply[L14] ((acc(bool(_old$l15$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l15$0))) && ((true) && (true)) --* ((acc(m_BoolArr32$_beg_$_end_(old[l14](_37.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l14](_37.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_37.val_ref))) == (old[l14](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_37.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_37.val_ref), old[l14](_38.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l15$0), write) in _old$l15$0.val_bool)))) && ((forall _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103: Int  :: (((0) <= (_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) && (((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_37.val_ref)))) && ((!((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) == (old[l14](_38.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_37.val_ref), _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) == (old[l14](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_37.val_ref, _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103))))) && (true)))) && (true))
    
} else {}
    if (__t15) && ((__t15) && (true)) {
    // expire loan L15
} else {}
    if (__t15) && ((__t15) && ((__t15) && (true))) {
    // expire loan L9
    transfer perm old[l14](_37.val_ref) --> old[l12](_37.val_ref) // unchecked: false
    transfer perm old[l12](_37.val_ref) --> _3 // unchecked: false
} else {}
    // [mir] StorageDead(_30)
    // [mir] StorageDead(_36)
    // [mir] _39 = CheckedAdd(_4, const 1_usize)
    _39 := builtin$havoc_ref()
    inhale(Stmt) acc(_39.tuple_0, write)
    inhale(Stmt) acc(_39.tuple_0.val_int, write)
    inhale(Stmt) acc(_39.tuple_1, write)
    inhale(Stmt) acc(_39.tuple_1.val_bool, write)
    _39.tuple_0.val_int := copy (_4.val_int) + (1)
    _39.tuple_1.val_bool := copy false
    // [mir] assert(!move (_39.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb22, unwind: bb24]
    __t26 := copy _39.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t26)
    Goto(cfg:25)
  label loop2_group3_bb22 // 25
    // ========== loop2_group3_bb22 ==========
    __t17 := copy true
    // [mir] _4 = move (_39.0: usize)
    _4 := move _39.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:26)
  label loop2_group4_bb2 // 26
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb24]
    Goto(cfg:27)
  label loop2_group4_bb3 // 27
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l18
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t27 := copy _7.val_bool
    GotoSwitch([(Local(__t27: Bool, Position { line: 0, column: 0, id: 0 }), cfg:29)], cfg:28)
  label l19 // 28
    // ========== l19 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:35)
  label l20 // 29
    // ========== l20 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:30)
  label loop2_group5_bb4 // 30
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:31)
  label loop2_group5_bb6 // 31
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t28 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:32)
  label loop2_end_body // 32
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    fold acc(usize:None(_2), write)
    obtain acc(usize(_2), read)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && (((((unfolding acc(usize:None(_2), write) in _2.val_int)) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && ((forall _2_forall_cf72806affd94af38503c16b504c0dc8_101: Int  :: ((((0) <= (_2_forall_cf72806affd94af38503c16b504c0dc8_101)) && (((_2_forall_cf72806affd94af38503c16b504c0dc8_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (((_2_forall_cf72806affd94af38503c16b504c0dc8_101) >= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (true)))) && (((((unfolding acc(usize:None(_2), write) in _2.val_int)) <= (_2_forall_cf72806affd94af38503c16b504c0dc8_101)) && (((!(false))?(((_2_forall_cf72806affd94af38503c16b504c0dc8_101) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?(((_2_forall_cf72806affd94af38503c16b504c0dc8_101) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_cf72806affd94af38503c16b504c0dc8_101)) == ((unfolding acc(usize:None(_2), write) in m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, (_2_forall_cf72806affd94af38503c16b504c0dc8_101) - (_2.val_int))))):(false))) && ((forall _2_forall_09cbc0246ec04d76ab969ec00dddd5aa_101: Int  :: (((0) <= (_2_forall_09cbc0246ec04d76ab969ec00dddd5aa_101)) && (((_2_forall_09cbc0246ec04d76ab969ec00dddd5aa_101) < ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (((_2_forall_09cbc0246ec04d76ab969ec00dddd5aa_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_09cbc0246ec04d76ab969ec00dddd5aa_101)))) && (true))))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 33
    // ========== bb5 ==========
    __t18 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l21
    // [mir] StorageDead(_4)
    // [mir] drop(_3) -> [return: bb23, unwind: bb25]
    Goto(cfg:34)
  label bb23 // 34
    // ========== bb23 ==========
    __t19 := copy true
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l22 // 35
    // ========== l22 ==========
    // drop Acc(old[l6](_31.val_ref), write) (Acc(old[l6](_31.val_ref), write))
    // drop Acc(_39.tuple_1.val_bool, write) (Acc(_39.tuple_1.val_bool, write))
    // drop Acc(_35.tuple_0, write) (Acc(_35.tuple_0, write))
    // drop Acc(_31.val_ref, write) (Acc(_31.val_ref, write))
    // drop Acc(_33.val_int, write) (Acc(_33.val_int, write))
    // drop Acc(_19.val_bool, write) (Acc(_19.val_bool, write))
    // drop Acc(_35.tuple_1.val_bool, write) (Acc(_35.tuple_1.val_bool, write))
    // drop Acc(_14.val_bool, write) (Acc(_14.val_bool, write))
    // drop Acc(_39.tuple_0, write) (Acc(_39.tuple_0, write))
    // drop Acc(_32.val_int, write) (Acc(_32.val_int, write))
    // drop Acc(_26.val_bool, write) (Acc(_26.val_bool, write))
    // drop Acc(_34.val_int, write) (Acc(_34.val_int, write))
    // drop Acc(_36.val_ref, write) (Acc(_36.val_ref, write))
    // drop Acc(_35.tuple_1, write) (Acc(_35.tuple_1, write))
    // drop Acc(_39.tuple_1, write) (Acc(_39.tuple_1, write))
    Goto(cfg:33)
  label end_of_method
}


struct_predicate closure$0_124$3$10449248484265987484(self){
  true
}


struct_predicate closure$0_117$3$1829153966109688439(self){
  true
}


struct_predicate closure$0_120$3$7338871186369032412(self){
  true
}


struct_predicate closure$0_118$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_118$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_118$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_117$3$1829153966109688439(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_117$3$1829153966109688439(self.val_ref), write)) && (true))
}


struct_predicate closure$0_119$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_119$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_119$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_121$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_121$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_121$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_120$3$7338871186369032412(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_120$3$7338871186369032412(self.val_ref), write)) && (true))
}


struct_predicate closure$0_122$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_122$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_122$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_123$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_123$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_123$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_126$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_126$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_126$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_125$3$660500970111813152(self){
  true
}


struct_predicate ref$closure$0_125$3$660500970111813152(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_125$3$660500970111813152(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_124$3$10449248484265987484(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_124$3$10449248484265987484(self.val_ref), write)) && (true))
}


struct_predicate closure$0_127$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_127$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_127$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_128$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_128$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_128$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_129$3$9259802854487030539(self){
  true
}


struct_predicate ref$closure$0_129$3$9259802854487030539(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_129$3$9259802854487030539(self.val_ref), write)) && (true))
}


struct_predicate closure$0_109$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_109$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_109$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_112$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_112$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_112$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_111$3$660500970111813152(self){
  true
}


struct_predicate ref$closure$0_111$3$660500970111813152(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_111$3$660500970111813152(self.val_ref), write)) && (true))
}


struct_predicate closure$0_113$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_113$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_113$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_114$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_114$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_114$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_115$3$9259802854487030539(self){
  true
}


struct_predicate ref$closure$0_115$3$9259802854487030539(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_115$3$9259802854487030539(self.val_ref), write)) && (true))
}


method m_shr(2 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    __t18: Bool
    __t19: Bool
    _preserve$0: Ref(AuxRef)
    __t20: Bool
    __t21: Bool
    __t22: Bool
    _old$l15$0: Ref(bool)
    __t23: Bool
    __t24: Bool
    __t25: Bool
    _old$pre$0: Ref(m_BoolArr32$_beg_$_end_)
    _1: Ref(ref$m_BoolArr32$_beg_$_end_)
    _2: Ref(usize)
    _3: Ref(m_BoolArr32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_117$3$1829153966109688439)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_120$3$7338871186369032412)
    _16: Ref(ref$usize)
    _17: Ref(ref$usize)
    _18: Ref(tuple0$)
    _19: Ref(bool)
    _20: Ref(closure$0_124$3$10449248484265987484)
    _21: Ref(ref$usize)
    _22: Ref(ref$m_BoolArr32$_beg_$_end_)
    _23: Ref(bool)
    _24: Ref(ref$m_BoolArr32$_beg_$_end_)
    _25: Ref(usize)
    _26: Ref(ref$bool)
    _27: Ref(ref$m_BoolArr32$_beg_$_end_)
    _28: Ref(usize)
    _29: Ref(usize)
    _30: Ref(usize)
    _31: Ref(tuple2$usize$bool)
    _32: Ref(tuple2$usize$bool)
    _33: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "bytevec::{impl#0}::shr"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bytevec.rs:284:5: 317:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    __t16 := copy false
    __t17 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_1.val_ref), read)) && ((acc(usize(_2), write)) && (true)))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_1)) && ((usize$inv<Ref(usize),Bool>(_2)) && (true))
    inhale(Expr) ((0) <= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l23
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BoolArr32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_e34970f2e5ca485da923ff0211d84c22_101: Int  :: (((0) <= (_2_forall_e34970f2e5ca485da923ff0211d84c22_101)) && (((!(false))?((_2_forall_e34970f2e5ca485da923ff0211d84c22_101) > ((32) - (old[pre]((unfolding acc(usize:None(_2), write) in _2.val_int))))):(false)) && (((_2_forall_e34970f2e5ca485da923ff0211d84c22_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_e34970f2e5ca485da923ff0211d84c22_101)))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BoolArr32$_beg_$_end_(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BoolArr32::zero() -> [return: bb1, unwind: bb22]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101: Int  :: (((0) <= (_2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101)) && (((_2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = _2
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    unfold acc(usize:None(_2), write)
    _4.val_int := copy _2.val_int
    label l2
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb21]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l3
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t18 := copy _7.val_bool
    GotoSwitch([(Local(__t18: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l4 // 7
    // ========== l4 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l5 // 8
    // ========== l5 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t19 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    fold acc(usize:None(_2), write)
    obtain acc(usize(_2), read)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && (((((unfolding acc(usize:None(_4), write) in _4.val_int)) >= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && ((forall _2_forall_9ae6893645a84c07b969a6e6d21e177f_101: Int  :: (((0) <= (_2_forall_9ae6893645a84c07b969a6e6d21e177f_101)) && (((!(false))?((_2_forall_9ae6893645a84c07b969a6e6d21e177f_101) > ((32) - ((unfolding acc(usize:None(_2), write) in _2.val_int)))):(false)) && (((_2_forall_9ae6893645a84c07b969a6e6d21e177f_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_9ae6893645a84c07b969a6e6d21e177f_101)))) && (true)))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    __t9 := builtin$havoc_bool()
    _32 := builtin$havoc_ref()
    __t13 := builtin$havoc_bool()
    __t8 := builtin$havoc_bool()
    _23 := builtin$havoc_ref()
    _24 := builtin$havoc_ref()
    __t15 := builtin$havoc_bool()
    _7 := builtin$havoc_ref()
    _19 := builtin$havoc_ref()
    __t2 := builtin$havoc_bool()
    __t25 := builtin$havoc_bool()
    __t14 := builtin$havoc_bool()
    _28 := builtin$havoc_ref()
    _26 := builtin$havoc_ref()
    __t12 := builtin$havoc_bool()
    __t20 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    __t6 := builtin$havoc_bool()
    _4 := builtin$havoc_ref()
    _14 := builtin$havoc_ref()
    _31 := builtin$havoc_ref()
    _10 := builtin$havoc_ref()
    __t22 := builtin$havoc_bool()
    __t10 := builtin$havoc_bool()
    __t24 := builtin$havoc_bool()
    __t23 := builtin$havoc_bool()
    __t4 := builtin$havoc_bool()
    _27 := builtin$havoc_ref()
    _30 := builtin$havoc_ref()
    __t21 := builtin$havoc_bool()
    __t7 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    _8 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    _29 := builtin$havoc_ref()
    _25 := builtin$havoc_ref()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    inhale(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && (((((unfolding acc(usize:None(_4), write) in _4.val_int)) >= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && ((forall _2_forall_9ae6893645a84c07b969a6e6d21e177f_101: Int  :: (((0) <= (_2_forall_9ae6893645a84c07b969a6e6d21e177f_101)) && (((!(false))?((_2_forall_9ae6893645a84c07b969a6e6d21e177f_101) > ((32) - ((unfolding acc(usize:None(_2), write) in _2.val_int)))):(false)) && (((_2_forall_9ae6893645a84c07b969a6e6d21e177f_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_9ae6893645a84c07b969a6e6d21e177f_101)))) && (true)))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t20 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_18)
    // [mir] StorageLive(_19)
    // [mir] _19 = const false
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_bool, write)
    _19.val_bool := copy false
    // [mir] switchInt(move _19) -> [false: bb14, otherwise: bb13]
    __t21 := copy _19.val_bool
    // Ignore default target bb13, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:17)
  label loop2_group3_bb14 // 17
    // ========== loop2_group3_bb14 ==========
    __t10 := copy true
    // [mir] _18 = const ()
    // [mir] goto -> bb15
    Goto(cfg:18)
  label loop2_group3_bb15 // 18
    // ========== loop2_group3_bb15 ==========
    __t11 := copy true
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_18)
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] _24 = &'_ (*_1)
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(_24.val_ref, write)
    _24.val_ref := borrow _1.val_ref // L11
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_24.val_ref), read)
    label l6
    // [mir] StorageLive(_25)
    // [mir] _25 = _4
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_int, write)
    unfold acc(usize:None(_4), write)
    _25.val_int := copy _4.val_int
    label l7
    // [mir] _23 = BoolArr32::lookup(move _24, move _25) -> [return: bb16, unwind: bb21]
    label l8
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_23), write)
    unfold acc(bool:None(_23), write)
    inhale(Stmt) (_23.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _25.val_int))
    transfer perm _24.val_ref --> old[l8](_24.val_ref) // unchecked: false
    Goto(cfg:19)
  label l9 // 19
    // ========== l9 ==========
    // MIR edge bb15 --> bb16
    // Expire borrows
    // expire_borrows ReborrowingDAG(L12,L11,)

    if (__t11) && (true) {
    // expire loan L12
} else {}
    if (__t11) && ((__t11) && (true)) {
    // expire loan L11
    transfer perm old[l8](_24.val_ref) --> old[l6](_24.val_ref) // unchecked: false
    exhale acc(m_BoolArr32$_beg_$_end_(old[l6](_24.val_ref)), read)
} else {}
    Goto(cfg:20)
  label loop2_group3_bb16 // 20
    // ========== loop2_group3_bb16 ==========
    __t12 := copy true
    // [mir] StorageDead(_25)
    // [mir] StorageDead(_24)
    // [mir] StorageLive(_26)
    // [mir] StorageLive(_27)
    // [mir] _27 = &'_ mut _3
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(_27.val_ref, write)
    _27.val_ref := mut borrow _3 // L5
    label l10
    // [mir] StorageLive(_28)
    // [mir] StorageLive(_29)
    // [mir] _29 = _4
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.val_int, write)
    _29.val_int := copy _4.val_int
    label l11
    // [mir] StorageLive(_30)
    // [mir] _30 = _2
    _30 := builtin$havoc_ref()
    inhale(Stmt) acc(_30.val_int, write)
    unfold acc(usize:None(_2), write)
    _30.val_int := copy _2.val_int
    label l12
    // [mir] _31 = CheckedSub(_29, _30)
    _31 := builtin$havoc_ref()
    inhale(Stmt) acc(_31.tuple_0, write)
    inhale(Stmt) acc(_31.tuple_0.val_int, write)
    inhale(Stmt) acc(_31.tuple_1, write)
    inhale(Stmt) acc(_31.tuple_1.val_bool, write)
    _31.tuple_0.val_int := copy (_29.val_int) - (_30.val_int)
    _31.tuple_1.val_bool := copy false
    // [mir] assert(!move (_31.1: bool), "attempt to compute `{} - {}`, which would overflow", move _29, move _30) -> [success: bb17, unwind: bb21]
    __t22 := copy _31.tuple_1.val_bool
    // Rust assertion: attempt to subtract with overflow
    assert(Stmt) !(__t22)
    Goto(cfg:21)
  label loop2_group3_bb17 // 21
    // ========== loop2_group3_bb17 ==========
    __t13 := copy true
    // [mir] _28 = move (_31.0: usize)
    _28 := move _31.tuple_0
    label l13
    // [mir] StorageDead(_30)
    // [mir] StorageDead(_29)
    // [mir] _26 = BoolArr32::index_mut(move _27, move _28) -> [return: bb18, unwind: bb21]
    label l14
    assert(Stmt) (((0) <= (_28.val_int)) && (((_28.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref))) && (true))) && (true)
    fold acc(usize:None(_28), write)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_27)) && ((usize$inv<Ref(usize),Bool>(_28)) && (true))
    exhale (acc(_27.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_27.val_ref), write)) && ((acc(usize(_28), write)) && (true)))
    _26 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_26.val_ref, write)) && (acc(bool(_26.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_26)) && (true)
    inhale(Expr) (((unfolding acc(bool:None(_26.val_ref), write) in _26.val_ref.val_bool)) == (old[l14](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _28.val_int)))) && (true)
    exhale true
    label l15
    Goto(cfg:22)
  label loop2_group3_bb18 // 22
    // ========== loop2_group3_bb18 ==========
    __t14 := copy true
    // [mir] StorageDead(_28)
    // [mir] StorageDead(_27)
    // [mir] (*_26) = move _23
    _26.val_ref := move _23
    label l16
    // expire_borrows ReborrowingDAG(L9,L10,L5,)

    if (__t13) && (true) {
    // expire loan L9
    _old$l15$0 := move _26.val_ref
    inhale(Stmt) (((acc(bool(_old$l15$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l15$0))) && ((true) && (true))) Some(L9) --* (((acc(m_BoolArr32$_beg_$_end_(old[l14](_27.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l14](_27.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_27.val_ref))) == (old[l14](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_27.val_ref), old[l14](_28.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l15$0), write) in _old$l15$0.val_bool)))) && ((forall _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103: Int  :: (((0) <= (_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) && (((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_27.val_ref)))) && ((!((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) == (old[l14](_28.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_27.val_ref), _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) == (old[l14](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103))))) && (true)))) && (true)))
    fold acc(bool:None(_old$l15$0), write)
    apply[L9] ((acc(bool(_old$l15$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l15$0))) && ((true) && (true)) --* ((acc(m_BoolArr32$_beg_$_end_(old[l14](_27.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l14](_27.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_27.val_ref))) == (old[l14](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_27.val_ref), old[l14](_28.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l15$0), write) in _old$l15$0.val_bool)))) && ((forall _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103: Int  :: (((0) <= (_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) && (((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_27.val_ref)))) && ((!((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) == (old[l14](_28.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_27.val_ref), _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) == (old[l14](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103))))) && (true)))) && (true))
    
} else {}
    if (__t13) && ((__t13) && (true)) {
    // expire loan L10
} else {}
    if (__t12) && ((__t13) && ((__t13) && (true))) {
    // expire loan L5
    transfer perm old[l14](_27.val_ref) --> old[l10](_27.val_ref) // unchecked: false
    transfer perm old[l10](_27.val_ref) --> _3 // unchecked: false
} else {}
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_26)
    // [mir] _32 = CheckedAdd(_4, const 1_usize)
    _32 := builtin$havoc_ref()
    inhale(Stmt) acc(_32.tuple_0, write)
    inhale(Stmt) acc(_32.tuple_0.val_int, write)
    inhale(Stmt) acc(_32.tuple_1, write)
    inhale(Stmt) acc(_32.tuple_1.val_bool, write)
    _32.tuple_0.val_int := copy (_4.val_int) + (1)
    _32.tuple_1.val_bool := copy false
    // [mir] assert(!move (_32.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb19, unwind: bb21]
    __t23 := copy _32.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t23)
    Goto(cfg:23)
  label loop2_group3_bb19 // 23
    // ========== loop2_group3_bb19 ==========
    __t15 := copy true
    // [mir] _4 = move (_32.0: usize)
    _4 := move _32.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:24)
  label loop2_group4_bb2 // 24
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb21]
    Goto(cfg:25)
  label loop2_group4_bb3 // 25
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l18
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t24 := copy _7.val_bool
    GotoSwitch([(Local(__t24: Bool, Position { line: 0, column: 0, id: 0 }), cfg:27)], cfg:26)
  label l19 // 26
    // ========== l19 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:33)
  label l20 // 27
    // ========== l20 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:28)
  label loop2_group5_bb4 // 28
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:29)
  label loop2_group5_bb6 // 29
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t25 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:30)
  label loop2_end_body // 30
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    fold acc(usize:None(_2), write)
    obtain acc(usize(_2), read)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && (((((unfolding acc(usize:None(_4), write) in _4.val_int)) >= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && ((forall _2_forall_9ae6893645a84c07b969a6e6d21e177f_101: Int  :: (((0) <= (_2_forall_9ae6893645a84c07b969a6e6d21e177f_101)) && (((!(false))?((_2_forall_9ae6893645a84c07b969a6e6d21e177f_101) > ((32) - ((unfolding acc(usize:None(_2), write) in _2.val_int)))):(false)) && (((_2_forall_9ae6893645a84c07b969a6e6d21e177f_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_9ae6893645a84c07b969a6e6d21e177f_101)))) && (true)))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 31
    // ========== bb5 ==========
    __t16 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l21
    // [mir] StorageDead(_4)
    // [mir] drop(_3) -> [return: bb20, unwind: bb22]
    Goto(cfg:32)
  label bb20 // 32
    // ========== bb20 ==========
    __t17 := copy true
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l22 // 33
    // ========== l22 ==========
    // drop Acc(_25.val_int, write) (Acc(_25.val_int, write))
    // drop Acc(_26.val_ref, write) (Acc(_26.val_ref, write))
    // drop Acc(_24.val_ref, write) (Acc(_24.val_ref, write))
    // drop Acc(_30.val_int, write) (Acc(_30.val_int, write))
    // drop Acc(old[l6](_24.val_ref), write) (Acc(old[l6](_24.val_ref), write))
    // drop Acc(_31.tuple_1.val_bool, write) (Acc(_31.tuple_1.val_bool, write))
    // drop Acc(_32.tuple_1.val_bool, write) (Acc(_32.tuple_1.val_bool, write))
    // drop Acc(_19.val_bool, write) (Acc(_19.val_bool, write))
    // drop Acc(_29.val_int, write) (Acc(_29.val_int, write))
    // drop Acc(_31.tuple_0, write) (Acc(_31.tuple_0, write))
    // drop Acc(_14.val_bool, write) (Acc(_14.val_bool, write))
    // drop Acc(_32.tuple_0, write) (Acc(_32.tuple_0, write))
    // drop Acc(_32.tuple_1, write) (Acc(_32.tuple_1, write))
    // drop Acc(_31.tuple_1, write) (Acc(_31.tuple_1, write))
    Goto(cfg:31)
  label end_of_method
}


struct_predicate closure$0_139$3$16802519762636729328(self){
  true
}


struct_predicate closure$0_136$3$1829153966109688439(self){
  true
}


struct_predicate closure$0_137$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_137$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_137$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_136$3$1829153966109688439(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_136$3$1829153966109688439(self.val_ref), write)) && (true))
}


struct_predicate closure$0_138$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_138$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_138$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_141$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_141$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_141$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_140$3$8668476983963327591(self){
  true
}


struct_predicate ref$closure$0_140$3$8668476983963327591(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_140$3$8668476983963327591(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_139$3$16802519762636729328(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_139$3$16802519762636729328(self.val_ref), write)) && (true))
}


struct_predicate closure$0_142$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_142$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_142$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_143$3$11489740734085331380(self){
  true
}


struct_predicate ref$closure$0_143$3$11489740734085331380(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_143$3$11489740734085331380(self.val_ref), write)) && (true))
}


struct_predicate closure$0_132$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_132$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_132$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_131$3$11538186059445744466(self){
  true
}


struct_predicate ref$closure$0_131$3$11538186059445744466(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_131$3$11538186059445744466(self.val_ref), write)) && (true))
}


struct_predicate closure$0_133$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_133$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_133$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_134$3$11489740734085331380(self){
  true
}


struct_predicate ref$closure$0_134$3$11489740734085331380(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_134$3$11489740734085331380(self.val_ref), write)) && (true))
}


method m_or(2 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t18: Bool
    _old$l16$0: Ref(bool)
    __t19: Bool
    __t20: Bool
    __t21: Bool
    _old$pre$0: Ref(m_BoolArr32$_beg_$_end_)
    _old$pre$1: Ref(m_BoolArr32$_beg_$_end_)
    _1: Ref(ref$m_BoolArr32$_beg_$_end_)
    _2: Ref(ref$m_BoolArr32$_beg_$_end_)
    _3: Ref(m_BoolArr32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_136$3$1829153966109688439)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_139$3$16802519762636729328)
    _16: Ref(ref$usize)
    _17: Ref(ref$m_BoolArr32$_beg_$_end_)
    _18: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _19: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _20: Ref(bool)
    _21: Ref(ref$m_BoolArr32$_beg_$_end_)
    _22: Ref(usize)
    _23: Ref(bool)
    _24: Ref(ref$m_BoolArr32$_beg_$_end_)
    _25: Ref(usize)
    _26: Ref(ref$bool)
    _27: Ref(ref$m_BoolArr32$_beg_$_end_)
    _28: Ref(usize)
    _29: Ref(tuple2$usize$bool)
    _30: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "bytevec::{impl#0}::or"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bytevec.rs:324:5: 338:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_1)) && ((ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l23
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BoolArr32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BoolArr32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_982a40ff83d042d6b81f45ed1f4880d0_101: Int  :: (((0) <= (_2_forall_982a40ff83d042d6b81f45ed1f4880d0_101)) && (((_2_forall_982a40ff83d042d6b81f45ed1f4880d0_101) < (32)) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_982a40ff83d042d6b81f45ed1f4880d0_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$0, _2_forall_982a40ff83d042d6b81f45ed1f4880d0_101)) || (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$1, _2_forall_982a40ff83d042d6b81f45ed1f4880d0_101))))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BoolArr32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BoolArr32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BoolArr32::zero() -> [return: bb1, unwind: bb19]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101: Int  :: (((0) <= (_2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101)) && (((_2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = const 0_usize
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy 0
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb18]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l2
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t16 := copy _7.val_bool
    GotoSwitch([(Local(__t16: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:30)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t17 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$1 := ghost _2.val_ref
    _preserve$0 := ghost _1.val_ref
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_69c1cb6cf37f42139c0b79b67900def8_101: Int  :: (((0) <= (_2_forall_69c1cb6cf37f42139c0b79b67900def8_101)) && (((_2_forall_69c1cb6cf37f42139c0b79b67900def8_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_69c1cb6cf37f42139c0b79b67900def8_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_69c1cb6cf37f42139c0b79b67900def8_101)) || (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_69c1cb6cf37f42139c0b79b67900def8_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    __t12 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    _22 := builtin$havoc_ref()
    _26 := builtin$havoc_ref()
    _23 := builtin$havoc_ref()
    __t21 := builtin$havoc_bool()
    _25 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    __t6 := builtin$havoc_bool()
    _24 := builtin$havoc_ref()
    __t11 := builtin$havoc_bool()
    __t10 := builtin$havoc_bool()
    _29 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    _8 := builtin$havoc_ref()
    _4 := builtin$havoc_ref()
    _27 := builtin$havoc_ref()
    __t20 := builtin$havoc_bool()
    _10 := builtin$havoc_ref()
    __t18 := builtin$havoc_bool()
    __t19 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    _7 := builtin$havoc_ref()
    _20 := builtin$havoc_ref()
    __t9 := builtin$havoc_bool()
    __t4 := builtin$havoc_bool()
    _21 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    __t2 := builtin$havoc_bool()
    _28 := builtin$havoc_ref()
    _14 := builtin$havoc_ref()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_69c1cb6cf37f42139c0b79b67900def8_101: Int  :: (((0) <= (_2_forall_69c1cb6cf37f42139c0b79b67900def8_101)) && (((_2_forall_69c1cb6cf37f42139c0b79b67900def8_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_69c1cb6cf37f42139c0b79b67900def8_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_69c1cb6cf37f42139c0b79b67900def8_101)) || (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_69c1cb6cf37f42139c0b79b67900def8_101))))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t18 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'_ (*_1)
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_ref, write)
    _21.val_ref := borrow _1.val_ref // L11
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_21.val_ref), read)
    label l5
    // [mir] StorageLive(_22)
    // [mir] _22 = _4
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_int, write)
    unfold acc(usize:None(_4), write)
    _22.val_int := copy _4.val_int
    label l6
    // [mir] _20 = BoolArr32::lookup(move _21, move _22) -> [return: bb13, unwind: bb18]
    label l7
    _20 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_20), write)
    unfold acc(bool:None(_20), write)
    inhale(Stmt) (_20.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_21.val_ref, _22.val_int))
    transfer perm _21.val_ref --> old[l7](_21.val_ref) // unchecked: false
    Goto(cfg:17)
  label l8 // 17
    // ========== l8 ==========
    // MIR edge bb12 --> bb13
    // Expire borrows
    // expire_borrows ReborrowingDAG(L10,L11,)

    if (__t9) && (true) {
    // expire loan L10
} else {}
    if (__t9) && ((__t9) && (true)) {
    // expire loan L11
    transfer perm old[l7](_21.val_ref) --> old[l5](_21.val_ref) // unchecked: false
    exhale acc(m_BoolArr32$_beg_$_end_(old[l5](_21.val_ref)), read)
} else {}
    Goto(cfg:18)
  label loop2_group3_bb13 // 18
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] _24 = &'_ (*_2)
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(_24.val_ref, write)
    _24.val_ref := borrow _2.val_ref // L13
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_24.val_ref), read)
    label l9
    // [mir] StorageLive(_25)
    // [mir] _25 = _4
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_int, write)
    _25.val_int := copy _4.val_int
    label l10
    // [mir] _23 = BoolArr32::lookup(move _24, move _25) -> [return: bb14, unwind: bb18]
    label l11
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_23), write)
    unfold acc(bool:None(_23), write)
    inhale(Stmt) (_23.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _25.val_int))
    transfer perm _24.val_ref --> old[l11](_24.val_ref) // unchecked: false
    Goto(cfg:19)
  label l12 // 19
    // ========== l12 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    // expire_borrows ReborrowingDAG(L12,L13,)

    if (__t10) && (true) {
    // expire loan L12
} else {}
    if (__t10) && ((__t10) && (true)) {
    // expire loan L13
    transfer perm old[l11](_24.val_ref) --> old[l9](_24.val_ref) // unchecked: false
    exhale acc(m_BoolArr32$_beg_$_end_(old[l9](_24.val_ref)), read)
} else {}
    Goto(cfg:20)
  label loop2_group3_bb14 // 20
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_25)
    // [mir] StorageDead(_24)
    // [mir] StorageLive(_26)
    // [mir] StorageLive(_27)
    // [mir] _27 = &'_ mut _3
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(_27.val_ref, write)
    _27.val_ref := mut borrow _3 // L5
    label l13
    // [mir] StorageLive(_28)
    // [mir] _28 = _4
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_int, write)
    _28.val_int := copy _4.val_int
    label l14
    // [mir] _26 = BoolArr32::index_mut(move _27, move _28) -> [return: bb15, unwind: bb18]
    label l15
    assert(Stmt) (((0) <= (_28.val_int)) && (((_28.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref))) && (true))) && (true)
    fold acc(usize:None(_28), write)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_27)) && ((usize$inv<Ref(usize),Bool>(_28)) && (true))
    exhale (acc(_27.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_27.val_ref), write)) && ((acc(usize(_28), write)) && (true)))
    _26 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_26.val_ref, write)) && (acc(bool(_26.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_26)) && (true)
    inhale(Expr) (((unfolding acc(bool:None(_26.val_ref), write) in _26.val_ref.val_bool)) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _28.val_int)))) && (true)
    exhale true
    label l16
    Goto(cfg:21)
  label loop2_group3_bb15 // 21
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_28)
    // [mir] StorageDead(_27)
    // [mir] (*_26) = BitOr(move _20, move _23)
    unfold acc(bool:None(_26.val_ref), write)
    _26.val_ref.val_bool := copy (_20.val_bool) || (_23.val_bool)
    // expire_borrows ReborrowingDAG(L14,L15,L5,)

    if (__t11) && (true) {
    // expire loan L14
    _old$l16$0 := move _26.val_ref
    inhale(Stmt) (((acc(bool(_old$l16$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l16$0))) && ((true) && (true))) Some(L14) --* (((acc(m_BoolArr32$_beg_$_end_(old[l15](_27.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l15](_27.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref))) == (old[l15](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), old[l15](_28.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l16$0), write) in _old$l16$0.val_bool)))) && ((forall _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103: Int  :: (((0) <= (_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) && (((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref)))) && ((!((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) == (old[l15](_28.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103))))) && (true)))) && (true)))
    fold acc(bool:None(_old$l16$0), write)
    apply[L14] ((acc(bool(_old$l16$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l16$0))) && ((true) && (true)) --* ((acc(m_BoolArr32$_beg_$_end_(old[l15](_27.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l15](_27.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref))) == (old[l15](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), old[l15](_28.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l16$0), write) in _old$l16$0.val_bool)))) && ((forall _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103: Int  :: (((0) <= (_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) && (((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref)))) && ((!((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) == (old[l15](_28.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103))))) && (true)))) && (true))
    
} else {}
    if (__t11) && ((__t11) && (true)) {
    // expire loan L15
} else {}
    if (__t11) && ((__t11) && ((__t11) && (true))) {
    // expire loan L5
    transfer perm old[l15](_27.val_ref) --> old[l13](_27.val_ref) // unchecked: false
    transfer perm old[l13](_27.val_ref) --> _3 // unchecked: false
} else {}
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_26)
    // [mir] _29 = CheckedAdd(_4, const 1_usize)
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.tuple_0, write)
    inhale(Stmt) acc(_29.tuple_0.val_int, write)
    inhale(Stmt) acc(_29.tuple_1, write)
    inhale(Stmt) acc(_29.tuple_1.val_bool, write)
    _29.tuple_0.val_int := copy (_4.val_int) + (1)
    _29.tuple_1.val_bool := copy false
    // [mir] assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb16, unwind: bb18]
    __t19 := copy _29.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t19)
    Goto(cfg:22)
  label loop2_group3_bb16 // 22
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _4 = move (_29.0: usize)
    _4 := move _29.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:23)
  label loop2_group4_bb2 // 23
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb18]
    Goto(cfg:24)
  label loop2_group4_bb3 // 24
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l18
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t20 := copy _7.val_bool
    GotoSwitch([(Local(__t20: Bool, Position { line: 0, column: 0, id: 0 }), cfg:26)], cfg:25)
  label l19 // 25
    // ========== l19 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:32)
  label l20 // 26
    // ========== l20 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:27)
  label loop2_group5_bb4 // 27
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:28)
  label loop2_group5_bb6 // 28
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t21 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:29)
  label loop2_end_body // 29
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_69c1cb6cf37f42139c0b79b67900def8_101: Int  :: (((0) <= (_2_forall_69c1cb6cf37f42139c0b79b67900def8_101)) && (((_2_forall_69c1cb6cf37f42139c0b79b67900def8_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_69c1cb6cf37f42139c0b79b67900def8_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_69c1cb6cf37f42139c0b79b67900def8_101)) || (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_69c1cb6cf37f42139c0b79b67900def8_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 30
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l21
    // [mir] StorageDead(_4)
    // [mir] drop(_3) -> [return: bb17, unwind: bb19]
    Goto(cfg:31)
  label bb17 // 31
    // ========== bb17 ==========
    __t15 := copy true
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l22 // 32
    // ========== l22 ==========
    // drop Acc(_22.val_int, write) (Acc(_22.val_int, write))
    // drop Acc(_24.val_ref, write) (Acc(_24.val_ref, write))
    // drop Acc(old[l9](_24.val_ref), write) (Acc(old[l9](_24.val_ref), write))
    // drop Acc(_26.val_ref, write) (Acc(_26.val_ref, write))
    // drop Acc(old[l5](_21.val_ref), write) (Acc(old[l5](_21.val_ref), write))
    // drop Acc(_21.val_ref, write) (Acc(_21.val_ref, write))
    // drop Acc(_14.val_bool, write) (Acc(_14.val_bool, write))
    // drop Acc(_29.tuple_0, write) (Acc(_29.tuple_0, write))
    // drop Acc(_23.val_bool, write) (Acc(_23.val_bool, write))
    // drop Acc(_29.tuple_1.val_bool, write) (Acc(_29.tuple_1.val_bool, write))
    // drop Acc(_20.val_bool, write) (Acc(_20.val_bool, write))
    // drop Acc(_25.val_int, write) (Acc(_25.val_int, write))
    // drop Acc(_29.tuple_1, write) (Acc(_29.tuple_1, write))
    Goto(cfg:30)
  label end_of_method
}


struct_predicate closure$0_150$3$1829153966109688439(self){
  true
}


struct_predicate closure$0_153$3$16802519762636729328(self){
  true
}


struct_predicate closure$0_151$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_151$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_151$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_150$3$1829153966109688439(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_150$3$1829153966109688439(self.val_ref), write)) && (true))
}


struct_predicate closure$0_152$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_152$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_152$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_155$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_155$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_155$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_154$3$8668476983963327591(self){
  true
}


struct_predicate ref$closure$0_154$3$8668476983963327591(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_154$3$8668476983963327591(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_153$3$16802519762636729328(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_153$3$16802519762636729328(self.val_ref), write)) && (true))
}


struct_predicate closure$0_156$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_156$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_156$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_157$3$11489740734085331380(self){
  true
}


struct_predicate ref$closure$0_157$3$11489740734085331380(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_157$3$11489740734085331380(self.val_ref), write)) && (true))
}


struct_predicate closure$0_146$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_146$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_146$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_145$3$11538186059445744466(self){
  true
}


struct_predicate ref$closure$0_145$3$11538186059445744466(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_145$3$11538186059445744466(self.val_ref), write)) && (true))
}


struct_predicate closure$0_147$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_147$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_147$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_148$3$11489740734085331380(self){
  true
}


struct_predicate ref$closure$0_148$3$11489740734085331380(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_148$3$11489740734085331380(self.val_ref), write)) && (true))
}


method m_and(2 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t18: Bool
    _old$l16$0: Ref(bool)
    __t19: Bool
    __t20: Bool
    __t21: Bool
    _old$pre$0: Ref(m_BoolArr32$_beg_$_end_)
    _old$pre$1: Ref(m_BoolArr32$_beg_$_end_)
    _1: Ref(ref$m_BoolArr32$_beg_$_end_)
    _2: Ref(ref$m_BoolArr32$_beg_$_end_)
    _3: Ref(m_BoolArr32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_150$3$1829153966109688439)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_153$3$16802519762636729328)
    _16: Ref(ref$usize)
    _17: Ref(ref$m_BoolArr32$_beg_$_end_)
    _18: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _19: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _20: Ref(bool)
    _21: Ref(ref$m_BoolArr32$_beg_$_end_)
    _22: Ref(usize)
    _23: Ref(bool)
    _24: Ref(ref$m_BoolArr32$_beg_$_end_)
    _25: Ref(usize)
    _26: Ref(ref$bool)
    _27: Ref(ref$m_BoolArr32$_beg_$_end_)
    _28: Ref(usize)
    _29: Ref(tuple2$usize$bool)
    _30: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "bytevec::{impl#0}::and"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bytevec.rs:345:5: 359:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_1)) && ((ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l23
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BoolArr32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BoolArr32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_a930b052200b4f028d90de6ee0c48aa2_101: Int  :: (((0) <= (_2_forall_a930b052200b4f028d90de6ee0c48aa2_101)) && (((_2_forall_a930b052200b4f028d90de6ee0c48aa2_101) < (32)) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_a930b052200b4f028d90de6ee0c48aa2_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$0, _2_forall_a930b052200b4f028d90de6ee0c48aa2_101)) && (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$1, _2_forall_a930b052200b4f028d90de6ee0c48aa2_101))))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BoolArr32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BoolArr32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BoolArr32::zero() -> [return: bb1, unwind: bb19]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101: Int  :: (((0) <= (_2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101)) && (((_2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = const 0_usize
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy 0
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb18]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l2
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t16 := copy _7.val_bool
    GotoSwitch([(Local(__t16: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:30)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t17 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$1 := ghost _2.val_ref
    _preserve$0 := ghost _1.val_ref
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_b68ac5d3d8294a52b359b76085d6c13e_101: Int  :: (((0) <= (_2_forall_b68ac5d3d8294a52b359b76085d6c13e_101)) && (((_2_forall_b68ac5d3d8294a52b359b76085d6c13e_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_b68ac5d3d8294a52b359b76085d6c13e_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_b68ac5d3d8294a52b359b76085d6c13e_101)) && (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_b68ac5d3d8294a52b359b76085d6c13e_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    _26 := builtin$havoc_ref()
    __t6 := builtin$havoc_bool()
    _29 := builtin$havoc_ref()
    __t19 := builtin$havoc_bool()
    __t4 := builtin$havoc_bool()
    __t2 := builtin$havoc_bool()
    __t20 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    _25 := builtin$havoc_ref()
    __t21 := builtin$havoc_bool()
    __t12 := builtin$havoc_bool()
    _21 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    _24 := builtin$havoc_ref()
    __t11 := builtin$havoc_bool()
    _28 := builtin$havoc_ref()
    _27 := builtin$havoc_ref()
    _23 := builtin$havoc_ref()
    _14 := builtin$havoc_ref()
    _4 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    _22 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    _10 := builtin$havoc_ref()
    _8 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    _7 := builtin$havoc_ref()
    __t5 := builtin$havoc_bool()
    _20 := builtin$havoc_ref()
    __t18 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_b68ac5d3d8294a52b359b76085d6c13e_101: Int  :: (((0) <= (_2_forall_b68ac5d3d8294a52b359b76085d6c13e_101)) && (((_2_forall_b68ac5d3d8294a52b359b76085d6c13e_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_b68ac5d3d8294a52b359b76085d6c13e_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_b68ac5d3d8294a52b359b76085d6c13e_101)) && (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_b68ac5d3d8294a52b359b76085d6c13e_101))))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t18 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'_ (*_1)
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_ref, write)
    _21.val_ref := borrow _1.val_ref // L15
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_21.val_ref), read)
    label l5
    // [mir] StorageLive(_22)
    // [mir] _22 = _4
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_int, write)
    unfold acc(usize:None(_4), write)
    _22.val_int := copy _4.val_int
    label l6
    // [mir] _20 = BoolArr32::lookup(move _21, move _22) -> [return: bb13, unwind: bb18]
    label l7
    _20 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_20), write)
    unfold acc(bool:None(_20), write)
    inhale(Stmt) (_20.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_21.val_ref, _22.val_int))
    transfer perm _21.val_ref --> old[l7](_21.val_ref) // unchecked: false
    Goto(cfg:17)
  label l8 // 17
    // ========== l8 ==========
    // MIR edge bb12 --> bb13
    // Expire borrows
    // expire_borrows ReborrowingDAG(L10,L15,)

    if (__t9) && (true) {
    // expire loan L10
} else {}
    if (__t9) && ((__t9) && (true)) {
    // expire loan L15
    transfer perm old[l7](_21.val_ref) --> old[l5](_21.val_ref) // unchecked: false
    exhale acc(m_BoolArr32$_beg_$_end_(old[l5](_21.val_ref)), read)
} else {}
    Goto(cfg:18)
  label loop2_group3_bb13 // 18
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] _24 = &'_ (*_2)
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(_24.val_ref, write)
    _24.val_ref := borrow _2.val_ref // L13
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_24.val_ref), read)
    label l9
    // [mir] StorageLive(_25)
    // [mir] _25 = _4
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_int, write)
    _25.val_int := copy _4.val_int
    label l10
    // [mir] _23 = BoolArr32::lookup(move _24, move _25) -> [return: bb14, unwind: bb18]
    label l11
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_23), write)
    unfold acc(bool:None(_23), write)
    inhale(Stmt) (_23.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _25.val_int))
    transfer perm _24.val_ref --> old[l11](_24.val_ref) // unchecked: false
    Goto(cfg:19)
  label l12 // 19
    // ========== l12 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    // expire_borrows ReborrowingDAG(L14,L13,)

    if (__t10) && (true) {
    // expire loan L14
} else {}
    if (__t10) && ((__t10) && (true)) {
    // expire loan L13
    transfer perm old[l11](_24.val_ref) --> old[l9](_24.val_ref) // unchecked: false
    exhale acc(m_BoolArr32$_beg_$_end_(old[l9](_24.val_ref)), read)
} else {}
    Goto(cfg:20)
  label loop2_group3_bb14 // 20
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_25)
    // [mir] StorageDead(_24)
    // [mir] StorageLive(_26)
    // [mir] StorageLive(_27)
    // [mir] _27 = &'_ mut _3
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(_27.val_ref, write)
    _27.val_ref := mut borrow _3 // L5
    label l13
    // [mir] StorageLive(_28)
    // [mir] _28 = _4
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_int, write)
    _28.val_int := copy _4.val_int
    label l14
    // [mir] _26 = BoolArr32::index_mut(move _27, move _28) -> [return: bb15, unwind: bb18]
    label l15
    assert(Stmt) (((0) <= (_28.val_int)) && (((_28.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref))) && (true))) && (true)
    fold acc(usize:None(_28), write)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_27)) && ((usize$inv<Ref(usize),Bool>(_28)) && (true))
    exhale (acc(_27.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_27.val_ref), write)) && ((acc(usize(_28), write)) && (true)))
    _26 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_26.val_ref, write)) && (acc(bool(_26.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_26)) && (true)
    inhale(Expr) (((unfolding acc(bool:None(_26.val_ref), write) in _26.val_ref.val_bool)) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _28.val_int)))) && (true)
    exhale true
    label l16
    Goto(cfg:21)
  label loop2_group3_bb15 // 21
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_28)
    // [mir] StorageDead(_27)
    // [mir] (*_26) = BitAnd(move _20, move _23)
    unfold acc(bool:None(_26.val_ref), write)
    _26.val_ref.val_bool := copy (_20.val_bool) && (_23.val_bool)
    // expire_borrows ReborrowingDAG(L11,L12,L5,)

    if (__t11) && (true) {
    // expire loan L11
    _old$l16$0 := move _26.val_ref
    inhale(Stmt) (((acc(bool(_old$l16$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l16$0))) && ((true) && (true))) Some(L11) --* (((acc(m_BoolArr32$_beg_$_end_(old[l15](_27.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l15](_27.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref))) == (old[l15](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), old[l15](_28.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l16$0), write) in _old$l16$0.val_bool)))) && ((forall _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103: Int  :: (((0) <= (_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) && (((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref)))) && ((!((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) == (old[l15](_28.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103))))) && (true)))) && (true)))
    fold acc(bool:None(_old$l16$0), write)
    apply[L11] ((acc(bool(_old$l16$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l16$0))) && ((true) && (true)) --* ((acc(m_BoolArr32$_beg_$_end_(old[l15](_27.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l15](_27.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref))) == (old[l15](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), old[l15](_28.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l16$0), write) in _old$l16$0.val_bool)))) && ((forall _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103: Int  :: (((0) <= (_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) && (((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref)))) && ((!((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) == (old[l15](_28.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103))))) && (true)))) && (true))
    
} else {}
    if (__t11) && ((__t11) && (true)) {
    // expire loan L12
} else {}
    if (__t11) && ((__t11) && ((__t11) && (true))) {
    // expire loan L5
    transfer perm old[l15](_27.val_ref) --> old[l13](_27.val_ref) // unchecked: false
    transfer perm old[l13](_27.val_ref) --> _3 // unchecked: false
} else {}
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_26)
    // [mir] _29 = CheckedAdd(_4, const 1_usize)
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.tuple_0, write)
    inhale(Stmt) acc(_29.tuple_0.val_int, write)
    inhale(Stmt) acc(_29.tuple_1, write)
    inhale(Stmt) acc(_29.tuple_1.val_bool, write)
    _29.tuple_0.val_int := copy (_4.val_int) + (1)
    _29.tuple_1.val_bool := copy false
    // [mir] assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb16, unwind: bb18]
    __t19 := copy _29.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t19)
    Goto(cfg:22)
  label loop2_group3_bb16 // 22
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _4 = move (_29.0: usize)
    _4 := move _29.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:23)
  label loop2_group4_bb2 // 23
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb18]
    Goto(cfg:24)
  label loop2_group4_bb3 // 24
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l18
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t20 := copy _7.val_bool
    GotoSwitch([(Local(__t20: Bool, Position { line: 0, column: 0, id: 0 }), cfg:26)], cfg:25)
  label l19 // 25
    // ========== l19 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:32)
  label l20 // 26
    // ========== l20 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:27)
  label loop2_group5_bb4 // 27
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:28)
  label loop2_group5_bb6 // 28
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t21 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:29)
  label loop2_end_body // 29
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_b68ac5d3d8294a52b359b76085d6c13e_101: Int  :: (((0) <= (_2_forall_b68ac5d3d8294a52b359b76085d6c13e_101)) && (((_2_forall_b68ac5d3d8294a52b359b76085d6c13e_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_b68ac5d3d8294a52b359b76085d6c13e_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_b68ac5d3d8294a52b359b76085d6c13e_101)) && (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_b68ac5d3d8294a52b359b76085d6c13e_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 30
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l21
    // [mir] StorageDead(_4)
    // [mir] drop(_3) -> [return: bb17, unwind: bb19]
    Goto(cfg:31)
  label bb17 // 31
    // ========== bb17 ==========
    __t15 := copy true
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l22 // 32
    // ========== l22 ==========
    // drop Acc(_26.val_ref, write) (Acc(_26.val_ref, write))
    // drop Acc(_29.tuple_1.val_bool, write) (Acc(_29.tuple_1.val_bool, write))
    // drop Acc(_25.val_int, write) (Acc(_25.val_int, write))
    // drop Acc(_20.val_bool, write) (Acc(_20.val_bool, write))
    // drop Acc(_24.val_ref, write) (Acc(_24.val_ref, write))
    // drop Acc(old[l9](_24.val_ref), write) (Acc(old[l9](_24.val_ref), write))
    // drop Acc(_14.val_bool, write) (Acc(_14.val_bool, write))
    // drop Acc(_22.val_int, write) (Acc(_22.val_int, write))
    // drop Acc(_23.val_bool, write) (Acc(_23.val_bool, write))
    // drop Acc(old[l5](_21.val_ref), write) (Acc(old[l5](_21.val_ref), write))
    // drop Acc(_21.val_ref, write) (Acc(_21.val_ref, write))
    // drop Acc(_29.tuple_0, write) (Acc(_29.tuple_0, write))
    // drop Acc(_29.tuple_1, write) (Acc(_29.tuple_1, write))
    Goto(cfg:30)
  label end_of_method
}


struct_predicate closure$0_167$3$16802519762636729328(self){
  true
}


struct_predicate closure$0_164$3$1829153966109688439(self){
  true
}


struct_predicate closure$0_165$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_165$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_165$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_164$3$1829153966109688439(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_164$3$1829153966109688439(self.val_ref), write)) && (true))
}


struct_predicate closure$0_166$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_166$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_166$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_169$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_169$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_169$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_168$3$8668476983963327591(self){
  true
}


struct_predicate ref$closure$0_168$3$8668476983963327591(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_168$3$8668476983963327591(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_167$3$16802519762636729328(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_167$3$16802519762636729328(self.val_ref), write)) && (true))
}


struct_predicate closure$0_170$3$10735134361002959390(self){
  true
}


struct_predicate ref$closure$0_170$3$10735134361002959390(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_170$3$10735134361002959390(self.val_ref), write)) && (true))
}


struct_predicate closure$0_171$3$11489740734085331380(self){
  true
}


struct_predicate ref$closure$0_171$3$11489740734085331380(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_171$3$11489740734085331380(self.val_ref), write)) && (true))
}


struct_predicate closure$0_160$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_160$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_160$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_159$3$11538186059445744466(self){
  true
}


struct_predicate ref$closure$0_159$3$11538186059445744466(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_159$3$11538186059445744466(self.val_ref), write)) && (true))
}


struct_predicate closure$0_161$3$7086023393399750873(self){
  true
}


struct_predicate ref$closure$0_161$3$7086023393399750873(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_161$3$7086023393399750873(self.val_ref), write)) && (true))
}


struct_predicate closure$0_162$3$11489740734085331380(self){
  true
}


struct_predicate ref$closure$0_162$3$11489740734085331380(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_162$3$11489740734085331380(self.val_ref), write)) && (true))
}


method m_xor(2 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t18: Bool
    _old$l16$0: Ref(bool)
    __t19: Bool
    __t20: Bool
    __t21: Bool
    _old$pre$0: Ref(m_BoolArr32$_beg_$_end_)
    _old$pre$1: Ref(m_BoolArr32$_beg_$_end_)
    _1: Ref(ref$m_BoolArr32$_beg_$_end_)
    _2: Ref(ref$m_BoolArr32$_beg_$_end_)
    _3: Ref(m_BoolArr32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_164$3$1829153966109688439)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_167$3$16802519762636729328)
    _16: Ref(ref$usize)
    _17: Ref(ref$m_BoolArr32$_beg_$_end_)
    _18: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _19: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _20: Ref(bool)
    _21: Ref(ref$m_BoolArr32$_beg_$_end_)
    _22: Ref(usize)
    _23: Ref(bool)
    _24: Ref(ref$m_BoolArr32$_beg_$_end_)
    _25: Ref(usize)
    _26: Ref(ref$bool)
    _27: Ref(ref$m_BoolArr32$_beg_$_end_)
    _28: Ref(usize)
    _29: Ref(tuple2$usize$bool)
    _30: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "bytevec::{impl#0}::xor"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bytevec.rs:366:5: 380:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_1)) && ((ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l23
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BoolArr32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BoolArr32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_d0e02e95e98f4c54b333161ca14ea5fc_101: Int  :: (((0) <= (_2_forall_d0e02e95e98f4c54b333161ca14ea5fc_101)) && (((_2_forall_d0e02e95e98f4c54b333161ca14ea5fc_101) < (32)) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_d0e02e95e98f4c54b333161ca14ea5fc_101)) == (!((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$0, _2_forall_d0e02e95e98f4c54b333161ca14ea5fc_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$1, _2_forall_d0e02e95e98f4c54b333161ca14ea5fc_101)))))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BoolArr32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BoolArr32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BoolArr32::zero() -> [return: bb1, unwind: bb19]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101: Int  :: (((0) <= (_2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101)) && (((_2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_5e7aa45fa4c0454583536f35f8d0ead2_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = const 0_usize
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy 0
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb18]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l2
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t16 := copy _7.val_bool
    GotoSwitch([(Local(__t16: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:30)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t17 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    _preserve$1 := ghost _2.val_ref
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_bf824b1408634e6c88e0028bc5869aa2_101: Int  :: (((0) <= (_2_forall_bf824b1408634e6c88e0028bc5869aa2_101)) && (((_2_forall_bf824b1408634e6c88e0028bc5869aa2_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_bf824b1408634e6c88e0028bc5869aa2_101)) == (!((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_bf824b1408634e6c88e0028bc5869aa2_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_bf824b1408634e6c88e0028bc5869aa2_101)))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    _27 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    __t18 := builtin$havoc_bool()
    _21 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    _10 := builtin$havoc_ref()
    _25 := builtin$havoc_ref()
    __t6 := builtin$havoc_bool()
    _28 := builtin$havoc_ref()
    _26 := builtin$havoc_ref()
    __t13 := builtin$havoc_bool()
    __t21 := builtin$havoc_bool()
    _24 := builtin$havoc_ref()
    _4 := builtin$havoc_ref()
    __t9 := builtin$havoc_bool()
    __t12 := builtin$havoc_bool()
    _8 := builtin$havoc_ref()
    _23 := builtin$havoc_ref()
    _22 := builtin$havoc_ref()
    __t20 := builtin$havoc_bool()
    _29 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    __t7 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    _7 := builtin$havoc_ref()
    __t2 := builtin$havoc_bool()
    _20 := builtin$havoc_ref()
    _14 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    __t19 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_bf824b1408634e6c88e0028bc5869aa2_101: Int  :: (((0) <= (_2_forall_bf824b1408634e6c88e0028bc5869aa2_101)) && (((_2_forall_bf824b1408634e6c88e0028bc5869aa2_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_bf824b1408634e6c88e0028bc5869aa2_101)) == (!((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_bf824b1408634e6c88e0028bc5869aa2_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_bf824b1408634e6c88e0028bc5869aa2_101)))))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t18 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'_ (*_1)
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_ref, write)
    _21.val_ref := borrow _1.val_ref // L13
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_21.val_ref), read)
    label l5
    // [mir] StorageLive(_22)
    // [mir] _22 = _4
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_int, write)
    unfold acc(usize:None(_4), write)
    _22.val_int := copy _4.val_int
    label l6
    // [mir] _20 = BoolArr32::lookup(move _21, move _22) -> [return: bb13, unwind: bb18]
    label l7
    _20 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_20), write)
    unfold acc(bool:None(_20), write)
    inhale(Stmt) (_20.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_21.val_ref, _22.val_int))
    transfer perm _21.val_ref --> old[l7](_21.val_ref) // unchecked: false
    Goto(cfg:17)
  label l8 // 17
    // ========== l8 ==========
    // MIR edge bb12 --> bb13
    // Expire borrows
    // expire_borrows ReborrowingDAG(L12,L13,)

    if (__t9) && (true) {
    // expire loan L12
} else {}
    if (__t9) && ((__t9) && (true)) {
    // expire loan L13
    transfer perm old[l7](_21.val_ref) --> old[l5](_21.val_ref) // unchecked: false
    exhale acc(m_BoolArr32$_beg_$_end_(old[l5](_21.val_ref)), read)
} else {}
    Goto(cfg:18)
  label loop2_group3_bb13 // 18
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] _24 = &'_ (*_2)
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(_24.val_ref, write)
    _24.val_ref := borrow _2.val_ref // L11
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_24.val_ref), read)
    label l9
    // [mir] StorageLive(_25)
    // [mir] _25 = _4
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_int, write)
    _25.val_int := copy _4.val_int
    label l10
    // [mir] _23 = BoolArr32::lookup(move _24, move _25) -> [return: bb14, unwind: bb18]
    label l11
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_23), write)
    unfold acc(bool:None(_23), write)
    inhale(Stmt) (_23.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _25.val_int))
    transfer perm _24.val_ref --> old[l11](_24.val_ref) // unchecked: false
    Goto(cfg:19)
  label l12 // 19
    // ========== l12 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    // expire_borrows ReborrowingDAG(L10,L11,)

    if (__t10) && (true) {
    // expire loan L10
} else {}
    if (__t10) && ((__t10) && (true)) {
    // expire loan L11
    transfer perm old[l11](_24.val_ref) --> old[l9](_24.val_ref) // unchecked: false
    exhale acc(m_BoolArr32$_beg_$_end_(old[l9](_24.val_ref)), read)
} else {}
    Goto(cfg:20)
  label loop2_group3_bb14 // 20
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_25)
    // [mir] StorageDead(_24)
    // [mir] StorageLive(_26)
    // [mir] StorageLive(_27)
    // [mir] _27 = &'_ mut _3
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(_27.val_ref, write)
    _27.val_ref := mut borrow _3 // L5
    label l13
    // [mir] StorageLive(_28)
    // [mir] _28 = _4
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_int, write)
    _28.val_int := copy _4.val_int
    label l14
    // [mir] _26 = BoolArr32::index_mut(move _27, move _28) -> [return: bb15, unwind: bb18]
    label l15
    assert(Stmt) (((0) <= (_28.val_int)) && (((_28.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref))) && (true))) && (true)
    fold acc(usize:None(_28), write)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_27)) && ((usize$inv<Ref(usize),Bool>(_28)) && (true))
    exhale (acc(_27.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_27.val_ref), write)) && ((acc(usize(_28), write)) && (true)))
    _26 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_26.val_ref, write)) && (acc(bool(_26.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_26)) && (true)
    inhale(Expr) (((unfolding acc(bool:None(_26.val_ref), write) in _26.val_ref.val_bool)) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _28.val_int)))) && (true)
    exhale true
    label l16
    Goto(cfg:21)
  label loop2_group3_bb15 // 21
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_28)
    // [mir] StorageDead(_27)
    // [mir] (*_26) = BitXor(move _20, move _23)
    unfold acc(bool:None(_26.val_ref), write)
    _26.val_ref.val_bool := copy !((_20.val_bool) == (_23.val_bool))
    // expire_borrows ReborrowingDAG(L14,L15,L5,)

    if (__t11) && (true) {
    // expire loan L14
    _old$l16$0 := move _26.val_ref
    inhale(Stmt) (((acc(bool(_old$l16$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l16$0))) && ((true) && (true))) Some(L14) --* (((acc(m_BoolArr32$_beg_$_end_(old[l15](_27.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l15](_27.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref))) == (old[l15](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), old[l15](_28.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l16$0), write) in _old$l16$0.val_bool)))) && ((forall _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103: Int  :: (((0) <= (_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) && (((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref)))) && ((!((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) == (old[l15](_28.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103))))) && (true)))) && (true)))
    fold acc(bool:None(_old$l16$0), write)
    apply[L14] ((acc(bool(_old$l16$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l16$0))) && ((true) && (true)) --* ((acc(m_BoolArr32$_beg_$_end_(old[l15](_27.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l15](_27.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref))) == (old[l15](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), old[l15](_28.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l16$0), write) in _old$l16$0.val_bool)))) && ((forall _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103: Int  :: (((0) <= (_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) && (((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref)))) && ((!((_2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103) == (old[l15](_28.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103)) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _2_forall_ddc1ff66a1974a08beba4391e71d2ef8_103))))) && (true)))) && (true))
    
} else {}
    if (__t11) && ((__t11) && (true)) {
    // expire loan L15
} else {}
    if (__t11) && ((__t11) && ((__t11) && (true))) {
    // expire loan L5
    transfer perm old[l15](_27.val_ref) --> old[l13](_27.val_ref) // unchecked: false
    transfer perm old[l13](_27.val_ref) --> _3 // unchecked: false
} else {}
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_26)
    // [mir] _29 = CheckedAdd(_4, const 1_usize)
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.tuple_0, write)
    inhale(Stmt) acc(_29.tuple_0.val_int, write)
    inhale(Stmt) acc(_29.tuple_1, write)
    inhale(Stmt) acc(_29.tuple_1.val_bool, write)
    _29.tuple_0.val_int := copy (_4.val_int) + (1)
    _29.tuple_1.val_bool := copy false
    // [mir] assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb16, unwind: bb18]
    __t19 := copy _29.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t19)
    Goto(cfg:22)
  label loop2_group3_bb16 // 22
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _4 = move (_29.0: usize)
    _4 := move _29.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:23)
  label loop2_group4_bb2 // 23
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb18]
    Goto(cfg:24)
  label loop2_group4_bb3 // 24
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l18
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t20 := copy _7.val_bool
    GotoSwitch([(Local(__t20: Bool, Position { line: 0, column: 0, id: 0 }), cfg:26)], cfg:25)
  label l19 // 25
    // ========== l19 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:32)
  label l20 // 26
    // ========== l20 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:27)
  label loop2_group5_bb4 // 27
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:28)
  label loop2_group5_bb6 // 28
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t21 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:29)
  label loop2_end_body // 29
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_bf824b1408634e6c88e0028bc5869aa2_101: Int  :: (((0) <= (_2_forall_bf824b1408634e6c88e0028bc5869aa2_101)) && (((_2_forall_bf824b1408634e6c88e0028bc5869aa2_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_bf824b1408634e6c88e0028bc5869aa2_101)) == (!((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_bf824b1408634e6c88e0028bc5869aa2_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_bf824b1408634e6c88e0028bc5869aa2_101)))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 30
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l21
    // [mir] StorageDead(_4)
    // [mir] drop(_3) -> [return: bb17, unwind: bb19]
    Goto(cfg:31)
  label bb17 // 31
    // ========== bb17 ==========
    __t15 := copy true
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l22 // 32
    // ========== l22 ==========
    // drop Acc(_26.val_ref, write) (Acc(_26.val_ref, write))
    // drop Acc(_23.val_bool, write) (Acc(_23.val_bool, write))
    // drop Acc(_14.val_bool, write) (Acc(_14.val_bool, write))
    // drop Acc(_29.tuple_1.val_bool, write) (Acc(_29.tuple_1.val_bool, write))
    // drop Acc(old[l5](_21.val_ref), write) (Acc(old[l5](_21.val_ref), write))
    // drop Acc(_29.tuple_0, write) (Acc(_29.tuple_0, write))
    // drop Acc(old[l9](_24.val_ref), write) (Acc(old[l9](_24.val_ref), write))
    // drop Acc(_20.val_bool, write) (Acc(_20.val_bool, write))
    // drop Acc(_24.val_ref, write) (Acc(_24.val_ref, write))
    // drop Acc(_25.val_int, write) (Acc(_25.val_int, write))
    // drop Acc(_22.val_int, write) (Acc(_22.val_int, write))
    // drop Acc(_21.val_ref, write) (Acc(_21.val_ref, write))
    // drop Acc(_29.tuple_1, write) (Acc(_29.tuple_1, write))
    Goto(cfg:30)
  label end_of_method
}


struct_predicate u8(self){
  (acc(self.val_int, write)) && (true)
}


struct_predicate ref$closure$0_172$3$14348369837522596991(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_172$3$14348369837522596991(self.val_ref), write)) && (true))
}


struct_predicate closure$0_174$3$15604894616233164167(self){
  true
}


struct_predicate ref$closure$0_174$3$15604894616233164167(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_174$3$15604894616233164167(self.val_ref), write)) && (true))
}


struct_predicate ref$u8(self){
  (acc(self.val_ref, write)) && ((acc(u8(self.val_ref), write)) && (true))
}


struct_predicate closure$0_176$3$15604894616233164167(self){
  true
}


struct_predicate ref$closure$0_176$3$15604894616233164167(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_176$3$15604894616233164167(self.val_ref), write)) && (true))
}


method m_closure$$$opencur$closure$sharp$0$closecur$(3 args)
    returns (_0: Ref(u8))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    _old$pre$0: Ref(closure$0_172$3$14348369837522596991)
    _1: Ref(ref$closure$0_172$3$14348369837522596991)
    _2: Ref(u8)
    _3: Ref(u8)
    _4: Ref(tuple0$)
    _5: Ref(bool)
    _6: Ref(u8)
    _7: Ref(tuple0$)
    _8: Ref(bool)
  label start // 0
    // ========== start ==========
    // Def path: "bytevec::closure::{closure#0}"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bytevec.rs:426:15: 430:6 (#90)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(closure$0_172$3$14348369837522596991(_1.val_ref), read)) && ((acc(u8(_2), write)) && ((acc(u8(_3), write)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$closure$0_172$3$14348369837522596991$inv<Ref(ref$closure$0_172$3$14348369837522596991),Bool>(_1)) && ((u8$inv<Ref(u8),Bool>(_2)) && ((u8$inv<Ref(u8),Bool>(_3)) && (true)))
    inhale(Expr) (((unfolding acc(u8:None(_2), write) in _2.val_int)) > ((unfolding acc(u8:None(_3), write) in _3.val_int))) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l7
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(closure$0_172$3$14348369837522596991(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    fold acc(u8:None(_0), write)
    obtain acc(u8(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (((unfolding acc(u8:None(_0), write) in _0.val_int)) > (old[pre]((unfolding acc(u8:None(_3), write) in _3.val_int)))) && (true)
    // Assert type invariants
    assert(Stmt) (u8$inv<Ref(u8),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(closure$0_172$3$14348369837522596991(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(u8(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = const false
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_bool, write)
    _5.val_bool := copy false
    // [mir] switchInt(move _5) -> [false: bb2, otherwise: bb1]
    __t7 := copy _5.val_bool
    GotoSwitch([(UnaryOp(Not, Local(__t7: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:4)], cfg:3)
  label l0 // 3
    // ========== l0 ==========
    // MIR edge bb0 --> bb1
    Goto(cfg:5)
  label l1 // 4
    // ========== l1 ==========
    // MIR edge bb0 --> bb2
    Goto(cfg:6)
  label bb1 // 5
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] _4 = const ()
    // [mir] goto -> bb3
    Goto(cfg:7)
  label bb2 // 6
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] _4 = const ()
    // [mir] goto -> bb3
    Goto(cfg:7)
  label bb3 // 7
    // ========== bb3 ==========
    __t3 := copy true
    // [mir] StorageDead(_5)
    // [mir] StorageDead(_4)
    // [mir] StorageLive(_6)
    // [mir] _6 = _2
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_int, write)
    unfold acc(u8:None(_2), write)
    _6.val_int := copy _2.val_int
    label l2
    // [mir] FakeRead(ForLet, _6)
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = const false
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_bool, write)
    _8.val_bool := copy false
    // [mir] switchInt(move _8) -> [false: bb5, otherwise: bb4]
    __t8 := copy _8.val_bool
    GotoSwitch([(UnaryOp(Not, Local(__t8: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:9)], cfg:8)
  label l3 // 8
    // ========== l3 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:10)
  label l4 // 9
    // ========== l4 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:11)
  label bb4 // 10
    // ========== bb4 ==========
    __t4 := copy true
    // [mir] _7 = const ()
    // [mir] goto -> bb6
    Goto(cfg:12)
  label bb5 // 11
    // ========== bb5 ==========
    __t5 := copy true
    // [mir] _7 = const ()
    // [mir] goto -> bb6
    Goto(cfg:12)
  label bb6 // 12
    // ========== bb6 ==========
    __t6 := copy true
    // [mir] StorageDead(_8)
    // [mir] StorageDead(_7)
    // [mir] _0 = _6
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_int, write)
    _0.val_int := copy _6.val_int
    label l5
    // [mir] StorageDead(_6)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


