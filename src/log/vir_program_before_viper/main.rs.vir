method builtin$havoc_bool() returns (ret: Bool);

method builtin$havoc_int() returns (ret: Int);

method builtin$havoc_ref() returns (ret: Ref());

struct_predicate closure$0_178$3$4476728821056422335(self){
  true
}


struct_predicate tuple0$(self){
  true
}


method m_closure(0 args)
    returns (_0: Ref(tuple0$))
{
    __t0: Bool
    _1: Ref(closure$0_178$3$4476728821056422335)
    _2: Ref(closure$0_178$3$4476728821056422335)
  label start // 0
    // ========== start ==========
    // Def path: "main::closure"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:425:1: 431:2 (#0)
    __t0 := copy false
    // Preconditions:
    inhale(Stmt) true
    inhale(Stmt) true
    inhale(Stmt) true
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l2
    // Fold predicates for &mut args and transfer borrow permissions to old
    // Fold the result
    fold acc(tuple0$:None(_0), write)
    obtain acc(tuple0$(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) true
    // Assert type invariants
    assert(Stmt) (tuple0$$inv<Ref(tuple0$),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale true
    // Exhale permissions of postcondition (2/3)
    exhale acc(tuple0$(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_1)
    // [mir] StorageLive(_2)
    // [mir] _2 = [closure@/home/philippe/VSCodeProjects/prusti_0/src/main.rs:426:15: 430:6]
    _2 := builtin$havoc_ref()
    inhale(Stmt) acc(closure$0_178$3$4476728821056422335(_2), write)
    // [mir] FakeRead(ForLet, _2)
    // [mir] _1 = _2
    label l0
    // [mir] StorageDead(_2)
    // [mir] FakeRead(ForLet, _1)
    // [mir] _0 = const ()
    // [mir] StorageDead(_1)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


struct_predicate u32(self){
  (acc(self.val_int, write)) && (true)
}


struct_predicate bool(self){
  (acc(self.val_bool, write)) && (true)
}


struct_predicate closure$0_16$3$11967321379665365051(self){
  true
}


struct_predicate ref$closure$0_16$3$11967321379665365051(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_16$3$11967321379665365051(self.val_ref), write)) && (true))
}


struct_predicate ref$u32(self){
  (acc(self.val_ref, write)) && ((acc(u32(self.val_ref), write)) && (true))
}


struct_predicate closure$0_17$3$11967321379665365051(self){
  true
}


struct_predicate ref$closure$0_17$3$11967321379665365051(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_17$3$11967321379665365051(self.val_ref), write)) && (true))
}


struct_predicate closure$0_19$3$10284401411735859536(self){
  true
}


struct_predicate ref$closure$0_19$3$10284401411735859536(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_19$3$10284401411735859536(self.val_ref), write)) && (true))
}


function m_max(_1: Int, _2: Int): Int
  requires true
  requires true
  ensures (((__result) >= (_1)) && (((__result) >= (_2)) && (true))) && (((!((__result) == (_1)))?((!((__result) == (_2)))?(false):(true)):(true)) && (true))
  ensures [((__result) == (mirror$m_max__$TY$__$int$$$int$$$int$(_1, _2))), (true)]
{
	(!((_1) > (_2)))?(_2):(_1)
}

struct_predicate m_U32Opt$_beg_$_end_Some(self){
  (acc(self.f$0, write)) && ((acc(u32(self.f$0), write)) && (true))
}


enum_predicate m_U32Opt$_beg_$_end_(self){
  discriminant=self.discriminant
  Some: (self.discriminant) == (0) ==> struct_predicate m_U32Opt$_beg_$_end_Some(self){
  (acc(self.f$0, write)) && ((acc(u32(self.f$0), write)) && (true))
}


  None: (self.discriminant) == (1) ==> struct_predicate m_U32Opt$_beg_$_end_None(self){
  true
}


}


struct_predicate ref$m_U32Opt$_beg_$_end_(self){
  (acc(self.val_ref, write)) && ((acc(m_U32Opt$_beg_$_end_(self.val_ref), write)) && (true))
}


method m_clone(1 args)
    returns (_0: Ref(m_U32Opt$_beg_$_end_))
{
    __t0: Bool
    _old$pre$0: Ref(m_U32Opt$_beg_$_end_)
    _1: Ref(ref$m_U32Opt$_beg_$_end_)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#3}::clone"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:97:27: 97:32 (#9)
    __t0 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_U32Opt$_beg_$_end_(_1.val_ref), read)) && (true))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_1)) && (true)
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l2
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_U32Opt$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(m_U32Opt$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) true
    // Assert type invariants
    assert(Stmt) (m_U32Opt$_beg_$_end_$inv<Ref(m_U32Opt$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_U32Opt$_beg_$_end_(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_U32Opt$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] _0 = (*_1)
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_0), write)
    inhale(Stmt) m_U32Opt$_beg_$_end_$$memory_eq$$<Ref(m_U32Opt$_beg_$_end_), Ref(m_U32Opt$_beg_$_end_),Bool>(_1.val_ref, _0)
    label l0
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


struct_predicate isize(self){
  (acc(self.val_int, write)) && (true)
}


struct_predicate tuple2$ref$m_U32Opt$_beg_$_end_$ref$m_U32Opt$_beg_$_end_(self){
  (acc(self.tuple_0, write)) && ((acc(ref$m_U32Opt$_beg_$_end_(self.tuple_0), write)) && ((acc(self.tuple_1, write)) && ((acc(ref$m_U32Opt$_beg_$_end_(self.tuple_1), write)) && (true))))
}


method m_eq(2 args)
    returns (_0: Ref(bool))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    _aux_havoc_ref$m_U32Opt$_beg_$_end_: Ref(ref$m_U32Opt$_beg_$_end_)
    __t18: Int
    __t19: Int
    _old$pre$0: Ref(m_U32Opt$_beg_$_end_)
    _old$pre$1: Ref(m_U32Opt$_beg_$_end_)
    _1: Ref(ref$m_U32Opt$_beg_$_end_)
    _2: Ref(ref$m_U32Opt$_beg_$_end_)
    _3: Ref(isize)
    _4: Ref(ref$m_U32Opt$_beg_$_end_)
    _5: Ref(ref$m_U32Opt$_beg_$_end_)
    _6: Ref(isize)
    _7: Ref(ref$m_U32Opt$_beg_$_end_)
    _8: Ref(ref$m_U32Opt$_beg_$_end_)
    _9: Ref(bool)
    _10: Ref(bool)
    _11: Ref(isize)
    _12: Ref(isize)
    _13: Ref(tuple2$ref$m_U32Opt$_beg_$_end_$ref$m_U32Opt$_beg_$_end_)
    _14: Ref(ref$m_U32Opt$_beg_$_end_)
    _15: Ref(ref$m_U32Opt$_beg_$_end_)
    _16: Ref(isize)
    _17: Ref(isize)
    _18: Ref(ref$u32)
    _19: Ref(ref$u32)
    _20: Ref(u32)
    _21: Ref(u32)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#6}::eq"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:97:10: 97:19 (#11)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_U32Opt$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_U32Opt$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_1)) && ((ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l31
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_U32Opt$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_U32Opt$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    fold acc(bool:None(_0), write)
    obtain acc(bool(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) true
    // Assert type invariants
    assert(Stmt) (bool$inv<Ref(bool),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_U32Opt$_beg_$_end_(_old$pre$0), read)) && ((acc(m_U32Opt$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(bool(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = &'_ (*_1)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_ref, write)
    _5.val_ref := borrow _1.val_ref // L15
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_5.val_ref), read)
    label l0
    // [mir] _4 = &'_ (*_5)
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_ref, write)
    _4.val_ref := borrow _5.val_ref // L14
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_4.val_ref), read)
    label l1
    // [mir] _3 = std::intrinsics::discriminant_value::<U32Opt>(move _4) -> [return: bb1, unwind: bb15]
    label l2
    assert(Stmt) true
    assert(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_4)) && (true)
    exhale (acc(_4.val_ref, write)) && ((true) && (true))
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(isize(_3), write)
    transfer perm _4.val_ref --> old[l2](_4.val_ref) // unchecked: true
    inhale(Stmt) (isize$inv<Ref(isize),Bool>(_3)) && (true)
    inhale(Expr) true
    exhale true
    label l3
    Goto(cfg:3)
  label l4 // 3
    // ========== l4 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    // expire_borrows ReborrowingDAG(L13,L14,L15,)

    if (__t0) && (true) {
    // expire loan L13
} else {}
    if (__t0) && ((__t0) && (true)) {
    // expire loan L14
    transfer perm old[l2](_4.val_ref) --> old[l1](_4.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l1](_4.val_ref)), read)
} else {}
    if (__t0) && ((__t0) && ((__t0) && (true))) {
    // expire loan L15
    exhale acc(m_U32Opt$_beg_$_end_(_5.val_ref), read)
} else {}
    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_4)
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageDead(_5)
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = &'_ (*_2)
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_ref, write)
    _8.val_ref := borrow _2.val_ref // L12
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_8.val_ref), read)
    label l5
    // [mir] _7 = &'_ (*_8)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_ref, write)
    _7.val_ref := borrow _8.val_ref // L5
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_7.val_ref), read)
    label l6
    // [mir] _6 = std::intrinsics::discriminant_value::<U32Opt>(move _7) -> [return: bb2, unwind: bb15]
    label l7
    assert(Stmt) true
    assert(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_7)) && (true)
    exhale (acc(_7.val_ref, write)) && ((true) && (true))
    _6 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(isize(_6), write)
    transfer perm _7.val_ref --> old[l7](_7.val_ref) // unchecked: true
    inhale(Stmt) (isize$inv<Ref(isize),Bool>(_6)) && (true)
    inhale(Expr) true
    exhale true
    label l8
    Goto(cfg:5)
  label l9 // 5
    // ========== l9 ==========
    // MIR edge bb1 --> bb2
    // Expire borrows
    // expire_borrows ReborrowingDAG(L6,L5,L12,)

    if (__t1) && (true) {
    // expire loan L6
} else {}
    if (__t1) && ((__t1) && (true)) {
    // expire loan L5
    transfer perm old[l7](_7.val_ref) --> old[l6](_7.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l6](_7.val_ref)), read)
} else {}
    if (__t1) && ((__t1) && ((__t1) && (true))) {
    // expire loan L12
    exhale acc(m_U32Opt$_beg_$_end_(_8.val_ref), read)
} else {}
    Goto(cfg:6)
  label bb2 // 6
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] StorageDead(_7)
    // [mir] FakeRead(ForLet, _6)
    // [mir] StorageDead(_8)
    // [mir] StorageLive(_9)
    // [mir] switchInt(const true) -> [false: bb4, otherwise: bb5]
    __t15 := copy true
    GotoSwitch([(UnaryOp(Not, Local(__t15: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l10 // 7
    // ========== l10 ==========
    // MIR edge bb2 --> bb5
    Goto(cfg:9)
  label l11 // 8
    // ========== l11 ==========
    // MIR edge bb2 --> bb4
    Goto(cfg:29)
  label bb5 // 9
    // ========== bb5 ==========
    __t3 := copy true
    // [mir] StorageLive(_10)
    // [mir] StorageLive(_11)
    // [mir] _11 = _3
    _11 := builtin$havoc_ref()
    inhale(Stmt) acc(_11.val_int, write)
    unfold acc(isize:None(_3), write)
    _11.val_int := copy _3.val_int
    label l12
    // [mir] StorageLive(_12)
    // [mir] _12 = _6
    _12 := builtin$havoc_ref()
    inhale(Stmt) acc(_12.val_int, write)
    unfold acc(isize:None(_6), write)
    _12.val_int := copy _6.val_int
    label l13
    // [mir] _10 = Eq(move _11, move _12)
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy (_11.val_int) == (_12.val_int)
    // [mir] StorageDead(_12)
    // [mir] StorageDead(_11)
    // [mir] switchInt(move _10) -> [false: bb4, otherwise: bb3]
    __t16 := copy _10.val_bool
    GotoSwitch([(UnaryOp(Not, Local(__t16: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:11)], cfg:10)
  label l14 // 10
    // ========== l14 ==========
    // MIR edge bb5 --> bb3
    Goto(cfg:12)
  label l15 // 11
    // ========== l15 ==========
    // MIR edge bb5 --> bb4
    Goto(cfg:30)
  label bb3 // 12
    // ========== bb3 ==========
    __t4 := copy true
    // [mir] _9 = const true
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy true
    // [mir] goto -> bb6
    Goto(cfg:31)
  label bb4 // 13
    // ========== bb4 ==========
    __t5 := copy true
    // [mir] _9 = const false
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy false
    // [mir] goto -> bb6
    Goto(cfg:14)
  label bb6 // 14
    // ========== bb6 ==========
    __t6 := copy true
    // [mir] StorageDead(_10)
    // [mir] switchInt(move _9) -> [false: bb8, otherwise: bb7]
    __t17 := copy _9.val_bool
    GotoSwitch([(UnaryOp(Not, Local(__t17: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:16)], cfg:15)
  label l16 // 15
    // ========== l16 ==========
    // MIR edge bb6 --> bb7
    Goto(cfg:17)
  label l17 // 16
    // ========== l17 ==========
    // MIR edge bb6 --> bb8
    Goto(cfg:27)
  label bb7 // 17
    // ========== bb7 ==========
    __t7 := copy true
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = &'_ (*_1)
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_ref, write)
    _14.val_ref := borrow _1.val_ref // L7
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_14.val_ref), read)
    label l18
    // [mir] StorageLive(_15)
    // [mir] _15 = &'_ (*_2)
    _15 := builtin$havoc_ref()
    inhale(Stmt) acc(_15.val_ref, write)
    _15.val_ref := borrow _2.val_ref // L8
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_15.val_ref), read)
    label l19
    // [mir] _13 = (move _14, move _15)
    _13 := builtin$havoc_ref()
    inhale(Stmt) acc(tuple2$ref$m_U32Opt$_beg_$_end_$ref$m_U32Opt$_beg_$_end_(_13), write)
    _aux_havoc_ref$m_U32Opt$_beg_$_end_ := builtin$havoc_ref()
    unfold acc(tuple2$ref$m_U32Opt$_beg_$_end_$ref$m_U32Opt$_beg_$_end_:None(_13), write)
    _13.tuple_0 := move _aux_havoc_ref$m_U32Opt$_beg_$_end_
    inhale(Stmt) acc(_13.tuple_0.val_ref, write)
    _13.tuple_0.val_ref := move _14.val_ref
    label l20
    _aux_havoc_ref$m_U32Opt$_beg_$_end_ := builtin$havoc_ref()
    _13.tuple_1 := move _aux_havoc_ref$m_U32Opt$_beg_$_end_
    inhale(Stmt) acc(_13.tuple_1.val_ref, write)
    _13.tuple_1.val_ref := move _15.val_ref
    label l21
    // [mir] StorageDead(_15)
    // [mir] StorageDead(_14)
    // [mir] FakeRead(ForMatchedPlace, _13)
    // [mir] _17 = discriminant((*(_13.0: &U32Opt)))
    _17 := builtin$havoc_ref()
    inhale(Stmt) acc(_17.val_int, write)
    _17.val_int := copy m_U32Opt$_beg_$_end_$$discriminant$$<Ref(m_U32Opt$_beg_$_end_),Int>(_13.tuple_0.val_ref)
    // [mir] switchInt(move _17) -> [0_isize: bb9, otherwise: bb11]
    __t18 := copy _17.val_int
    GotoSwitch([(BinOp(EqCmp, Local(__t18: Int, Position { line: 0, column: 0, id: 0 }), Const(BigInt("0"), Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:19)], cfg:18)
  label l22 // 18
    // ========== l22 ==========
    // MIR edge bb7 --> bb11
    // Expire borrows
    // expire_borrows ReborrowingDAG(L10,L9,L8,L7,)

    if (__t7) && (true) {
    // expire loan L10
    transfer perm _13.tuple_1.val_ref --> old[l21](_15.val_ref) // unchecked: false
} else {}
    if (__t7) && (true) {
    // expire loan L9
    transfer perm _13.tuple_0.val_ref --> old[l21](_14.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && (true)) {
    // expire loan L8
    transfer perm old[l21](_15.val_ref) --> old[l19](_15.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l19](_15.val_ref)), read)
    // drop Acc(old[l19](_15.val_ref), write) (Acc(old[l19](_15.val_ref), write))
    // drop Pred(_13.tuple_0.val_ref, read) (Pred(_13.tuple_0.val_ref, read))
} else {}
    if (__t7) && ((__t7) && (true)) {
    // expire loan L7
    transfer perm old[l21](_14.val_ref) --> old[l18](_14.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l18](_14.val_ref)), read)
    // drop Acc(old[l18](_14.val_ref), write) (Acc(old[l18](_14.val_ref), write))
    // drop Pred(_13.tuple_1.val_ref, read) (Pred(_13.tuple_1.val_ref, read))
} else {}
    Goto(cfg:23)
  label l23 // 19
    // ========== l23 ==========
    // MIR edge bb7 --> bb9
    Goto(cfg:20)
  label bb9 // 20
    // ========== bb9 ==========
    __t8 := copy true
    // [mir] _16 = discriminant((*(_13.1: &U32Opt)))
    _16 := builtin$havoc_ref()
    inhale(Stmt) acc(_16.val_int, write)
    _16.val_int := copy m_U32Opt$_beg_$_end_$$discriminant$$<Ref(m_U32Opt$_beg_$_end_),Int>(_13.tuple_1.val_ref)
    // [mir] switchInt(move _16) -> [0_isize: bb10, otherwise: bb11]
    __t19 := copy _16.val_int
    GotoSwitch([(BinOp(EqCmp, Local(__t19: Int, Position { line: 0, column: 0, id: 0 }), Const(BigInt("0"), Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:22)], cfg:21)
  label l24 // 21
    // ========== l24 ==========
    // MIR edge bb9 --> bb11
    // Expire borrows
    // expire_borrows ReborrowingDAG(L10,L9,L8,L7,)

    if (__t7) && (true) {
    // expire loan L10
    transfer perm _13.tuple_1.val_ref --> old[l21](_15.val_ref) // unchecked: false
} else {}
    if (__t7) && (true) {
    // expire loan L9
    transfer perm _13.tuple_0.val_ref --> old[l21](_14.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && (true)) {
    // expire loan L8
    transfer perm old[l21](_15.val_ref) --> old[l19](_15.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l19](_15.val_ref)), read)
    // drop Acc(old[l19](_15.val_ref), write) (Acc(old[l19](_15.val_ref), write))
    // drop Pred(_13.tuple_0.val_ref, read) (Pred(_13.tuple_0.val_ref, read))
} else {}
    if (__t7) && ((__t7) && (true)) {
    // expire loan L7
    transfer perm old[l21](_14.val_ref) --> old[l18](_14.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l18](_14.val_ref)), read)
    // drop Acc(old[l18](_14.val_ref), write) (Acc(old[l18](_14.val_ref), write))
    // drop Pred(_13.tuple_1.val_ref, read) (Pred(_13.tuple_1.val_ref, read))
} else {}
    Goto(cfg:32)
  label l25 // 22
    // ========== l25 ==========
    // MIR edge bb9 --> bb10
    Goto(cfg:24)
  label bb11 // 23
    // ========== bb11 ==========
    __t9 := copy true
    // [mir] _0 = const true
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_bool, write)
    _0.val_bool := copy true
    // [mir] goto -> bb13
    Goto(cfg:26)
  label bb10 // 24
    // ========== bb10 ==========
    __t10 := copy true
    // [mir] falseEdge -> [real: bb12, imaginary: bb11]
    Goto(cfg:25)
  label bb12 // 25
    // ========== bb12 ==========
    __t11 := copy true
    // [mir] StorageLive(_18)
    // [mir] _18 = &'_ (((*(_13.0: &U32Opt)) as Some).0: u32)
    _18 := builtin$havoc_ref()
    inhale(Stmt) acc(_18.val_ref, write)
    unfold acc(m_U32Opt$_beg_$_end_:Some(EnumVariantIndex("Some"))(_13.tuple_0.val_ref), read)
    unfold acc(m_U32Opt$_beg_$_end_Some:None(_13.tuple_0.val_ref[enum_Some]), read)
    _18.val_ref := borrow _13.tuple_0.val_ref[enum_Some].f$0 // L4
    inhale(Stmt) acc(u32(_18.val_ref), read)
    label l26
    // [mir] StorageLive(_19)
    // [mir] _19 = &'_ (((*(_13.1: &U32Opt)) as Some).0: u32)
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_ref, write)
    unfold acc(m_U32Opt$_beg_$_end_:Some(EnumVariantIndex("Some"))(_13.tuple_1.val_ref), read)
    unfold acc(m_U32Opt$_beg_$_end_Some:None(_13.tuple_1.val_ref[enum_Some]), read)
    _19.val_ref := borrow _13.tuple_1.val_ref[enum_Some].f$0 // L11
    inhale(Stmt) acc(u32(_19.val_ref), read)
    label l27
    // [mir] StorageLive(_20)
    // [mir] _20 = (*_18)
    _20 := builtin$havoc_ref()
    inhale(Stmt) acc(_20.val_int, write)
    unfold acc(u32:None(_18.val_ref), read)
    _20.val_int := copy _18.val_ref.val_int
    label l28
    // expire_borrows ReborrowingDAG(L4,L9,L7,)

    if (__t11) && (true) {
    // expire loan L4
    fold acc(u32:None(_18.val_ref), read)
    exhale acc(u32(_18.val_ref), read)
} else {}
    if (__t7) && ((__t11) && (true)) {
    // expire loan L9
    transfer perm _13.tuple_0.val_ref --> old[l21](_14.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && ((__t11) && (true))) {
    // expire loan L7
    transfer perm old[l21](_14.val_ref) --> old[l18](_14.val_ref) // unchecked: false
    fold acc(m_U32Opt$_beg_$_end_Some:None(old[l18](_14.val_ref)[enum_Some]), read)
    fold acc(m_U32Opt$_beg_$_end_:Some(EnumVariantIndex("Some"))(old[l18](_14.val_ref)), read)
    exhale acc(m_U32Opt$_beg_$_end_(old[l18](_14.val_ref)), read)
} else {}
    // [mir] StorageLive(_21)
    // [mir] _21 = (*_19)
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_int, write)
    unfold acc(u32:None(_19.val_ref), read)
    _21.val_int := copy _19.val_ref.val_int
    label l29
    // expire_borrows ReborrowingDAG(L11,L10,L8,)

    if (__t11) && (true) {
    // expire loan L11
    fold acc(u32:None(_19.val_ref), read)
    exhale acc(u32(_19.val_ref), read)
} else {}
    if (__t7) && ((__t11) && (true)) {
    // expire loan L10
    transfer perm _13.tuple_1.val_ref --> old[l21](_15.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && ((__t11) && (true))) {
    // expire loan L8
    transfer perm old[l21](_15.val_ref) --> old[l19](_15.val_ref) // unchecked: false
    fold acc(m_U32Opt$_beg_$_end_Some:None(old[l19](_15.val_ref)[enum_Some]), read)
    fold acc(m_U32Opt$_beg_$_end_:Some(EnumVariantIndex("Some"))(old[l19](_15.val_ref)), read)
    exhale acc(m_U32Opt$_beg_$_end_(old[l19](_15.val_ref)), read)
} else {}
    // [mir] _0 = Eq(move _20, move _21)
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_bool, write)
    _0.val_bool := copy (_20.val_int) == (_21.val_int)
    // [mir] StorageDead(_21)
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_18)
    // [mir] goto -> bb13
    Goto(cfg:33)
  label bb13 // 26
    // ========== bb13 ==========
    __t12 := copy true
    // [mir] StorageDead(_13)
    // [mir] goto -> bb14
    Goto(cfg:34)
  label bb8 // 27
    // ========== bb8 ==========
    __t13 := copy true
    // [mir] _0 = const false
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_bool, write)
    _0.val_bool := copy false
    // [mir] goto -> bb14
    Goto(cfg:28)
  label bb14 // 28
    // ========== bb14 ==========
    __t14 := copy true
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l30 // 29
    // ========== l30 ==========
    unfold acc(isize:None(_3), write)
    unfold acc(isize:None(_6), write)
    Goto(cfg:13)
  label l32 // 30
    // ========== l32 ==========
    // drop Acc(_11.val_int, write) (Acc(_11.val_int, write))
    // drop Acc(_12.val_int, write) (Acc(_12.val_int, write))
    // drop Acc(_10.val_bool, write) (Acc(_10.val_bool, write))
    Goto(cfg:13)
  label l33 // 31
    // ========== l33 ==========
    // drop Acc(_10.val_bool, write) (Acc(_10.val_bool, write))
    // drop Acc(_12.val_int, write) (Acc(_12.val_int, write))
    // drop Acc(_11.val_int, write) (Acc(_11.val_int, write))
    Goto(cfg:14)
  label l34 // 32
    // ========== l34 ==========
    // drop Acc(_16.val_int, write) (Acc(_16.val_int, write))
    Goto(cfg:23)
  label l35 // 33
    // ========== l35 ==========
    // drop Acc(_18.val_ref, write) (Acc(_18.val_ref, write))
    // drop Acc(_19.val_ref, write) (Acc(_19.val_ref, write))
    // drop Acc(old[l18](_14.val_ref), write) (Acc(old[l18](_14.val_ref), write))
    // drop Acc(_20.val_int, write) (Acc(_20.val_int, write))
    // drop Acc(_21.val_int, write) (Acc(_21.val_int, write))
    // drop Acc(_16.val_int, write) (Acc(_16.val_int, write))
    // drop Acc(old[l19](_15.val_ref), write) (Acc(old[l19](_15.val_ref), write))
    Goto(cfg:26)
  label l36 // 34
    // ========== l36 ==========
    // drop Acc(_17.val_int, write) (Acc(_17.val_int, write))
    // drop Acc(_14.val_ref, write) (Acc(_14.val_ref, write))
    // drop Acc(_13.tuple_1.val_ref, write) (Acc(_13.tuple_1.val_ref, write))
    // drop Acc(_15.val_ref, write) (Acc(_15.val_ref, write))
    // drop Acc(_13.tuple_0.val_ref, write) (Acc(_13.tuple_0.val_ref, write))
    // drop Acc(_13.tuple_0, write) (Acc(_13.tuple_0, write))
    // drop Acc(_13.tuple_1, write) (Acc(_13.tuple_1, write))
    Goto(cfg:28)
  label end_of_method
}


method m_ne(2 args)
    returns (_0: Ref(bool))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    _aux_havoc_ref$m_U32Opt$_beg_$_end_: Ref(ref$m_U32Opt$_beg_$_end_)
    __t18: Int
    __t19: Int
    _old$pre$0: Ref(m_U32Opt$_beg_$_end_)
    _old$pre$1: Ref(m_U32Opt$_beg_$_end_)
    _1: Ref(ref$m_U32Opt$_beg_$_end_)
    _2: Ref(ref$m_U32Opt$_beg_$_end_)
    _3: Ref(isize)
    _4: Ref(ref$m_U32Opt$_beg_$_end_)
    _5: Ref(ref$m_U32Opt$_beg_$_end_)
    _6: Ref(isize)
    _7: Ref(ref$m_U32Opt$_beg_$_end_)
    _8: Ref(ref$m_U32Opt$_beg_$_end_)
    _9: Ref(bool)
    _10: Ref(bool)
    _11: Ref(isize)
    _12: Ref(isize)
    _13: Ref(tuple2$ref$m_U32Opt$_beg_$_end_$ref$m_U32Opt$_beg_$_end_)
    _14: Ref(ref$m_U32Opt$_beg_$_end_)
    _15: Ref(ref$m_U32Opt$_beg_$_end_)
    _16: Ref(isize)
    _17: Ref(isize)
    _18: Ref(ref$u32)
    _19: Ref(ref$u32)
    _20: Ref(u32)
    _21: Ref(u32)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#6}::ne"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:97:10: 97:19 (#11)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_U32Opt$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_U32Opt$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_1)) && ((ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l31
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_U32Opt$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_U32Opt$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    fold acc(bool:None(_0), write)
    obtain acc(bool(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) true
    // Assert type invariants
    assert(Stmt) (bool$inv<Ref(bool),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_U32Opt$_beg_$_end_(_old$pre$0), read)) && ((acc(m_U32Opt$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(bool(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = &'_ (*_1)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_ref, write)
    _5.val_ref := borrow _1.val_ref // L5
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_5.val_ref), read)
    label l0
    // [mir] _4 = &'_ (*_5)
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_ref, write)
    _4.val_ref := borrow _5.val_ref // L4
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_4.val_ref), read)
    label l1
    // [mir] _3 = std::intrinsics::discriminant_value::<U32Opt>(move _4) -> [return: bb1, unwind: bb15]
    label l2
    assert(Stmt) true
    assert(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_4)) && (true)
    exhale (acc(_4.val_ref, write)) && ((true) && (true))
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(isize(_3), write)
    transfer perm _4.val_ref --> old[l2](_4.val_ref) // unchecked: true
    inhale(Stmt) (isize$inv<Ref(isize),Bool>(_3)) && (true)
    inhale(Expr) true
    exhale true
    label l3
    Goto(cfg:3)
  label l4 // 3
    // ========== l4 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    // expire_borrows ReborrowingDAG(L9,L4,L5,)

    if (__t0) && (true) {
    // expire loan L9
} else {}
    if (__t0) && ((__t0) && (true)) {
    // expire loan L4
    transfer perm old[l2](_4.val_ref) --> old[l1](_4.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l1](_4.val_ref)), read)
} else {}
    if (__t0) && ((__t0) && ((__t0) && (true))) {
    // expire loan L5
    exhale acc(m_U32Opt$_beg_$_end_(_5.val_ref), read)
} else {}
    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_4)
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageDead(_5)
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = &'_ (*_2)
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_ref, write)
    _8.val_ref := borrow _2.val_ref // L15
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_8.val_ref), read)
    label l5
    // [mir] _7 = &'_ (*_8)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_ref, write)
    _7.val_ref := borrow _8.val_ref // L8
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_7.val_ref), read)
    label l6
    // [mir] _6 = std::intrinsics::discriminant_value::<U32Opt>(move _7) -> [return: bb2, unwind: bb15]
    label l7
    assert(Stmt) true
    assert(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_7)) && (true)
    exhale (acc(_7.val_ref, write)) && ((true) && (true))
    _6 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(isize(_6), write)
    transfer perm _7.val_ref --> old[l7](_7.val_ref) // unchecked: true
    inhale(Stmt) (isize$inv<Ref(isize),Bool>(_6)) && (true)
    inhale(Expr) true
    exhale true
    label l8
    Goto(cfg:5)
  label l9 // 5
    // ========== l9 ==========
    // MIR edge bb1 --> bb2
    // Expire borrows
    // expire_borrows ReborrowingDAG(L6,L8,L15,)

    if (__t1) && (true) {
    // expire loan L6
} else {}
    if (__t1) && ((__t1) && (true)) {
    // expire loan L8
    transfer perm old[l7](_7.val_ref) --> old[l6](_7.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l6](_7.val_ref)), read)
} else {}
    if (__t1) && ((__t1) && ((__t1) && (true))) {
    // expire loan L15
    exhale acc(m_U32Opt$_beg_$_end_(_8.val_ref), read)
} else {}
    Goto(cfg:6)
  label bb2 // 6
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] StorageDead(_7)
    // [mir] FakeRead(ForLet, _6)
    // [mir] StorageDead(_8)
    // [mir] StorageLive(_9)
    // [mir] switchInt(const true) -> [false: bb4, otherwise: bb5]
    __t15 := copy true
    GotoSwitch([(UnaryOp(Not, Local(__t15: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l10 // 7
    // ========== l10 ==========
    // MIR edge bb2 --> bb5
    Goto(cfg:9)
  label l11 // 8
    // ========== l11 ==========
    // MIR edge bb2 --> bb4
    Goto(cfg:29)
  label bb5 // 9
    // ========== bb5 ==========
    __t3 := copy true
    // [mir] StorageLive(_10)
    // [mir] StorageLive(_11)
    // [mir] _11 = _3
    _11 := builtin$havoc_ref()
    inhale(Stmt) acc(_11.val_int, write)
    unfold acc(isize:None(_3), write)
    _11.val_int := copy _3.val_int
    label l12
    // [mir] StorageLive(_12)
    // [mir] _12 = _6
    _12 := builtin$havoc_ref()
    inhale(Stmt) acc(_12.val_int, write)
    unfold acc(isize:None(_6), write)
    _12.val_int := copy _6.val_int
    label l13
    // [mir] _10 = Eq(move _11, move _12)
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy (_11.val_int) == (_12.val_int)
    // [mir] StorageDead(_12)
    // [mir] StorageDead(_11)
    // [mir] switchInt(move _10) -> [false: bb4, otherwise: bb3]
    __t16 := copy _10.val_bool
    GotoSwitch([(UnaryOp(Not, Local(__t16: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:11)], cfg:10)
  label l14 // 10
    // ========== l14 ==========
    // MIR edge bb5 --> bb3
    Goto(cfg:12)
  label l15 // 11
    // ========== l15 ==========
    // MIR edge bb5 --> bb4
    Goto(cfg:30)
  label bb3 // 12
    // ========== bb3 ==========
    __t4 := copy true
    // [mir] _9 = const true
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy true
    // [mir] goto -> bb6
    Goto(cfg:31)
  label bb4 // 13
    // ========== bb4 ==========
    __t5 := copy true
    // [mir] _9 = const false
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy false
    // [mir] goto -> bb6
    Goto(cfg:14)
  label bb6 // 14
    // ========== bb6 ==========
    __t6 := copy true
    // [mir] StorageDead(_10)
    // [mir] switchInt(move _9) -> [false: bb8, otherwise: bb7]
    __t17 := copy _9.val_bool
    GotoSwitch([(UnaryOp(Not, Local(__t17: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:16)], cfg:15)
  label l16 // 15
    // ========== l16 ==========
    // MIR edge bb6 --> bb7
    Goto(cfg:17)
  label l17 // 16
    // ========== l17 ==========
    // MIR edge bb6 --> bb8
    Goto(cfg:27)
  label bb7 // 17
    // ========== bb7 ==========
    __t7 := copy true
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = &'_ (*_1)
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_ref, write)
    _14.val_ref := borrow _1.val_ref // L11
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_14.val_ref), read)
    label l18
    // [mir] StorageLive(_15)
    // [mir] _15 = &'_ (*_2)
    _15 := builtin$havoc_ref()
    inhale(Stmt) acc(_15.val_ref, write)
    _15.val_ref := borrow _2.val_ref // L10
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_15.val_ref), read)
    label l19
    // [mir] _13 = (move _14, move _15)
    _13 := builtin$havoc_ref()
    inhale(Stmt) acc(tuple2$ref$m_U32Opt$_beg_$_end_$ref$m_U32Opt$_beg_$_end_(_13), write)
    _aux_havoc_ref$m_U32Opt$_beg_$_end_ := builtin$havoc_ref()
    unfold acc(tuple2$ref$m_U32Opt$_beg_$_end_$ref$m_U32Opt$_beg_$_end_:None(_13), write)
    _13.tuple_0 := move _aux_havoc_ref$m_U32Opt$_beg_$_end_
    inhale(Stmt) acc(_13.tuple_0.val_ref, write)
    _13.tuple_0.val_ref := move _14.val_ref
    label l20
    _aux_havoc_ref$m_U32Opt$_beg_$_end_ := builtin$havoc_ref()
    _13.tuple_1 := move _aux_havoc_ref$m_U32Opt$_beg_$_end_
    inhale(Stmt) acc(_13.tuple_1.val_ref, write)
    _13.tuple_1.val_ref := move _15.val_ref
    label l21
    // [mir] StorageDead(_15)
    // [mir] StorageDead(_14)
    // [mir] FakeRead(ForMatchedPlace, _13)
    // [mir] _17 = discriminant((*(_13.0: &U32Opt)))
    _17 := builtin$havoc_ref()
    inhale(Stmt) acc(_17.val_int, write)
    _17.val_int := copy m_U32Opt$_beg_$_end_$$discriminant$$<Ref(m_U32Opt$_beg_$_end_),Int>(_13.tuple_0.val_ref)
    // [mir] switchInt(move _17) -> [0_isize: bb9, otherwise: bb11]
    __t18 := copy _17.val_int
    GotoSwitch([(BinOp(EqCmp, Local(__t18: Int, Position { line: 0, column: 0, id: 0 }), Const(BigInt("0"), Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:19)], cfg:18)
  label l22 // 18
    // ========== l22 ==========
    // MIR edge bb7 --> bb11
    // Expire borrows
    // expire_borrows ReborrowingDAG(L14,L13,L11,L10,)

    if (__t7) && (true) {
    // expire loan L14
    transfer perm _13.tuple_1.val_ref --> old[l21](_15.val_ref) // unchecked: false
} else {}
    if (__t7) && (true) {
    // expire loan L13
    transfer perm _13.tuple_0.val_ref --> old[l21](_14.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && (true)) {
    // expire loan L11
    transfer perm old[l21](_14.val_ref) --> old[l18](_14.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l18](_14.val_ref)), read)
    // drop Acc(old[l18](_14.val_ref), write) (Acc(old[l18](_14.val_ref), write))
    // drop Pred(_13.tuple_1.val_ref, read) (Pred(_13.tuple_1.val_ref, read))
} else {}
    if (__t7) && ((__t7) && (true)) {
    // expire loan L10
    transfer perm old[l21](_15.val_ref) --> old[l19](_15.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l19](_15.val_ref)), read)
    // drop Acc(old[l19](_15.val_ref), write) (Acc(old[l19](_15.val_ref), write))
    // drop Pred(_13.tuple_0.val_ref, read) (Pred(_13.tuple_0.val_ref, read))
} else {}
    Goto(cfg:23)
  label l23 // 19
    // ========== l23 ==========
    // MIR edge bb7 --> bb9
    Goto(cfg:20)
  label bb9 // 20
    // ========== bb9 ==========
    __t8 := copy true
    // [mir] _16 = discriminant((*(_13.1: &U32Opt)))
    _16 := builtin$havoc_ref()
    inhale(Stmt) acc(_16.val_int, write)
    _16.val_int := copy m_U32Opt$_beg_$_end_$$discriminant$$<Ref(m_U32Opt$_beg_$_end_),Int>(_13.tuple_1.val_ref)
    // [mir] switchInt(move _16) -> [0_isize: bb10, otherwise: bb11]
    __t19 := copy _16.val_int
    GotoSwitch([(BinOp(EqCmp, Local(__t19: Int, Position { line: 0, column: 0, id: 0 }), Const(BigInt("0"), Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:22)], cfg:21)
  label l24 // 21
    // ========== l24 ==========
    // MIR edge bb9 --> bb11
    // Expire borrows
    // expire_borrows ReborrowingDAG(L14,L13,L11,L10,)

    if (__t7) && (true) {
    // expire loan L14
    transfer perm _13.tuple_1.val_ref --> old[l21](_15.val_ref) // unchecked: false
} else {}
    if (__t7) && (true) {
    // expire loan L13
    transfer perm _13.tuple_0.val_ref --> old[l21](_14.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && (true)) {
    // expire loan L11
    transfer perm old[l21](_14.val_ref) --> old[l18](_14.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l18](_14.val_ref)), read)
    // drop Acc(old[l18](_14.val_ref), write) (Acc(old[l18](_14.val_ref), write))
    // drop Pred(_13.tuple_1.val_ref, read) (Pred(_13.tuple_1.val_ref, read))
} else {}
    if (__t7) && ((__t7) && (true)) {
    // expire loan L10
    transfer perm old[l21](_15.val_ref) --> old[l19](_15.val_ref) // unchecked: false
    exhale acc(m_U32Opt$_beg_$_end_(old[l19](_15.val_ref)), read)
    // drop Acc(old[l19](_15.val_ref), write) (Acc(old[l19](_15.val_ref), write))
    // drop Pred(_13.tuple_0.val_ref, read) (Pred(_13.tuple_0.val_ref, read))
} else {}
    Goto(cfg:32)
  label l25 // 22
    // ========== l25 ==========
    // MIR edge bb9 --> bb10
    Goto(cfg:24)
  label bb11 // 23
    // ========== bb11 ==========
    __t9 := copy true
    // [mir] _0 = const false
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_bool, write)
    _0.val_bool := copy false
    // [mir] goto -> bb13
    Goto(cfg:26)
  label bb10 // 24
    // ========== bb10 ==========
    __t10 := copy true
    // [mir] falseEdge -> [real: bb12, imaginary: bb11]
    Goto(cfg:25)
  label bb12 // 25
    // ========== bb12 ==========
    __t11 := copy true
    // [mir] StorageLive(_18)
    // [mir] _18 = &'_ (((*(_13.0: &U32Opt)) as Some).0: u32)
    _18 := builtin$havoc_ref()
    inhale(Stmt) acc(_18.val_ref, write)
    unfold acc(m_U32Opt$_beg_$_end_:Some(EnumVariantIndex("Some"))(_13.tuple_0.val_ref), read)
    unfold acc(m_U32Opt$_beg_$_end_Some:None(_13.tuple_0.val_ref[enum_Some]), read)
    _18.val_ref := borrow _13.tuple_0.val_ref[enum_Some].f$0 // L7
    inhale(Stmt) acc(u32(_18.val_ref), read)
    label l26
    // [mir] StorageLive(_19)
    // [mir] _19 = &'_ (((*(_13.1: &U32Opt)) as Some).0: u32)
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_ref, write)
    unfold acc(m_U32Opt$_beg_$_end_:Some(EnumVariantIndex("Some"))(_13.tuple_1.val_ref), read)
    unfold acc(m_U32Opt$_beg_$_end_Some:None(_13.tuple_1.val_ref[enum_Some]), read)
    _19.val_ref := borrow _13.tuple_1.val_ref[enum_Some].f$0 // L12
    inhale(Stmt) acc(u32(_19.val_ref), read)
    label l27
    // [mir] StorageLive(_20)
    // [mir] _20 = (*_18)
    _20 := builtin$havoc_ref()
    inhale(Stmt) acc(_20.val_int, write)
    unfold acc(u32:None(_18.val_ref), read)
    _20.val_int := copy _18.val_ref.val_int
    label l28
    // expire_borrows ReborrowingDAG(L7,L13,L11,)

    if (__t11) && (true) {
    // expire loan L7
    fold acc(u32:None(_18.val_ref), read)
    exhale acc(u32(_18.val_ref), read)
} else {}
    if (__t7) && ((__t11) && (true)) {
    // expire loan L13
    transfer perm _13.tuple_0.val_ref --> old[l21](_14.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && ((__t11) && (true))) {
    // expire loan L11
    transfer perm old[l21](_14.val_ref) --> old[l18](_14.val_ref) // unchecked: false
    fold acc(m_U32Opt$_beg_$_end_Some:None(old[l18](_14.val_ref)[enum_Some]), read)
    fold acc(m_U32Opt$_beg_$_end_:Some(EnumVariantIndex("Some"))(old[l18](_14.val_ref)), read)
    exhale acc(m_U32Opt$_beg_$_end_(old[l18](_14.val_ref)), read)
} else {}
    // [mir] StorageLive(_21)
    // [mir] _21 = (*_19)
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_int, write)
    unfold acc(u32:None(_19.val_ref), read)
    _21.val_int := copy _19.val_ref.val_int
    label l29
    // expire_borrows ReborrowingDAG(L12,L14,L10,)

    if (__t11) && (true) {
    // expire loan L12
    fold acc(u32:None(_19.val_ref), read)
    exhale acc(u32(_19.val_ref), read)
} else {}
    if (__t7) && ((__t11) && (true)) {
    // expire loan L14
    transfer perm _13.tuple_1.val_ref --> old[l21](_15.val_ref) // unchecked: false
} else {}
    if (__t7) && ((__t7) && ((__t11) && (true))) {
    // expire loan L10
    transfer perm old[l21](_15.val_ref) --> old[l19](_15.val_ref) // unchecked: false
    fold acc(m_U32Opt$_beg_$_end_Some:None(old[l19](_15.val_ref)[enum_Some]), read)
    fold acc(m_U32Opt$_beg_$_end_:Some(EnumVariantIndex("Some"))(old[l19](_15.val_ref)), read)
    exhale acc(m_U32Opt$_beg_$_end_(old[l19](_15.val_ref)), read)
} else {}
    // [mir] _0 = Ne(move _20, move _21)
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_bool, write)
    _0.val_bool := copy !((_20.val_int) == (_21.val_int))
    // [mir] StorageDead(_21)
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_18)
    // [mir] goto -> bb13
    Goto(cfg:33)
  label bb13 // 26
    // ========== bb13 ==========
    __t12 := copy true
    // [mir] StorageDead(_13)
    // [mir] goto -> bb14
    Goto(cfg:34)
  label bb8 // 27
    // ========== bb8 ==========
    __t13 := copy true
    // [mir] _0 = const true
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_bool, write)
    _0.val_bool := copy true
    // [mir] goto -> bb14
    Goto(cfg:28)
  label bb14 // 28
    // ========== bb14 ==========
    __t14 := copy true
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l30 // 29
    // ========== l30 ==========
    unfold acc(isize:None(_3), write)
    unfold acc(isize:None(_6), write)
    Goto(cfg:13)
  label l32 // 30
    // ========== l32 ==========
    // drop Acc(_12.val_int, write) (Acc(_12.val_int, write))
    // drop Acc(_11.val_int, write) (Acc(_11.val_int, write))
    // drop Acc(_10.val_bool, write) (Acc(_10.val_bool, write))
    Goto(cfg:13)
  label l33 // 31
    // ========== l33 ==========
    // drop Acc(_11.val_int, write) (Acc(_11.val_int, write))
    // drop Acc(_12.val_int, write) (Acc(_12.val_int, write))
    // drop Acc(_10.val_bool, write) (Acc(_10.val_bool, write))
    Goto(cfg:14)
  label l34 // 32
    // ========== l34 ==========
    // drop Acc(_16.val_int, write) (Acc(_16.val_int, write))
    Goto(cfg:23)
  label l35 // 33
    // ========== l35 ==========
    // drop Acc(old[l18](_14.val_ref), write) (Acc(old[l18](_14.val_ref), write))
    // drop Acc(_21.val_int, write) (Acc(_21.val_int, write))
    // drop Acc(_16.val_int, write) (Acc(_16.val_int, write))
    // drop Acc(_20.val_int, write) (Acc(_20.val_int, write))
    // drop Acc(_18.val_ref, write) (Acc(_18.val_ref, write))
    // drop Acc(_19.val_ref, write) (Acc(_19.val_ref, write))
    // drop Acc(old[l19](_15.val_ref), write) (Acc(old[l19](_15.val_ref), write))
    Goto(cfg:26)
  label l36 // 34
    // ========== l36 ==========
    // drop Acc(_14.val_ref, write) (Acc(_14.val_ref, write))
    // drop Acc(_13.tuple_1.val_ref, write) (Acc(_13.tuple_1.val_ref, write))
    // drop Acc(_17.val_int, write) (Acc(_17.val_int, write))
    // drop Acc(_15.val_ref, write) (Acc(_15.val_ref, write))
    // drop Acc(_13.tuple_0.val_ref, write) (Acc(_13.tuple_0.val_ref, write))
    // drop Acc(_13.tuple_0, write) (Acc(_13.tuple_0, write))
    // drop Acc(_13.tuple_1, write) (Acc(_13.tuple_1, write))
    Goto(cfg:28)
  label end_of_method
}


struct_predicate m_Global$_beg_$_end_(self){
  true
}


struct_predicate raw_ref$bool(self);


struct_predicate m_PhantomData$_beg_$bool$_end_(self){
  true
}


struct_predicate m_Unique$_beg_$bool$_end_(self){
  (acc(self.f$pointer, write)) && ((acc(raw_ref$bool(self.f$pointer), write)) && ((acc(self.f$_marker, write)) && ((acc(m_PhantomData$_beg_$bool$_end_(self.f$_marker), write)) && (true))))
}


struct_predicate usize(self){
  (acc(self.val_int, write)) && (true)
}


struct_predicate m_RawVec$_beg_$bool$_sep_$m_Global$_beg_$_end_$_end_(self){
  (acc(self.f$ptr, write)) && ((acc(m_Unique$_beg_$bool$_end_(self.f$ptr), write)) && ((acc(self.f$cap, write)) && ((acc(usize(self.f$cap), write)) && ((acc(self.f$alloc, write)) && ((acc(m_Global$_beg_$_end_(self.f$alloc), write)) && (true))))))
}


struct_predicate m_Vec$_beg_$bool$_sep_$m_Global$_beg_$_end_$_end_(self){
  (acc(self.f$buf, write)) && ((acc(m_RawVec$_beg_$bool$_sep_$m_Global$_beg_$_end_$_end_(self.f$buf), write)) && ((acc(self.f$len, write)) && ((acc(usize(self.f$len), write)) && (true))))
}


struct_predicate m_BoolArr32$_beg_$_end_(self){
  (acc(self.f$v, write)) && ((acc(m_Vec$_beg_$bool$_sep_$m_Global$_beg_$_end_$_end_(self.f$v), write)) && (true))
}


struct_predicate closure$0_41$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_41$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_41$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate ref$usize(self){
  (acc(self.val_ref, write)) && ((acc(usize(self.val_ref), write)) && (true))
}


struct_predicate ref$m_BoolArr32$_beg_$_end_(self){
  (acc(self.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(self.val_ref), write)) && (true))
}


function m_len(_1: Ref(m_BoolArr32$_beg_$_end_)): Int
  requires (acc(m_BoolArr32$_beg_$_end_(_1), read)) && (true)
  requires true
  ensures ((__result) == (32)) && (true)


struct_predicate closure$0_44$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_44$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_44$3$8495963677228082619(self.val_ref), write)) && (true))
}


function builtin$unreach_bool(): Bool
  requires false


struct_predicate closure$0_45$3$148307520387589505(self){
  true
}


struct_predicate ref$closure$0_45$3$148307520387589505(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_45$3$148307520387589505(self.val_ref), write)) && (true))
}


struct_predicate ref$ref$m_BoolArr32$_beg_$_end_(self){
  (acc(self.val_ref, write)) && ((acc(ref$m_BoolArr32$_beg_$_end_(self.val_ref), write)) && (true))
}


function m_lookup(_1: Ref(m_BoolArr32$_beg_$_end_), _2: Int): Bool
  requires (acc(m_BoolArr32$_beg_$_end_(_1), read)) && (true)
  requires (((0) <= (_2)) && (((_2) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_1))) && (true))) && (true)
  ensures true


struct_predicate ref$bool(self){
  (acc(self.val_ref, write)) && ((acc(bool(self.val_ref), write)) && (true))
}


struct_predicate tuple2$usize$bool(self){
  (acc(self.tuple_0, write)) && ((acc(usize(self.tuple_0), write)) && ((acc(self.tuple_1, write)) && ((acc(bool(self.tuple_1), write)) && (true))))
}


struct_predicate closure$0_67$3$13114848456984105119(self){
  true
}


struct_predicate closure$0_70$3$7219283737433700658(self){
  true
}


struct_predicate never(self);


struct_predicate closure$0_36$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_36$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_36$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_35$3$14251816320613143870(self){
  true
}


struct_predicate ref$closure$0_35$3$14251816320613143870(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_35$3$14251816320613143870(self.val_ref), write)) && (true))
}


struct_predicate closure$0_37$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_37$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_37$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_38$3$634645340582930069(self){
  true
}


struct_predicate ref$closure$0_38$3$634645340582930069(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_38$3$634645340582930069(self.val_ref), write)) && (true))
}


struct_predicate closure$0_68$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_68$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_68$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_67$3$13114848456984105119(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_67$3$13114848456984105119(self.val_ref), write)) && (true))
}


struct_predicate closure$0_69$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_69$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_69$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_72$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_72$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_72$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_71$3$12702952023364619181(self){
  true
}


struct_predicate ref$closure$0_71$3$12702952023364619181(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_71$3$12702952023364619181(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_70$3$7219283737433700658(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_70$3$7219283737433700658(self.val_ref), write)) && (true))
}


struct_predicate closure$0_73$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_73$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_73$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_74$3$9903976678192147628(self){
  true
}


struct_predicate ref$closure$0_74$3$9903976678192147628(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_74$3$9903976678192147628(self.val_ref), write)) && (true))
}


struct_predicate closure$0_48$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_48$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_48$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_49$3$8731896813294706411(self){
  true
}


struct_predicate ref$closure$0_49$3$8731896813294706411(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_49$3$8731896813294706411(self.val_ref), write)) && (true))
}


struct_predicate closure$0_53$3$10699146559852440452(self){
  true
}


struct_predicate ref$closure$0_53$3$10699146559852440452(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_53$3$10699146559852440452(self.val_ref), write)) && (true))
}


struct_predicate closure$0_54$3$10918761881378066563(self){
  true
}


struct_predicate ref$closure$0_54$3$10918761881378066563(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_54$3$10918761881378066563(self.val_ref), write)) && (true))
}


struct_predicate ref$ref$bool(self){
  (acc(self.val_ref, write)) && ((acc(ref$bool(self.val_ref), write)) && (true))
}


struct_predicate closure$0_56$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_56$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_56$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_55$3$18215228686208147315(self){
  true
}


struct_predicate ref$closure$0_55$3$18215228686208147315(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_55$3$18215228686208147315(self.val_ref), write)) && (true))
}


struct_predicate closure$0_57$3$8731896813294706411(self){
  true
}


struct_predicate ref$closure$0_57$3$8731896813294706411(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_57$3$8731896813294706411(self.val_ref), write)) && (true))
}


struct_predicate closure$0_58$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_58$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_58$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_59$3$2812121096262411779(self){
  true
}


struct_predicate ref$closure$0_59$3$2812121096262411779(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_59$3$2812121096262411779(self.val_ref), write)) && (true))
}


struct_predicate closure$0_51$3$15591262141140406642(self){
  true
}


struct_predicate ref$closure$0_51$3$15591262141140406642(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_51$3$15591262141140406642(self.val_ref), write)) && (true))
}


struct_predicate closure$0_63$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_63$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_63$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_62$3$6207018731879239482(self){
  true
}


struct_predicate ref$closure$0_62$3$6207018731879239482(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_62$3$6207018731879239482(self.val_ref), write)) && (true))
}


struct_predicate closure$0_64$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_64$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_64$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_65$3$9903976678192147628(self){
  true
}


struct_predicate ref$closure$0_65$3$9903976678192147628(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_65$3$9903976678192147628(self.val_ref), write)) && (true))
}


method m_flip_bits(1 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    _old$l13$0: Ref(bool)
    __t21: Bool
    __t22: Bool
    __t23: Bool
    _1: Ref(m_BoolArr32$_beg_$_end_)
    _2: Ref(m_BoolArr32$_beg_$_end_)
    _3: Ref(usize)
    _4: Ref(tuple0$)
    _5: Ref(tuple0$)
    _6: Ref(bool)
    _7: Ref(usize)
    _8: Ref(tuple0$)
    _9: Ref(bool)
    _10: Ref(closure$0_67$3$13114848456984105119)
    _11: Ref(ref$usize)
    _12: Ref(tuple0$)
    _13: Ref(bool)
    _14: Ref(closure$0_70$3$7219283737433700658)
    _15: Ref(ref$usize)
    _16: Ref(ref$m_BoolArr32$_beg_$_end_)
    _17: Ref(ref$m_BoolArr32$_beg_$_end_)
    _18: Ref(bool)
    _19: Ref(ref$m_BoolArr32$_beg_$_end_)
    _20: Ref(usize)
    _21: Ref(usize)
    _22: Ref(tuple2$usize$bool)
    _23: Ref(ref$bool)
    _24: Ref(ref$m_BoolArr32$_beg_$_end_)
    _25: Ref(usize)
    _26: Ref(tuple2$usize$bool)
    _27: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#0}::flip_bits"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:199:5: 220:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    __t16 := copy false
    // Preconditions:
    inhale(Stmt) (acc(m_BoolArr32$_beg_$_end_(_1), write)) && (true)
    inhale(Stmt) true
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_1)) && (true)
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l21
    // Fold predicates for &mut args and transfer borrow permissions to old
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_0083a8e4b4f24223afffc7f9d8f3cf80_101: Int  :: (((0) <= (_2_forall_0083a8e4b4f24223afffc7f9d8f3cf80_101)) && (((_2_forall_0083a8e4b4f24223afffc7f9d8f3cf80_101) < (32)) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_0083a8e4b4f24223afffc7f9d8f3cf80_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1, (31) - (_2_forall_0083a8e4b4f24223afffc7f9d8f3cf80_101)))):(false))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale true
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_2)
    // [mir] _2 = BoolArr32::zero() -> [return: bb1, unwind: bb20]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _2 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_2), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_2)) && (true)
    inhale(Expr) (forall _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101: Int  :: (((0) <= (_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)) && (((_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2, _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _2)
    // [mir] StorageLive(_3)
    // [mir] _3 = const 0_usize
    _3 := builtin$havoc_ref()
    inhale(Stmt) acc(_3.val_int, write)
    _3.val_int := copy 0
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb19]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] _7 = _3
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_int, write)
    _7.val_int := copy _3.val_int
    label l2
    // [mir] _6 = Lt(move _7, const 32_usize)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_bool, write)
    _6.val_bool := copy (_7.val_int) < (32)
    // [mir] StorageDead(_7)
    // [mir] FakeRead(ForMatchedPlace, _6)
    // [mir] switchInt(_6) -> [false: bb5, otherwise: bb4]
    __t17 := copy _6.val_bool
    GotoSwitch([(Local(__t17: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:29)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_8)
    // [mir] StorageLive(_9)
    // [mir] _9 = const false
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy false
    // [mir] switchInt(move _9) -> [false: bb8, otherwise: bb7]
    __t18 := copy _9.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_6), write)
    obtain acc(bool(_6), write)
    fold acc(usize:None(_3), write)
    obtain acc(usize(_3), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_2), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_1), read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_3), write) in _3.val_int))) && ((((unfolding acc(usize:None(_3), write) in _3.val_int)) < (32)) && (true))) && ((forall _2_forall_665d1c97d964440a8bd771ad7ee2a15d_101: Int  :: (((0) <= (_2_forall_665d1c97d964440a8bd771ad7ee2a15d_101)) && (((_2_forall_665d1c97d964440a8bd771ad7ee2a15d_101) < ((unfolding acc(usize:None(_3), write) in _3.val_int))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2, _2_forall_665d1c97d964440a8bd771ad7ee2a15d_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1, (31) - (_2_forall_665d1c97d964440a8bd771ad7ee2a15d_101)))):(false))) && (true))
    assert(Expr) true
    exhale (acc(bool(_6), write)) && ((acc(usize(_3), write)) && ((acc(m_BoolArr32$_beg_$_end_(_2), write)) && ((acc(m_BoolArr32$_beg_$_end_(_1), read)) && (true))))
    _26 := builtin$havoc_ref()
    _20 := builtin$havoc_ref()
    _7 := builtin$havoc_ref()
    _3 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    __t6 := builtin$havoc_bool()
    _21 := builtin$havoc_ref()
    __t21 := builtin$havoc_bool()
    __t4 := builtin$havoc_bool()
    _6 := builtin$havoc_ref()
    __t13 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    __t8 := builtin$havoc_bool()
    _13 := builtin$havoc_ref()
    _23 := builtin$havoc_ref()
    _18 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    _24 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    _22 := builtin$havoc_ref()
    __t5 := builtin$havoc_bool()
    __t22 := builtin$havoc_bool()
    _25 := builtin$havoc_ref()
    __t23 := builtin$havoc_bool()
    __t12 := builtin$havoc_bool()
    _19 := builtin$havoc_ref()
    __t19 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    _9 := builtin$havoc_ref()
    __t2 := builtin$havoc_bool()
    __t20 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_6), write)) && ((acc(usize(_3), write)) && ((acc(m_BoolArr32$_beg_$_end_(_2), write)) && ((acc(m_BoolArr32$_beg_$_end_(_1), read)) && (true))))
    inhale(Expr) true
    inhale(Expr) (((0) <= ((unfolding acc(usize:None(_3), write) in _3.val_int))) && ((((unfolding acc(usize:None(_3), write) in _3.val_int)) < (32)) && (true))) && ((forall _2_forall_665d1c97d964440a8bd771ad7ee2a15d_101: Int  :: (((0) <= (_2_forall_665d1c97d964440a8bd771ad7ee2a15d_101)) && (((_2_forall_665d1c97d964440a8bd771ad7ee2a15d_101) < ((unfolding acc(usize:None(_3), write) in _3.val_int))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2, _2_forall_665d1c97d964440a8bd771ad7ee2a15d_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1, (31) - (_2_forall_665d1c97d964440a8bd771ad7ee2a15d_101)))):(false))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _8 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_8)
    // [mir] StorageLive(_12)
    // [mir] StorageLive(_13)
    // [mir] _13 = const false
    _13 := builtin$havoc_ref()
    inhale(Stmt) acc(_13.val_bool, write)
    _13.val_bool := copy false
    // [mir] switchInt(move _13) -> [false: bb11, otherwise: bb10]
    __t19 := copy _13.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _12 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_13)
    // [mir] StorageDead(_12)
    // [mir] StorageLive(_18)
    // [mir] StorageLive(_19)
    // [mir] _19 = &'_ _1
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_ref, write)
    _19.val_ref := borrow _1 // L4
    exhale acc(m_BoolArr32$_beg_$_end_(_1), write-read)
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_19.val_ref), read)
    label l5
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = _3
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_int, write)
    unfold acc(usize:None(_3), write)
    _21.val_int := copy _3.val_int
    label l6
    // [mir] _22 = CheckedSub(const 31_usize, _21)
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.tuple_0, write)
    inhale(Stmt) acc(_22.tuple_0.val_int, write)
    inhale(Stmt) acc(_22.tuple_1, write)
    inhale(Stmt) acc(_22.tuple_1.val_bool, write)
    _22.tuple_0.val_int := copy (31) - (_21.val_int)
    _22.tuple_1.val_bool := copy false
    // [mir] assert(!move (_22.1: bool), "attempt to compute `{} - {}`, which would overflow", const 31_usize, move _21) -> [success: bb13, unwind: bb19]
    __t20 := copy _22.tuple_1.val_bool
    // Rust assertion: attempt to subtract with overflow
    assert(Stmt) !(__t20)
    Goto(cfg:17)
  label loop2_group3_bb13 // 17
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] _20 = move (_22.0: usize)
    _20 := move _22.tuple_0
    label l7
    // [mir] StorageDead(_21)
    // [mir] _18 = BoolArr32::lookup(move _19, move _20) -> [return: bb14, unwind: bb19]
    label l8
    _18 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_18), write)
    unfold acc(bool:None(_18), write)
    inhale(Stmt) (_18.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_19.val_ref, _20.val_int))
    transfer perm _19.val_ref --> old[l8](_19.val_ref) // unchecked: false
    Goto(cfg:18)
  label l9 // 18
    // ========== l9 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    // expire_borrows ReborrowingDAG(L8,L4,)

    if (__t10) && (true) {
    // expire loan L8
} else {}
    if (__t9) && ((__t10) && (true)) {
    // expire loan L4
    transfer perm old[l8](_19.val_ref) --> old[l5](_19.val_ref) // unchecked: false
    exhale acc(m_BoolArr32$_beg_$_end_(old[l5](_19.val_ref)), read)
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_1), write-read)
} else {}
    Goto(cfg:19)
  label loop2_group3_bb14 // 19
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_19)
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] _24 = &'_ mut _2
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(_24.val_ref, write)
    _24.val_ref := mut borrow _2 // L5
    label l10
    // [mir] StorageLive(_25)
    // [mir] _25 = _3
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_int, write)
    _25.val_int := copy _3.val_int
    label l11
    // [mir] _23 = BoolArr32::index_mut(move _24, move _25) -> [return: bb15, unwind: bb19]
    label l12
    assert(Stmt) (((0) <= (_25.val_int)) && (((_25.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_24.val_ref))) && (true))) && (true)
    fold acc(usize:None(_25), write)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_24)) && ((usize$inv<Ref(usize),Bool>(_25)) && (true))
    exhale (acc(_24.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_24.val_ref), write)) && ((acc(usize(_25), write)) && (true)))
    _23 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_23.val_ref, write)) && (acc(bool(_23.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_23)) && (true)
    inhale(Expr) (((unfolding acc(bool:None(_23.val_ref), write) in _23.val_ref.val_bool)) == (old[l12](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _25.val_int)))) && (true)
    exhale true
    label l13
    Goto(cfg:20)
  label loop2_group3_bb15 // 20
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_25)
    // [mir] StorageDead(_24)
    // [mir] (*_23) = move _18
    _23.val_ref := move _18
    label l14
    // expire_borrows ReborrowingDAG(L9,L10,L5,)

    if (__t11) && (true) {
    // expire loan L9
    _old$l13$0 := move _23.val_ref
    inhale(Stmt) (((acc(bool(_old$l13$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l13$0))) && ((true) && (true))) Some(L9) --* (((acc(m_BoolArr32$_beg_$_end_(old[l12](_24.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l12](_24.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l12](_24.val_ref))) == (old[l12](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_24.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l12](_24.val_ref), old[l12](_25.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l13$0), write) in _old$l13$0.val_bool)))) && ((forall _2_forall_5be58431c8f94233ac0b32ea01095bd7_103: Int  :: (((0) <= (_2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) && (((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l12](_24.val_ref)))) && ((!((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) == (old[l12](_25.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l12](_24.val_ref), _2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) == (old[l12](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _2_forall_5be58431c8f94233ac0b32ea01095bd7_103))))) && (true)))) && (true)))
    fold acc(bool:None(_old$l13$0), write)
    apply[L9] ((acc(bool(_old$l13$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l13$0))) && ((true) && (true)) --* ((acc(m_BoolArr32$_beg_$_end_(old[l12](_24.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l12](_24.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l12](_24.val_ref))) == (old[l12](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_24.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l12](_24.val_ref), old[l12](_25.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l13$0), write) in _old$l13$0.val_bool)))) && ((forall _2_forall_5be58431c8f94233ac0b32ea01095bd7_103: Int  :: (((0) <= (_2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) && (((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l12](_24.val_ref)))) && ((!((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) == (old[l12](_25.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l12](_24.val_ref), _2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) == (old[l12](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _2_forall_5be58431c8f94233ac0b32ea01095bd7_103))))) && (true)))) && (true))
    
} else {}
    if (__t11) && ((__t11) && (true)) {
    // expire loan L10
} else {}
    if (__t11) && ((__t11) && ((__t11) && (true))) {
    // expire loan L5
    transfer perm old[l12](_24.val_ref) --> old[l10](_24.val_ref) // unchecked: false
    transfer perm old[l10](_24.val_ref) --> _2 // unchecked: false
} else {}
    // [mir] StorageDead(_18)
    // [mir] StorageDead(_23)
    // [mir] _26 = CheckedAdd(_3, const 1_usize)
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.tuple_0, write)
    inhale(Stmt) acc(_26.tuple_0.val_int, write)
    inhale(Stmt) acc(_26.tuple_1, write)
    inhale(Stmt) acc(_26.tuple_1.val_bool, write)
    _26.tuple_0.val_int := copy (_3.val_int) + (1)
    _26.tuple_1.val_bool := copy false
    // [mir] assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_usize) -> [success: bb16, unwind: bb19]
    __t21 := copy _26.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t21)
    Goto(cfg:21)
  label loop2_group3_bb16 // 21
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _3 = move (_26.0: usize)
    _3 := move _26.tuple_0
    label l15
    // [mir] _5 = const ()
    // [mir] StorageDead(_6)
    // [mir] goto -> bb2
    Goto(cfg:22)
  label loop2_group4_bb2 // 22
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb19]
    Goto(cfg:23)
  label loop2_group4_bb3 // 23
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] _7 = _3
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_int, write)
    _7.val_int := copy _3.val_int
    label l16
    // [mir] _6 = Lt(move _7, const 32_usize)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_bool, write)
    _6.val_bool := copy (_7.val_int) < (32)
    // [mir] StorageDead(_7)
    // [mir] FakeRead(ForMatchedPlace, _6)
    // [mir] switchInt(_6) -> [false: bb5, otherwise: bb4]
    __t22 := copy _6.val_bool
    GotoSwitch([(Local(__t22: Bool, Position { line: 0, column: 0, id: 0 }), cfg:25)], cfg:24)
  label l17 // 24
    // ========== l17 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:32)
  label l18 // 25
    // ========== l18 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:26)
  label loop2_group5_bb4 // 26
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:27)
  label loop2_group5_bb6 // 27
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_8)
    // [mir] StorageLive(_9)
    // [mir] _9 = const false
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy false
    // [mir] switchInt(move _9) -> [false: bb8, otherwise: bb7]
    __t23 := copy _9.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:28)
  label loop2_end_body // 28
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_6), write)
    obtain acc(bool(_6), write)
    fold acc(usize:None(_3), write)
    obtain acc(usize(_3), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_2), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_1), read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_3), write) in _3.val_int))) && ((((unfolding acc(usize:None(_3), write) in _3.val_int)) < (32)) && (true))) && ((forall _2_forall_665d1c97d964440a8bd771ad7ee2a15d_101: Int  :: (((0) <= (_2_forall_665d1c97d964440a8bd771ad7ee2a15d_101)) && (((_2_forall_665d1c97d964440a8bd771ad7ee2a15d_101) < ((unfolding acc(usize:None(_3), write) in _3.val_int))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2, _2_forall_665d1c97d964440a8bd771ad7ee2a15d_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1, (31) - (_2_forall_665d1c97d964440a8bd771ad7ee2a15d_101)))):(false))) && (true))
    assert(Expr) true
    exhale (acc(bool(_6), write)) && ((acc(usize(_3), write)) && ((acc(m_BoolArr32$_beg_$_end_(_2), write)) && ((acc(m_BoolArr32$_beg_$_end_(_1), read)) && (true))))
    inhale(Stmt) false
    Return
  label bb5 // 29
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _4 = const ()
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_4)
    // [mir] _0 = move _2
    _0 := move _2
    label l19
    // [mir] StorageDead(_3)
    // [mir] drop(_2) -> [return: bb17, unwind: bb20]
    Goto(cfg:30)
  label bb17 // 30
    // ========== bb17 ==========
    __t15 := copy true
    // [mir] StorageDead(_2)
    // [mir] drop(_1) -> [return: bb18, unwind: bb21]
    Goto(cfg:31)
  label bb18 // 31
    // ========== bb18 ==========
    __t16 := copy true
    // [mir] return
    Goto(cfg:1)
  label l20 // 32
    // ========== l20 ==========
    // drop Acc(_22.tuple_1.val_bool, write) (Acc(_22.tuple_1.val_bool, write))
    // drop Acc(_19.val_ref, write) (Acc(_19.val_ref, write))
    // drop Acc(old[l5](_19.val_ref), write) (Acc(old[l5](_19.val_ref), write))
    // drop Acc(_23.val_ref, write) (Acc(_23.val_ref, write))
    // drop Acc(_26.tuple_1.val_bool, write) (Acc(_26.tuple_1.val_bool, write))
    // drop Acc(_13.val_bool, write) (Acc(_13.val_bool, write))
    // drop Acc(_21.val_int, write) (Acc(_21.val_int, write))
    // drop Acc(_26.tuple_0, write) (Acc(_26.tuple_0, write))
    // drop Acc(_22.tuple_0, write) (Acc(_22.tuple_0, write))
    // drop Acc(_20.val_int, write) (Acc(_20.val_int, write))
    // drop Acc(_22.tuple_1, write) (Acc(_22.tuple_1, write))
    // drop Acc(_26.tuple_1, write) (Acc(_26.tuple_1, write))
    Goto(cfg:29)
  label end_of_method
}


struct_predicate closure$0_95$3$3859392265678673261(self){
  true
}


struct_predicate closure$0_108$3$12351797966212270264(self){
  true
}


struct_predicate closure$0_99$3$2536757696045608690(self){
  true
}


struct_predicate closure$0_92$3$13114848456984105119(self){
  true
}


struct_predicate closure$0_93$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_93$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_93$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_92$3$13114848456984105119(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_92$3$13114848456984105119(self.val_ref), write)) && (true))
}


struct_predicate closure$0_94$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_94$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_94$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_96$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_96$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_96$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_95$3$3859392265678673261(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_95$3$3859392265678673261(self.val_ref), write)) && (true))
}


struct_predicate closure$0_97$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_97$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_97$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_98$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_98$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_98$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_101$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_101$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_101$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_100$3$3620985974840008788(self){
  true
}


struct_predicate ref$closure$0_100$3$3620985974840008788(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_100$3$3620985974840008788(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_99$3$2536757696045608690(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_99$3$2536757696045608690(self.val_ref), write)) && (true))
}


struct_predicate closure$0_102$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_102$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_102$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_103$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_103$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_103$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_104$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_104$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_104$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_105$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_105$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_105$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_106$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_106$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_106$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_107$3$16510859290061661556(self){
  true
}


struct_predicate ref$closure$0_107$3$16510859290061661556(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_107$3$16510859290061661556(self.val_ref), write)) && (true))
}


struct_predicate closure$0_110$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_110$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_110$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_109$3$5412928828267228331(self){
  true
}


struct_predicate ref$closure$0_109$3$5412928828267228331(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_109$3$5412928828267228331(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_108$3$12351797966212270264(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_108$3$12351797966212270264(self.val_ref), write)) && (true))
}


struct_predicate closure$0_111$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_111$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_111$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_112$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_112$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_112$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_113$3$634645340582930069(self){
  true
}


struct_predicate ref$closure$0_113$3$634645340582930069(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_113$3$634645340582930069(self.val_ref), write)) && (true))
}


struct_predicate closure$0_76$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_76$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_76$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_79$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_79$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_79$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_78$3$15621218911021980997(self){
  true
}


struct_predicate ref$closure$0_78$3$15621218911021980997(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_78$3$15621218911021980997(self.val_ref), write)) && (true))
}


struct_predicate closure$0_80$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_80$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_80$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_81$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_81$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_81$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_82$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_82$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_82$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_83$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_83$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_83$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_84$3$16510859290061661556(self){
  true
}


struct_predicate ref$closure$0_84$3$16510859290061661556(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_84$3$16510859290061661556(self.val_ref), write)) && (true))
}


struct_predicate closure$0_87$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_87$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_87$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_86$3$5412928828267228331(self){
  true
}


struct_predicate ref$closure$0_86$3$5412928828267228331(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_86$3$5412928828267228331(self.val_ref), write)) && (true))
}


struct_predicate closure$0_88$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_88$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_88$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_89$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_89$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_89$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_90$3$634645340582930069(self){
  true
}


struct_predicate ref$closure$0_90$3$634645340582930069(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_90$3$634645340582930069(self.val_ref), write)) && (true))
}


method m_shl(2 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    __t21: Bool
    _preserve$0: Ref(AuxRef)
    __t22: Bool
    __t23: Bool
    __t24: Bool
    __t25: Bool
    _old$l15$0: Ref(bool)
    __t26: Bool
    __t27: Bool
    __t28: Bool
    _old$pre$0: Ref(m_BoolArr32$_beg_$_end_)
    _1: Ref(ref$m_BoolArr32$_beg_$_end_)
    _2: Ref(usize)
    _3: Ref(m_BoolArr32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_92$3$13114848456984105119)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_95$3$3859392265678673261)
    _16: Ref(ref$usize)
    _17: Ref(ref$usize)
    _18: Ref(tuple0$)
    _19: Ref(bool)
    _20: Ref(closure$0_99$3$2536757696045608690)
    _21: Ref(ref$usize)
    _22: Ref(ref$usize)
    _23: Ref(ref$m_BoolArr32$_beg_$_end_)
    _24: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _25: Ref(tuple0$)
    _26: Ref(bool)
    _27: Ref(closure$0_108$3$12351797966212270264)
    _28: Ref(ref$usize)
    _29: Ref(ref$m_BoolArr32$_beg_$_end_)
    _30: Ref(bool)
    _31: Ref(ref$m_BoolArr32$_beg_$_end_)
    _32: Ref(usize)
    _33: Ref(usize)
    _34: Ref(usize)
    _35: Ref(tuple2$usize$bool)
    _36: Ref(ref$bool)
    _37: Ref(ref$m_BoolArr32$_beg_$_end_)
    _38: Ref(usize)
    _39: Ref(tuple2$usize$bool)
    _40: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#0}::shl"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:236:5: 266:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    __t16 := copy false
    __t17 := copy false
    __t18 := copy false
    __t19 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_1.val_ref), read)) && ((acc(usize(_2), write)) && (true)))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_1)) && ((usize$inv<Ref(usize),Bool>(_2)) && (true))
    inhale(Expr) ((0) <= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l23
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BoolArr32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_6fc8cfa62033420090e69f867e787a16_101: Int  :: ((((0) <= (_2_forall_6fc8cfa62033420090e69f867e787a16_101)) && (((_2_forall_6fc8cfa62033420090e69f867e787a16_101) < (32)) && (true))) && ((((old[pre]((unfolding acc(usize:None(_2), write) in _2.val_int))) <= (_2_forall_6fc8cfa62033420090e69f867e787a16_101)) && (((!(false))?(((_2_forall_6fc8cfa62033420090e69f867e787a16_101) - (old[pre]((unfolding acc(usize:None(_2), write) in _2.val_int)))) >= (0)):(false)) && (((!(false))?(((_2_forall_6fc8cfa62033420090e69f867e787a16_101) - (old[pre]((unfolding acc(usize:None(_2), write) in _2.val_int)))) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_6fc8cfa62033420090e69f867e787a16_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$0, (_2_forall_6fc8cfa62033420090e69f867e787a16_101) - (old[pre]((unfolding acc(usize:None(_2), write) in _2.val_int)))))):(false))) && ((forall _2_forall_eb699bd163134657a845fdab605d9b52_101: Int  :: (((0) <= (_2_forall_eb699bd163134657a845fdab605d9b52_101)) && (((_2_forall_eb699bd163134657a845fdab605d9b52_101) < (old[pre]((unfolding acc(usize:None(_2), write) in _2.val_int)))) && (((_2_forall_eb699bd163134657a845fdab605d9b52_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_eb699bd163134657a845fdab605d9b52_101)))) && (true))
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BoolArr32$_beg_$_end_(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BoolArr32::zero() -> [return: bb1, unwind: bb25]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101: Int  :: (((0) <= (_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)) && (((_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = _2
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    unfold acc(usize:None(_2), write)
    _4.val_int := copy _2.val_int
    label l2
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb24]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l3
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t20 := copy _7.val_bool
    GotoSwitch([(Local(__t20: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l4 // 7
    // ========== l4 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:33)
  label l5 // 8
    // ========== l5 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t21 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    fold acc(usize:None(_2), write)
    obtain acc(usize(_2), read)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && (((((unfolding acc(usize:None(_2), write) in _2.val_int)) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && ((forall _2_forall_82b69defbea14d588fa5d817ac980abe_101: Int  :: ((((0) <= (_2_forall_82b69defbea14d588fa5d817ac980abe_101)) && (((_2_forall_82b69defbea14d588fa5d817ac980abe_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (((_2_forall_82b69defbea14d588fa5d817ac980abe_101) >= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (true)))) && (((((unfolding acc(usize:None(_2), write) in _2.val_int)) <= (_2_forall_82b69defbea14d588fa5d817ac980abe_101)) && (((!(false))?(((_2_forall_82b69defbea14d588fa5d817ac980abe_101) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?(((_2_forall_82b69defbea14d588fa5d817ac980abe_101) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_82b69defbea14d588fa5d817ac980abe_101)) == ((unfolding acc(usize:None(_2), write) in m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, (_2_forall_82b69defbea14d588fa5d817ac980abe_101) - (_2.val_int))))):(false))) && ((forall _2_forall_dbb1f07c505c467c94b331d686ce7ac5_101: Int  :: (((0) <= (_2_forall_dbb1f07c505c467c94b331d686ce7ac5_101)) && (((_2_forall_dbb1f07c505c467c94b331d686ce7ac5_101) < ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (((_2_forall_dbb1f07c505c467c94b331d686ce7ac5_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_dbb1f07c505c467c94b331d686ce7ac5_101)))) && (true))))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    __t22 := builtin$havoc_bool()
    _10 := builtin$havoc_ref()
    _39 := builtin$havoc_ref()
    _30 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    _35 := builtin$havoc_ref()
    __t13 := builtin$havoc_bool()
    __t7 := builtin$havoc_bool()
    __t15 := builtin$havoc_bool()
    __t12 := builtin$havoc_bool()
    _14 := builtin$havoc_ref()
    __t14 := builtin$havoc_bool()
    _36 := builtin$havoc_ref()
    __t24 := builtin$havoc_bool()
    _31 := builtin$havoc_ref()
    __t16 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    _37 := builtin$havoc_ref()
    __t2 := builtin$havoc_bool()
    _34 := builtin$havoc_ref()
    _4 := builtin$havoc_ref()
    __t28 := builtin$havoc_bool()
    _38 := builtin$havoc_ref()
    _7 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    __t26 := builtin$havoc_bool()
    __t4 := builtin$havoc_bool()
    __t3 := builtin$havoc_bool()
    _26 := builtin$havoc_ref()
    _33 := builtin$havoc_ref()
    _19 := builtin$havoc_ref()
    __t23 := builtin$havoc_bool()
    __t27 := builtin$havoc_bool()
    __t6 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    __t25 := builtin$havoc_bool()
    _32 := builtin$havoc_ref()
    _8 := builtin$havoc_ref()
    __t17 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    inhale(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && (((((unfolding acc(usize:None(_2), write) in _2.val_int)) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && ((forall _2_forall_82b69defbea14d588fa5d817ac980abe_101: Int  :: ((((0) <= (_2_forall_82b69defbea14d588fa5d817ac980abe_101)) && (((_2_forall_82b69defbea14d588fa5d817ac980abe_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (((_2_forall_82b69defbea14d588fa5d817ac980abe_101) >= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (true)))) && (((((unfolding acc(usize:None(_2), write) in _2.val_int)) <= (_2_forall_82b69defbea14d588fa5d817ac980abe_101)) && (((!(false))?(((_2_forall_82b69defbea14d588fa5d817ac980abe_101) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?(((_2_forall_82b69defbea14d588fa5d817ac980abe_101) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_82b69defbea14d588fa5d817ac980abe_101)) == ((unfolding acc(usize:None(_2), write) in m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, (_2_forall_82b69defbea14d588fa5d817ac980abe_101) - (_2.val_int))))):(false))) && ((forall _2_forall_dbb1f07c505c467c94b331d686ce7ac5_101: Int  :: (((0) <= (_2_forall_dbb1f07c505c467c94b331d686ce7ac5_101)) && (((_2_forall_dbb1f07c505c467c94b331d686ce7ac5_101) < ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (((_2_forall_dbb1f07c505c467c94b331d686ce7ac5_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_dbb1f07c505c467c94b331d686ce7ac5_101)))) && (true))))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t22 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_18)
    // [mir] StorageLive(_19)
    // [mir] _19 = const false
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_bool, write)
    _19.val_bool := copy false
    // [mir] switchInt(move _19) -> [false: bb14, otherwise: bb13]
    __t23 := copy _19.val_bool
    // Ignore default target bb13, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:17)
  label loop2_group3_bb14 // 17
    // ========== loop2_group3_bb14 ==========
    __t10 := copy true
    // [mir] _18 = const ()
    // [mir] goto -> bb15
    Goto(cfg:18)
  label loop2_group3_bb15 // 18
    // ========== loop2_group3_bb15 ==========
    __t11 := copy true
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_18)
    // [mir] StorageLive(_25)
    // [mir] StorageLive(_26)
    // [mir] _26 = const false
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.val_bool, write)
    _26.val_bool := copy false
    // [mir] switchInt(move _26) -> [false: bb17, otherwise: bb16]
    __t24 := copy _26.val_bool
    // Ignore default target bb16, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:19)
  label loop2_group3_bb17 // 19
    // ========== loop2_group3_bb17 ==========
    __t12 := copy true
    // [mir] _25 = const ()
    // [mir] goto -> bb18
    Goto(cfg:20)
  label loop2_group3_bb18 // 20
    // ========== loop2_group3_bb18 ==========
    __t13 := copy true
    // [mir] StorageDead(_26)
    // [mir] StorageDead(_25)
    // [mir] StorageLive(_30)
    // [mir] StorageLive(_31)
    // [mir] _31 = &'_ (*_1)
    _31 := builtin$havoc_ref()
    inhale(Stmt) acc(_31.val_ref, write)
    _31.val_ref := borrow _1.val_ref // L13
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_31.val_ref), read)
    label l6
    // [mir] StorageLive(_32)
    // [mir] StorageLive(_33)
    // [mir] _33 = _4
    _33 := builtin$havoc_ref()
    inhale(Stmt) acc(_33.val_int, write)
    unfold acc(usize:None(_4), write)
    _33.val_int := copy _4.val_int
    label l7
    // [mir] StorageLive(_34)
    // [mir] _34 = _2
    _34 := builtin$havoc_ref()
    inhale(Stmt) acc(_34.val_int, write)
    unfold acc(usize:None(_2), write)
    _34.val_int := copy _2.val_int
    label l8
    // [mir] _35 = CheckedSub(_33, _34)
    _35 := builtin$havoc_ref()
    inhale(Stmt) acc(_35.tuple_0, write)
    inhale(Stmt) acc(_35.tuple_0.val_int, write)
    inhale(Stmt) acc(_35.tuple_1, write)
    inhale(Stmt) acc(_35.tuple_1.val_bool, write)
    _35.tuple_0.val_int := copy (_33.val_int) - (_34.val_int)
    _35.tuple_1.val_bool := copy false
    // [mir] assert(!move (_35.1: bool), "attempt to compute `{} - {}`, which would overflow", move _33, move _34) -> [success: bb19, unwind: bb24]
    __t25 := copy _35.tuple_1.val_bool
    // Rust assertion: attempt to subtract with overflow
    assert(Stmt) !(__t25)
    Goto(cfg:21)
  label loop2_group3_bb19 // 21
    // ========== loop2_group3_bb19 ==========
    __t14 := copy true
    // [mir] _32 = move (_35.0: usize)
    _32 := move _35.tuple_0
    label l9
    // [mir] StorageDead(_34)
    // [mir] StorageDead(_33)
    // [mir] _30 = BoolArr32::lookup(move _31, move _32) -> [return: bb20, unwind: bb24]
    label l10
    _30 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_30), write)
    unfold acc(bool:None(_30), write)
    inhale(Stmt) (_30.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_31.val_ref, _32.val_int))
    transfer perm _31.val_ref --> old[l10](_31.val_ref) // unchecked: false
    Goto(cfg:22)
  label l11 // 22
    // ========== l11 ==========
    // MIR edge bb19 --> bb20
    // Expire borrows
    // expire_borrows ReborrowingDAG(L14,L13,)

    if (__t14) && (true) {
    // expire loan L14
} else {}
    if (__t13) && ((__t14) && (true)) {
    // expire loan L13
    transfer perm old[l10](_31.val_ref) --> old[l6](_31.val_ref) // unchecked: false
    exhale acc(m_BoolArr32$_beg_$_end_(old[l6](_31.val_ref)), read)
} else {}
    Goto(cfg:23)
  label loop2_group3_bb20 // 23
    // ========== loop2_group3_bb20 ==========
    __t15 := copy true
    // [mir] StorageDead(_32)
    // [mir] StorageDead(_31)
    // [mir] StorageLive(_36)
    // [mir] StorageLive(_37)
    // [mir] _37 = &'_ mut _3
    _37 := builtin$havoc_ref()
    inhale(Stmt) acc(_37.val_ref, write)
    _37.val_ref := mut borrow _3 // L9
    label l12
    // [mir] StorageLive(_38)
    // [mir] _38 = _4
    _38 := builtin$havoc_ref()
    inhale(Stmt) acc(_38.val_int, write)
    _38.val_int := copy _4.val_int
    label l13
    // [mir] _36 = BoolArr32::index_mut(move _37, move _38) -> [return: bb21, unwind: bb24]
    label l14
    assert(Stmt) (((0) <= (_38.val_int)) && (((_38.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_37.val_ref))) && (true))) && (true)
    fold acc(usize:None(_38), write)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_37)) && ((usize$inv<Ref(usize),Bool>(_38)) && (true))
    exhale (acc(_37.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_37.val_ref), write)) && ((acc(usize(_38), write)) && (true)))
    _36 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_36.val_ref, write)) && (acc(bool(_36.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_36)) && (true)
    inhale(Expr) (((unfolding acc(bool:None(_36.val_ref), write) in _36.val_ref.val_bool)) == (old[l14](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_37.val_ref, _38.val_int)))) && (true)
    exhale true
    label l15
    Goto(cfg:24)
  label loop2_group3_bb21 // 24
    // ========== loop2_group3_bb21 ==========
    __t16 := copy true
    // [mir] StorageDead(_38)
    // [mir] StorageDead(_37)
    // [mir] (*_36) = move _30
    _36.val_ref := move _30
    label l16
    // expire_borrows ReborrowingDAG(L15,L16,L9,)

    if (__t15) && (true) {
    // expire loan L15
    _old$l15$0 := move _36.val_ref
    inhale(Stmt) (((acc(bool(_old$l15$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l15$0))) && ((true) && (true))) Some(L15) --* (((acc(m_BoolArr32$_beg_$_end_(old[l14](_37.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l14](_37.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_37.val_ref))) == (old[l14](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_37.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_37.val_ref), old[l14](_38.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l15$0), write) in _old$l15$0.val_bool)))) && ((forall _2_forall_5be58431c8f94233ac0b32ea01095bd7_103: Int  :: (((0) <= (_2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) && (((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_37.val_ref)))) && ((!((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) == (old[l14](_38.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_37.val_ref), _2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) == (old[l14](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_37.val_ref, _2_forall_5be58431c8f94233ac0b32ea01095bd7_103))))) && (true)))) && (true)))
    fold acc(bool:None(_old$l15$0), write)
    apply[L15] ((acc(bool(_old$l15$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l15$0))) && ((true) && (true)) --* ((acc(m_BoolArr32$_beg_$_end_(old[l14](_37.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l14](_37.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_37.val_ref))) == (old[l14](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_37.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_37.val_ref), old[l14](_38.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l15$0), write) in _old$l15$0.val_bool)))) && ((forall _2_forall_5be58431c8f94233ac0b32ea01095bd7_103: Int  :: (((0) <= (_2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) && (((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_37.val_ref)))) && ((!((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) == (old[l14](_38.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_37.val_ref), _2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) == (old[l14](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_37.val_ref, _2_forall_5be58431c8f94233ac0b32ea01095bd7_103))))) && (true)))) && (true))
    
} else {}
    if (__t15) && ((__t15) && (true)) {
    // expire loan L16
} else {}
    if (__t15) && ((__t15) && ((__t15) && (true))) {
    // expire loan L9
    transfer perm old[l14](_37.val_ref) --> old[l12](_37.val_ref) // unchecked: false
    transfer perm old[l12](_37.val_ref) --> _3 // unchecked: false
} else {}
    // [mir] StorageDead(_30)
    // [mir] StorageDead(_36)
    // [mir] _39 = CheckedAdd(_4, const 1_usize)
    _39 := builtin$havoc_ref()
    inhale(Stmt) acc(_39.tuple_0, write)
    inhale(Stmt) acc(_39.tuple_0.val_int, write)
    inhale(Stmt) acc(_39.tuple_1, write)
    inhale(Stmt) acc(_39.tuple_1.val_bool, write)
    _39.tuple_0.val_int := copy (_4.val_int) + (1)
    _39.tuple_1.val_bool := copy false
    // [mir] assert(!move (_39.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb22, unwind: bb24]
    __t26 := copy _39.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t26)
    Goto(cfg:25)
  label loop2_group3_bb22 // 25
    // ========== loop2_group3_bb22 ==========
    __t17 := copy true
    // [mir] _4 = move (_39.0: usize)
    _4 := move _39.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:26)
  label loop2_group4_bb2 // 26
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb24]
    Goto(cfg:27)
  label loop2_group4_bb3 // 27
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l18
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t27 := copy _7.val_bool
    GotoSwitch([(Local(__t27: Bool, Position { line: 0, column: 0, id: 0 }), cfg:29)], cfg:28)
  label l19 // 28
    // ========== l19 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:35)
  label l20 // 29
    // ========== l20 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:30)
  label loop2_group5_bb4 // 30
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:31)
  label loop2_group5_bb6 // 31
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t28 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:32)
  label loop2_end_body // 32
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    fold acc(usize:None(_2), write)
    obtain acc(usize(_2), read)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && (((((unfolding acc(usize:None(_2), write) in _2.val_int)) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && ((forall _2_forall_82b69defbea14d588fa5d817ac980abe_101: Int  :: ((((0) <= (_2_forall_82b69defbea14d588fa5d817ac980abe_101)) && (((_2_forall_82b69defbea14d588fa5d817ac980abe_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (((_2_forall_82b69defbea14d588fa5d817ac980abe_101) >= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (true)))) && (((((unfolding acc(usize:None(_2), write) in _2.val_int)) <= (_2_forall_82b69defbea14d588fa5d817ac980abe_101)) && (((!(false))?(((_2_forall_82b69defbea14d588fa5d817ac980abe_101) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?(((_2_forall_82b69defbea14d588fa5d817ac980abe_101) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_82b69defbea14d588fa5d817ac980abe_101)) == ((unfolding acc(usize:None(_2), write) in m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, (_2_forall_82b69defbea14d588fa5d817ac980abe_101) - (_2.val_int))))):(false))) && ((forall _2_forall_dbb1f07c505c467c94b331d686ce7ac5_101: Int  :: (((0) <= (_2_forall_dbb1f07c505c467c94b331d686ce7ac5_101)) && (((_2_forall_dbb1f07c505c467c94b331d686ce7ac5_101) < ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (((_2_forall_dbb1f07c505c467c94b331d686ce7ac5_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_dbb1f07c505c467c94b331d686ce7ac5_101)))) && (true))))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 33
    // ========== bb5 ==========
    __t18 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l21
    // [mir] StorageDead(_4)
    // [mir] drop(_3) -> [return: bb23, unwind: bb25]
    Goto(cfg:34)
  label bb23 // 34
    // ========== bb23 ==========
    __t19 := copy true
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l22 // 35
    // ========== l22 ==========
    // drop Acc(_36.val_ref, write) (Acc(_36.val_ref, write))
    // drop Acc(old[l6](_31.val_ref), write) (Acc(old[l6](_31.val_ref), write))
    // drop Acc(_39.tuple_0, write) (Acc(_39.tuple_0, write))
    // drop Acc(_35.tuple_0, write) (Acc(_35.tuple_0, write))
    // drop Acc(_34.val_int, write) (Acc(_34.val_int, write))
    // drop Acc(_14.val_bool, write) (Acc(_14.val_bool, write))
    // drop Acc(_33.val_int, write) (Acc(_33.val_int, write))
    // drop Acc(_26.val_bool, write) (Acc(_26.val_bool, write))
    // drop Acc(_35.tuple_1.val_bool, write) (Acc(_35.tuple_1.val_bool, write))
    // drop Acc(_19.val_bool, write) (Acc(_19.val_bool, write))
    // drop Acc(_31.val_ref, write) (Acc(_31.val_ref, write))
    // drop Acc(_32.val_int, write) (Acc(_32.val_int, write))
    // drop Acc(_39.tuple_1.val_bool, write) (Acc(_39.tuple_1.val_bool, write))
    // drop Acc(_39.tuple_1, write) (Acc(_39.tuple_1, write))
    // drop Acc(_35.tuple_1, write) (Acc(_35.tuple_1, write))
    Goto(cfg:33)
  label end_of_method
}


struct_predicate closure$0_123$3$13114848456984105119(self){
  true
}


struct_predicate closure$0_126$3$3859392265678673261(self){
  true
}


struct_predicate closure$0_130$3$12351797966212270264(self){
  true
}


struct_predicate closure$0_124$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_124$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_124$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_123$3$13114848456984105119(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_123$3$13114848456984105119(self.val_ref), write)) && (true))
}


struct_predicate closure$0_125$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_125$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_125$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_127$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_127$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_127$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_126$3$3859392265678673261(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_126$3$3859392265678673261(self.val_ref), write)) && (true))
}


struct_predicate closure$0_128$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_128$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_128$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_129$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_129$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_129$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_132$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_132$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_132$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_131$3$5412928828267228331(self){
  true
}


struct_predicate ref$closure$0_131$3$5412928828267228331(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_131$3$5412928828267228331(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_130$3$12351797966212270264(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_130$3$12351797966212270264(self.val_ref), write)) && (true))
}


struct_predicate closure$0_133$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_133$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_133$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_134$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_134$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_134$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_135$3$634645340582930069(self){
  true
}


struct_predicate ref$closure$0_135$3$634645340582930069(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_135$3$634645340582930069(self.val_ref), write)) && (true))
}


struct_predicate closure$0_115$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_115$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_115$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_118$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_118$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_118$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_117$3$5412928828267228331(self){
  true
}


struct_predicate ref$closure$0_117$3$5412928828267228331(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_117$3$5412928828267228331(self.val_ref), write)) && (true))
}


struct_predicate closure$0_119$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_119$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_119$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_120$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_120$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_120$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_121$3$634645340582930069(self){
  true
}


struct_predicate ref$closure$0_121$3$634645340582930069(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_121$3$634645340582930069(self.val_ref), write)) && (true))
}


method m_shr(2 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    __t18: Bool
    __t19: Bool
    _preserve$0: Ref(AuxRef)
    __t20: Bool
    __t21: Bool
    __t22: Bool
    _old$l15$0: Ref(bool)
    __t23: Bool
    __t24: Bool
    __t25: Bool
    _old$pre$0: Ref(m_BoolArr32$_beg_$_end_)
    _1: Ref(ref$m_BoolArr32$_beg_$_end_)
    _2: Ref(usize)
    _3: Ref(m_BoolArr32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_123$3$13114848456984105119)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_126$3$3859392265678673261)
    _16: Ref(ref$usize)
    _17: Ref(ref$usize)
    _18: Ref(tuple0$)
    _19: Ref(bool)
    _20: Ref(closure$0_130$3$12351797966212270264)
    _21: Ref(ref$usize)
    _22: Ref(ref$m_BoolArr32$_beg_$_end_)
    _23: Ref(bool)
    _24: Ref(ref$m_BoolArr32$_beg_$_end_)
    _25: Ref(usize)
    _26: Ref(ref$bool)
    _27: Ref(ref$m_BoolArr32$_beg_$_end_)
    _28: Ref(usize)
    _29: Ref(usize)
    _30: Ref(usize)
    _31: Ref(tuple2$usize$bool)
    _32: Ref(tuple2$usize$bool)
    _33: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#0}::shr"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:284:5: 317:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    __t16 := copy false
    __t17 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_1.val_ref), read)) && ((acc(usize(_2), write)) && (true)))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_1)) && ((usize$inv<Ref(usize),Bool>(_2)) && (true))
    inhale(Expr) ((0) <= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l23
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BoolArr32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_9061e768819d46e1a5959b481ddd9804_101: Int  :: (((0) <= (_2_forall_9061e768819d46e1a5959b481ddd9804_101)) && (((!(false))?((_2_forall_9061e768819d46e1a5959b481ddd9804_101) > ((32) - (old[pre]((unfolding acc(usize:None(_2), write) in _2.val_int))))):(false)) && (((_2_forall_9061e768819d46e1a5959b481ddd9804_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_9061e768819d46e1a5959b481ddd9804_101)))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BoolArr32$_beg_$_end_(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BoolArr32::zero() -> [return: bb1, unwind: bb22]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101: Int  :: (((0) <= (_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)) && (((_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = _2
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    unfold acc(usize:None(_2), write)
    _4.val_int := copy _2.val_int
    label l2
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb21]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l3
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t18 := copy _7.val_bool
    GotoSwitch([(Local(__t18: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l4 // 7
    // ========== l4 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l5 // 8
    // ========== l5 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t19 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    fold acc(usize:None(_2), write)
    obtain acc(usize(_2), read)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && (((((unfolding acc(usize:None(_4), write) in _4.val_int)) >= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && ((forall _2_forall_3a96b4c5fd354600a880df6bda7c9430_101: Int  :: (((0) <= (_2_forall_3a96b4c5fd354600a880df6bda7c9430_101)) && (((!(false))?((_2_forall_3a96b4c5fd354600a880df6bda7c9430_101) > ((32) - ((unfolding acc(usize:None(_2), write) in _2.val_int)))):(false)) && (((_2_forall_3a96b4c5fd354600a880df6bda7c9430_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_3a96b4c5fd354600a880df6bda7c9430_101)))) && (true)))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    _7 := builtin$havoc_ref()
    __t12 := builtin$havoc_bool()
    _25 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    __t21 := builtin$havoc_bool()
    __t24 := builtin$havoc_bool()
    __t6 := builtin$havoc_bool()
    __t15 := builtin$havoc_bool()
    __t23 := builtin$havoc_bool()
    __t14 := builtin$havoc_bool()
    _31 := builtin$havoc_ref()
    __t11 := builtin$havoc_bool()
    _23 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    _24 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    _26 := builtin$havoc_ref()
    _4 := builtin$havoc_ref()
    _10 := builtin$havoc_ref()
    _14 := builtin$havoc_ref()
    __t9 := builtin$havoc_bool()
    __t2 := builtin$havoc_bool()
    _28 := builtin$havoc_ref()
    _19 := builtin$havoc_ref()
    __t13 := builtin$havoc_bool()
    __t25 := builtin$havoc_bool()
    _29 := builtin$havoc_ref()
    _32 := builtin$havoc_ref()
    __t20 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    __t3 := builtin$havoc_bool()
    _30 := builtin$havoc_ref()
    _27 := builtin$havoc_ref()
    _8 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    __t22 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    inhale(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && (((((unfolding acc(usize:None(_4), write) in _4.val_int)) >= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && ((forall _2_forall_3a96b4c5fd354600a880df6bda7c9430_101: Int  :: (((0) <= (_2_forall_3a96b4c5fd354600a880df6bda7c9430_101)) && (((!(false))?((_2_forall_3a96b4c5fd354600a880df6bda7c9430_101) > ((32) - ((unfolding acc(usize:None(_2), write) in _2.val_int)))):(false)) && (((_2_forall_3a96b4c5fd354600a880df6bda7c9430_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_3a96b4c5fd354600a880df6bda7c9430_101)))) && (true)))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t20 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_18)
    // [mir] StorageLive(_19)
    // [mir] _19 = const false
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_bool, write)
    _19.val_bool := copy false
    // [mir] switchInt(move _19) -> [false: bb14, otherwise: bb13]
    __t21 := copy _19.val_bool
    // Ignore default target bb13, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:17)
  label loop2_group3_bb14 // 17
    // ========== loop2_group3_bb14 ==========
    __t10 := copy true
    // [mir] _18 = const ()
    // [mir] goto -> bb15
    Goto(cfg:18)
  label loop2_group3_bb15 // 18
    // ========== loop2_group3_bb15 ==========
    __t11 := copy true
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_18)
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] _24 = &'_ (*_1)
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(_24.val_ref, write)
    _24.val_ref := borrow _1.val_ref // L11
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_24.val_ref), read)
    label l6
    // [mir] StorageLive(_25)
    // [mir] _25 = _4
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_int, write)
    unfold acc(usize:None(_4), write)
    _25.val_int := copy _4.val_int
    label l7
    // [mir] _23 = BoolArr32::lookup(move _24, move _25) -> [return: bb16, unwind: bb21]
    label l8
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_23), write)
    unfold acc(bool:None(_23), write)
    inhale(Stmt) (_23.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _25.val_int))
    transfer perm _24.val_ref --> old[l8](_24.val_ref) // unchecked: false
    Goto(cfg:19)
  label l9 // 19
    // ========== l9 ==========
    // MIR edge bb15 --> bb16
    // Expire borrows
    // expire_borrows ReborrowingDAG(L12,L11,)

    if (__t11) && (true) {
    // expire loan L12
} else {}
    if (__t11) && ((__t11) && (true)) {
    // expire loan L11
    transfer perm old[l8](_24.val_ref) --> old[l6](_24.val_ref) // unchecked: false
    exhale acc(m_BoolArr32$_beg_$_end_(old[l6](_24.val_ref)), read)
} else {}
    Goto(cfg:20)
  label loop2_group3_bb16 // 20
    // ========== loop2_group3_bb16 ==========
    __t12 := copy true
    // [mir] StorageDead(_25)
    // [mir] StorageDead(_24)
    // [mir] StorageLive(_26)
    // [mir] StorageLive(_27)
    // [mir] _27 = &'_ mut _3
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(_27.val_ref, write)
    _27.val_ref := mut borrow _3 // L5
    label l10
    // [mir] StorageLive(_28)
    // [mir] StorageLive(_29)
    // [mir] _29 = _4
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.val_int, write)
    _29.val_int := copy _4.val_int
    label l11
    // [mir] StorageLive(_30)
    // [mir] _30 = _2
    _30 := builtin$havoc_ref()
    inhale(Stmt) acc(_30.val_int, write)
    unfold acc(usize:None(_2), write)
    _30.val_int := copy _2.val_int
    label l12
    // [mir] _31 = CheckedSub(_29, _30)
    _31 := builtin$havoc_ref()
    inhale(Stmt) acc(_31.tuple_0, write)
    inhale(Stmt) acc(_31.tuple_0.val_int, write)
    inhale(Stmt) acc(_31.tuple_1, write)
    inhale(Stmt) acc(_31.tuple_1.val_bool, write)
    _31.tuple_0.val_int := copy (_29.val_int) - (_30.val_int)
    _31.tuple_1.val_bool := copy false
    // [mir] assert(!move (_31.1: bool), "attempt to compute `{} - {}`, which would overflow", move _29, move _30) -> [success: bb17, unwind: bb21]
    __t22 := copy _31.tuple_1.val_bool
    // Rust assertion: attempt to subtract with overflow
    assert(Stmt) !(__t22)
    Goto(cfg:21)
  label loop2_group3_bb17 // 21
    // ========== loop2_group3_bb17 ==========
    __t13 := copy true
    // [mir] _28 = move (_31.0: usize)
    _28 := move _31.tuple_0
    label l13
    // [mir] StorageDead(_30)
    // [mir] StorageDead(_29)
    // [mir] _26 = BoolArr32::index_mut(move _27, move _28) -> [return: bb18, unwind: bb21]
    label l14
    assert(Stmt) (((0) <= (_28.val_int)) && (((_28.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref))) && (true))) && (true)
    fold acc(usize:None(_28), write)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_27)) && ((usize$inv<Ref(usize),Bool>(_28)) && (true))
    exhale (acc(_27.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_27.val_ref), write)) && ((acc(usize(_28), write)) && (true)))
    _26 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_26.val_ref, write)) && (acc(bool(_26.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_26)) && (true)
    inhale(Expr) (((unfolding acc(bool:None(_26.val_ref), write) in _26.val_ref.val_bool)) == (old[l14](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _28.val_int)))) && (true)
    exhale true
    label l15
    Goto(cfg:22)
  label loop2_group3_bb18 // 22
    // ========== loop2_group3_bb18 ==========
    __t14 := copy true
    // [mir] StorageDead(_28)
    // [mir] StorageDead(_27)
    // [mir] (*_26) = move _23
    _26.val_ref := move _23
    label l16
    // expire_borrows ReborrowingDAG(L9,L10,L5,)

    if (__t13) && (true) {
    // expire loan L9
    _old$l15$0 := move _26.val_ref
    inhale(Stmt) (((acc(bool(_old$l15$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l15$0))) && ((true) && (true))) Some(L9) --* (((acc(m_BoolArr32$_beg_$_end_(old[l14](_27.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l14](_27.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_27.val_ref))) == (old[l14](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_27.val_ref), old[l14](_28.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l15$0), write) in _old$l15$0.val_bool)))) && ((forall _2_forall_5be58431c8f94233ac0b32ea01095bd7_103: Int  :: (((0) <= (_2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) && (((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_27.val_ref)))) && ((!((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) == (old[l14](_28.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_27.val_ref), _2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) == (old[l14](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _2_forall_5be58431c8f94233ac0b32ea01095bd7_103))))) && (true)))) && (true)))
    fold acc(bool:None(_old$l15$0), write)
    apply[L9] ((acc(bool(_old$l15$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l15$0))) && ((true) && (true)) --* ((acc(m_BoolArr32$_beg_$_end_(old[l14](_27.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l14](_27.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_27.val_ref))) == (old[l14](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_27.val_ref), old[l14](_28.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l15$0), write) in _old$l15$0.val_bool)))) && ((forall _2_forall_5be58431c8f94233ac0b32ea01095bd7_103: Int  :: (((0) <= (_2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) && (((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_27.val_ref)))) && ((!((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) == (old[l14](_28.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_27.val_ref), _2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) == (old[l14](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _2_forall_5be58431c8f94233ac0b32ea01095bd7_103))))) && (true)))) && (true))
    
} else {}
    if (__t13) && ((__t13) && (true)) {
    // expire loan L10
} else {}
    if (__t12) && ((__t13) && ((__t13) && (true))) {
    // expire loan L5
    transfer perm old[l14](_27.val_ref) --> old[l10](_27.val_ref) // unchecked: false
    transfer perm old[l10](_27.val_ref) --> _3 // unchecked: false
} else {}
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_26)
    // [mir] _32 = CheckedAdd(_4, const 1_usize)
    _32 := builtin$havoc_ref()
    inhale(Stmt) acc(_32.tuple_0, write)
    inhale(Stmt) acc(_32.tuple_0.val_int, write)
    inhale(Stmt) acc(_32.tuple_1, write)
    inhale(Stmt) acc(_32.tuple_1.val_bool, write)
    _32.tuple_0.val_int := copy (_4.val_int) + (1)
    _32.tuple_1.val_bool := copy false
    // [mir] assert(!move (_32.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb19, unwind: bb21]
    __t23 := copy _32.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t23)
    Goto(cfg:23)
  label loop2_group3_bb19 // 23
    // ========== loop2_group3_bb19 ==========
    __t15 := copy true
    // [mir] _4 = move (_32.0: usize)
    _4 := move _32.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:24)
  label loop2_group4_bb2 // 24
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb21]
    Goto(cfg:25)
  label loop2_group4_bb3 // 25
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l18
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t24 := copy _7.val_bool
    GotoSwitch([(Local(__t24: Bool, Position { line: 0, column: 0, id: 0 }), cfg:27)], cfg:26)
  label l19 // 26
    // ========== l19 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:33)
  label l20 // 27
    // ========== l20 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:28)
  label loop2_group5_bb4 // 28
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:29)
  label loop2_group5_bb6 // 29
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t25 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:30)
  label loop2_end_body // 30
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    fold acc(usize:None(_2), write)
    obtain acc(usize(_2), read)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && (((((unfolding acc(usize:None(_4), write) in _4.val_int)) >= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && ((forall _2_forall_3a96b4c5fd354600a880df6bda7c9430_101: Int  :: (((0) <= (_2_forall_3a96b4c5fd354600a880df6bda7c9430_101)) && (((!(false))?((_2_forall_3a96b4c5fd354600a880df6bda7c9430_101) > ((32) - ((unfolding acc(usize:None(_2), write) in _2.val_int)))):(false)) && (((_2_forall_3a96b4c5fd354600a880df6bda7c9430_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_3a96b4c5fd354600a880df6bda7c9430_101)))) && (true)))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 31
    // ========== bb5 ==========
    __t16 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l21
    // [mir] StorageDead(_4)
    // [mir] drop(_3) -> [return: bb20, unwind: bb22]
    Goto(cfg:32)
  label bb20 // 32
    // ========== bb20 ==========
    __t17 := copy true
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l22 // 33
    // ========== l22 ==========
    // drop Acc(_31.tuple_0, write) (Acc(_31.tuple_0, write))
    // drop Acc(_26.val_ref, write) (Acc(_26.val_ref, write))
    // drop Acc(_29.val_int, write) (Acc(_29.val_int, write))
    // drop Acc(_30.val_int, write) (Acc(_30.val_int, write))
    // drop Acc(_31.tuple_1.val_bool, write) (Acc(_31.tuple_1.val_bool, write))
    // drop Acc(_24.val_ref, write) (Acc(_24.val_ref, write))
    // drop Acc(old[l6](_24.val_ref), write) (Acc(old[l6](_24.val_ref), write))
    // drop Acc(_25.val_int, write) (Acc(_25.val_int, write))
    // drop Acc(_19.val_bool, write) (Acc(_19.val_bool, write))
    // drop Acc(_14.val_bool, write) (Acc(_14.val_bool, write))
    // drop Acc(_32.tuple_0, write) (Acc(_32.tuple_0, write))
    // drop Acc(_32.tuple_1.val_bool, write) (Acc(_32.tuple_1.val_bool, write))
    // drop Acc(_32.tuple_1, write) (Acc(_32.tuple_1, write))
    // drop Acc(_31.tuple_1, write) (Acc(_31.tuple_1, write))
    Goto(cfg:31)
  label end_of_method
}


struct_predicate closure$0_145$3$5995690350403947267(self){
  true
}


struct_predicate closure$0_142$3$13114848456984105119(self){
  true
}


struct_predicate closure$0_143$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_143$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_143$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_142$3$13114848456984105119(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_142$3$13114848456984105119(self.val_ref), write)) && (true))
}


struct_predicate closure$0_144$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_144$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_144$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_147$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_147$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_147$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_146$3$12052970462978565359(self){
  true
}


struct_predicate ref$closure$0_146$3$12052970462978565359(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_146$3$12052970462978565359(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_145$3$5995690350403947267(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_145$3$5995690350403947267(self.val_ref), write)) && (true))
}


struct_predicate closure$0_148$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_148$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_148$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_149$3$3807802852492153155(self){
  true
}


struct_predicate ref$closure$0_149$3$3807802852492153155(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_149$3$3807802852492153155(self.val_ref), write)) && (true))
}


struct_predicate closure$0_138$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_138$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_138$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_137$3$17041045897492703373(self){
  true
}


struct_predicate ref$closure$0_137$3$17041045897492703373(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_137$3$17041045897492703373(self.val_ref), write)) && (true))
}


struct_predicate closure$0_139$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_139$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_139$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_140$3$3807802852492153155(self){
  true
}


struct_predicate ref$closure$0_140$3$3807802852492153155(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_140$3$3807802852492153155(self.val_ref), write)) && (true))
}


method m_or(2 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t18: Bool
    _old$l16$0: Ref(bool)
    __t19: Bool
    __t20: Bool
    __t21: Bool
    _old$pre$0: Ref(m_BoolArr32$_beg_$_end_)
    _old$pre$1: Ref(m_BoolArr32$_beg_$_end_)
    _1: Ref(ref$m_BoolArr32$_beg_$_end_)
    _2: Ref(ref$m_BoolArr32$_beg_$_end_)
    _3: Ref(m_BoolArr32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_142$3$13114848456984105119)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_145$3$5995690350403947267)
    _16: Ref(ref$usize)
    _17: Ref(ref$m_BoolArr32$_beg_$_end_)
    _18: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _19: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _20: Ref(bool)
    _21: Ref(ref$m_BoolArr32$_beg_$_end_)
    _22: Ref(usize)
    _23: Ref(bool)
    _24: Ref(ref$m_BoolArr32$_beg_$_end_)
    _25: Ref(usize)
    _26: Ref(ref$bool)
    _27: Ref(ref$m_BoolArr32$_beg_$_end_)
    _28: Ref(usize)
    _29: Ref(tuple2$usize$bool)
    _30: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#0}::or"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:324:5: 338:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_1)) && ((ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l23
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BoolArr32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BoolArr32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_0441df0c956548a09e2230baf180e174_101: Int  :: (((0) <= (_2_forall_0441df0c956548a09e2230baf180e174_101)) && (((_2_forall_0441df0c956548a09e2230baf180e174_101) < (32)) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_0441df0c956548a09e2230baf180e174_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$0, _2_forall_0441df0c956548a09e2230baf180e174_101)) || (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$1, _2_forall_0441df0c956548a09e2230baf180e174_101))))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BoolArr32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BoolArr32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BoolArr32::zero() -> [return: bb1, unwind: bb19]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101: Int  :: (((0) <= (_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)) && (((_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = const 0_usize
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy 0
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb18]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l2
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t16 := copy _7.val_bool
    GotoSwitch([(Local(__t16: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:30)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t17 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$1 := ghost _2.val_ref
    _preserve$0 := ghost _1.val_ref
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_605176880ec840179c4ee5c7355c11fa_101: Int  :: (((0) <= (_2_forall_605176880ec840179c4ee5c7355c11fa_101)) && (((_2_forall_605176880ec840179c4ee5c7355c11fa_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_605176880ec840179c4ee5c7355c11fa_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_605176880ec840179c4ee5c7355c11fa_101)) || (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_605176880ec840179c4ee5c7355c11fa_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    __t6 := builtin$havoc_bool()
    _26 := builtin$havoc_ref()
    __t21 := builtin$havoc_bool()
    _28 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    __t2 := builtin$havoc_bool()
    _4 := builtin$havoc_ref()
    __t11 := builtin$havoc_bool()
    _20 := builtin$havoc_ref()
    __t20 := builtin$havoc_bool()
    __t12 := builtin$havoc_bool()
    __t4 := builtin$havoc_bool()
    _29 := builtin$havoc_ref()
    _10 := builtin$havoc_ref()
    _25 := builtin$havoc_ref()
    __t9 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    _24 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    _7 := builtin$havoc_ref()
    __t5 := builtin$havoc_bool()
    _23 := builtin$havoc_ref()
    _14 := builtin$havoc_ref()
    _27 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    _21 := builtin$havoc_ref()
    _8 := builtin$havoc_ref()
    __t19 := builtin$havoc_bool()
    __t18 := builtin$havoc_bool()
    _22 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_605176880ec840179c4ee5c7355c11fa_101: Int  :: (((0) <= (_2_forall_605176880ec840179c4ee5c7355c11fa_101)) && (((_2_forall_605176880ec840179c4ee5c7355c11fa_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_605176880ec840179c4ee5c7355c11fa_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_605176880ec840179c4ee5c7355c11fa_101)) || (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_605176880ec840179c4ee5c7355c11fa_101))))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t18 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'_ (*_1)
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_ref, write)
    _21.val_ref := borrow _1.val_ref // L12
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_21.val_ref), read)
    label l5
    // [mir] StorageLive(_22)
    // [mir] _22 = _4
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_int, write)
    unfold acc(usize:None(_4), write)
    _22.val_int := copy _4.val_int
    label l6
    // [mir] _20 = BoolArr32::lookup(move _21, move _22) -> [return: bb13, unwind: bb18]
    label l7
    _20 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_20), write)
    unfold acc(bool:None(_20), write)
    inhale(Stmt) (_20.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_21.val_ref, _22.val_int))
    transfer perm _21.val_ref --> old[l7](_21.val_ref) // unchecked: false
    Goto(cfg:17)
  label l8 // 17
    // ========== l8 ==========
    // MIR edge bb12 --> bb13
    // Expire borrows
    // expire_borrows ReborrowingDAG(L15,L12,)

    if (__t9) && (true) {
    // expire loan L15
} else {}
    if (__t9) && ((__t9) && (true)) {
    // expire loan L12
    transfer perm old[l7](_21.val_ref) --> old[l5](_21.val_ref) // unchecked: false
    exhale acc(m_BoolArr32$_beg_$_end_(old[l5](_21.val_ref)), read)
} else {}
    Goto(cfg:18)
  label loop2_group3_bb13 // 18
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] _24 = &'_ (*_2)
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(_24.val_ref, write)
    _24.val_ref := borrow _2.val_ref // L13
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_24.val_ref), read)
    label l9
    // [mir] StorageLive(_25)
    // [mir] _25 = _4
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_int, write)
    _25.val_int := copy _4.val_int
    label l10
    // [mir] _23 = BoolArr32::lookup(move _24, move _25) -> [return: bb14, unwind: bb18]
    label l11
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_23), write)
    unfold acc(bool:None(_23), write)
    inhale(Stmt) (_23.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _25.val_int))
    transfer perm _24.val_ref --> old[l11](_24.val_ref) // unchecked: false
    Goto(cfg:19)
  label l12 // 19
    // ========== l12 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    // expire_borrows ReborrowingDAG(L14,L13,)

    if (__t10) && (true) {
    // expire loan L14
} else {}
    if (__t10) && ((__t10) && (true)) {
    // expire loan L13
    transfer perm old[l11](_24.val_ref) --> old[l9](_24.val_ref) // unchecked: false
    exhale acc(m_BoolArr32$_beg_$_end_(old[l9](_24.val_ref)), read)
} else {}
    Goto(cfg:20)
  label loop2_group3_bb14 // 20
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_25)
    // [mir] StorageDead(_24)
    // [mir] StorageLive(_26)
    // [mir] StorageLive(_27)
    // [mir] _27 = &'_ mut _3
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(_27.val_ref, write)
    _27.val_ref := mut borrow _3 // L5
    label l13
    // [mir] StorageLive(_28)
    // [mir] _28 = _4
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_int, write)
    _28.val_int := copy _4.val_int
    label l14
    // [mir] _26 = BoolArr32::index_mut(move _27, move _28) -> [return: bb15, unwind: bb18]
    label l15
    assert(Stmt) (((0) <= (_28.val_int)) && (((_28.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref))) && (true))) && (true)
    fold acc(usize:None(_28), write)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_27)) && ((usize$inv<Ref(usize),Bool>(_28)) && (true))
    exhale (acc(_27.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_27.val_ref), write)) && ((acc(usize(_28), write)) && (true)))
    _26 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_26.val_ref, write)) && (acc(bool(_26.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_26)) && (true)
    inhale(Expr) (((unfolding acc(bool:None(_26.val_ref), write) in _26.val_ref.val_bool)) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _28.val_int)))) && (true)
    exhale true
    label l16
    Goto(cfg:21)
  label loop2_group3_bb15 // 21
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_28)
    // [mir] StorageDead(_27)
    // [mir] (*_26) = BitOr(move _20, move _23)
    unfold acc(bool:None(_26.val_ref), write)
    _26.val_ref.val_bool := copy (_20.val_bool) || (_23.val_bool)
    // expire_borrows ReborrowingDAG(L10,L11,L5,)

    if (__t11) && (true) {
    // expire loan L10
    _old$l16$0 := move _26.val_ref
    inhale(Stmt) (((acc(bool(_old$l16$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l16$0))) && ((true) && (true))) Some(L10) --* (((acc(m_BoolArr32$_beg_$_end_(old[l15](_27.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l15](_27.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref))) == (old[l15](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), old[l15](_28.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l16$0), write) in _old$l16$0.val_bool)))) && ((forall _2_forall_5be58431c8f94233ac0b32ea01095bd7_103: Int  :: (((0) <= (_2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) && (((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref)))) && ((!((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) == (old[l15](_28.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), _2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _2_forall_5be58431c8f94233ac0b32ea01095bd7_103))))) && (true)))) && (true)))
    fold acc(bool:None(_old$l16$0), write)
    apply[L10] ((acc(bool(_old$l16$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l16$0))) && ((true) && (true)) --* ((acc(m_BoolArr32$_beg_$_end_(old[l15](_27.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l15](_27.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref))) == (old[l15](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), old[l15](_28.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l16$0), write) in _old$l16$0.val_bool)))) && ((forall _2_forall_5be58431c8f94233ac0b32ea01095bd7_103: Int  :: (((0) <= (_2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) && (((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref)))) && ((!((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) == (old[l15](_28.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), _2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _2_forall_5be58431c8f94233ac0b32ea01095bd7_103))))) && (true)))) && (true))
    
} else {}
    if (__t11) && ((__t11) && (true)) {
    // expire loan L11
} else {}
    if (__t11) && ((__t11) && ((__t11) && (true))) {
    // expire loan L5
    transfer perm old[l15](_27.val_ref) --> old[l13](_27.val_ref) // unchecked: false
    transfer perm old[l13](_27.val_ref) --> _3 // unchecked: false
} else {}
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_26)
    // [mir] _29 = CheckedAdd(_4, const 1_usize)
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.tuple_0, write)
    inhale(Stmt) acc(_29.tuple_0.val_int, write)
    inhale(Stmt) acc(_29.tuple_1, write)
    inhale(Stmt) acc(_29.tuple_1.val_bool, write)
    _29.tuple_0.val_int := copy (_4.val_int) + (1)
    _29.tuple_1.val_bool := copy false
    // [mir] assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb16, unwind: bb18]
    __t19 := copy _29.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t19)
    Goto(cfg:22)
  label loop2_group3_bb16 // 22
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _4 = move (_29.0: usize)
    _4 := move _29.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:23)
  label loop2_group4_bb2 // 23
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb18]
    Goto(cfg:24)
  label loop2_group4_bb3 // 24
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l18
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t20 := copy _7.val_bool
    GotoSwitch([(Local(__t20: Bool, Position { line: 0, column: 0, id: 0 }), cfg:26)], cfg:25)
  label l19 // 25
    // ========== l19 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:32)
  label l20 // 26
    // ========== l20 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:27)
  label loop2_group5_bb4 // 27
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:28)
  label loop2_group5_bb6 // 28
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t21 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:29)
  label loop2_end_body // 29
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_605176880ec840179c4ee5c7355c11fa_101: Int  :: (((0) <= (_2_forall_605176880ec840179c4ee5c7355c11fa_101)) && (((_2_forall_605176880ec840179c4ee5c7355c11fa_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_605176880ec840179c4ee5c7355c11fa_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_605176880ec840179c4ee5c7355c11fa_101)) || (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_605176880ec840179c4ee5c7355c11fa_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 30
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l21
    // [mir] StorageDead(_4)
    // [mir] drop(_3) -> [return: bb17, unwind: bb19]
    Goto(cfg:31)
  label bb17 // 31
    // ========== bb17 ==========
    __t15 := copy true
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l22 // 32
    // ========== l22 ==========
    // drop Acc(_22.val_int, write) (Acc(_22.val_int, write))
    // drop Acc(_24.val_ref, write) (Acc(_24.val_ref, write))
    // drop Acc(_29.tuple_0, write) (Acc(_29.tuple_0, write))
    // drop Acc(old[l5](_21.val_ref), write) (Acc(old[l5](_21.val_ref), write))
    // drop Acc(_26.val_ref, write) (Acc(_26.val_ref, write))
    // drop Acc(_14.val_bool, write) (Acc(_14.val_bool, write))
    // drop Acc(_29.tuple_1.val_bool, write) (Acc(_29.tuple_1.val_bool, write))
    // drop Acc(_23.val_bool, write) (Acc(_23.val_bool, write))
    // drop Acc(_25.val_int, write) (Acc(_25.val_int, write))
    // drop Acc(_20.val_bool, write) (Acc(_20.val_bool, write))
    // drop Acc(_21.val_ref, write) (Acc(_21.val_ref, write))
    // drop Acc(old[l9](_24.val_ref), write) (Acc(old[l9](_24.val_ref), write))
    // drop Acc(_29.tuple_1, write) (Acc(_29.tuple_1, write))
    Goto(cfg:30)
  label end_of_method
}


struct_predicate closure$0_156$3$13114848456984105119(self){
  true
}


struct_predicate closure$0_159$3$5995690350403947267(self){
  true
}


struct_predicate closure$0_157$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_157$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_157$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_156$3$13114848456984105119(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_156$3$13114848456984105119(self.val_ref), write)) && (true))
}


struct_predicate closure$0_158$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_158$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_158$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_161$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_161$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_161$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_160$3$12052970462978565359(self){
  true
}


struct_predicate ref$closure$0_160$3$12052970462978565359(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_160$3$12052970462978565359(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_159$3$5995690350403947267(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_159$3$5995690350403947267(self.val_ref), write)) && (true))
}


struct_predicate closure$0_162$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_162$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_162$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_163$3$3807802852492153155(self){
  true
}


struct_predicate ref$closure$0_163$3$3807802852492153155(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_163$3$3807802852492153155(self.val_ref), write)) && (true))
}


struct_predicate closure$0_152$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_152$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_152$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_151$3$17041045897492703373(self){
  true
}


struct_predicate ref$closure$0_151$3$17041045897492703373(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_151$3$17041045897492703373(self.val_ref), write)) && (true))
}


struct_predicate closure$0_153$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_153$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_153$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_154$3$3807802852492153155(self){
  true
}


struct_predicate ref$closure$0_154$3$3807802852492153155(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_154$3$3807802852492153155(self.val_ref), write)) && (true))
}


method m_and(2 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t18: Bool
    _old$l16$0: Ref(bool)
    __t19: Bool
    __t20: Bool
    __t21: Bool
    _old$pre$0: Ref(m_BoolArr32$_beg_$_end_)
    _old$pre$1: Ref(m_BoolArr32$_beg_$_end_)
    _1: Ref(ref$m_BoolArr32$_beg_$_end_)
    _2: Ref(ref$m_BoolArr32$_beg_$_end_)
    _3: Ref(m_BoolArr32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_156$3$13114848456984105119)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_159$3$5995690350403947267)
    _16: Ref(ref$usize)
    _17: Ref(ref$m_BoolArr32$_beg_$_end_)
    _18: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _19: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _20: Ref(bool)
    _21: Ref(ref$m_BoolArr32$_beg_$_end_)
    _22: Ref(usize)
    _23: Ref(bool)
    _24: Ref(ref$m_BoolArr32$_beg_$_end_)
    _25: Ref(usize)
    _26: Ref(ref$bool)
    _27: Ref(ref$m_BoolArr32$_beg_$_end_)
    _28: Ref(usize)
    _29: Ref(tuple2$usize$bool)
    _30: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#0}::and"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:345:5: 359:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_1)) && ((ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l23
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BoolArr32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BoolArr32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_a4b5898d9dec4933af8066d4616bb0a5_101: Int  :: (((0) <= (_2_forall_a4b5898d9dec4933af8066d4616bb0a5_101)) && (((_2_forall_a4b5898d9dec4933af8066d4616bb0a5_101) < (32)) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_a4b5898d9dec4933af8066d4616bb0a5_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$0, _2_forall_a4b5898d9dec4933af8066d4616bb0a5_101)) && (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$1, _2_forall_a4b5898d9dec4933af8066d4616bb0a5_101))))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BoolArr32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BoolArr32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BoolArr32::zero() -> [return: bb1, unwind: bb19]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101: Int  :: (((0) <= (_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)) && (((_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = const 0_usize
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy 0
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb18]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l2
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t16 := copy _7.val_bool
    GotoSwitch([(Local(__t16: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:30)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t17 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    _preserve$1 := ghost _2.val_ref
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101: Int  :: (((0) <= (_2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101)) && (((_2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101)) && (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    __t8 := builtin$havoc_bool()
    _23 := builtin$havoc_ref()
    _21 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    _26 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    _20 := builtin$havoc_ref()
    _7 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    __t20 := builtin$havoc_bool()
    _27 := builtin$havoc_ref()
    __t13 := builtin$havoc_bool()
    _28 := builtin$havoc_ref()
    _4 := builtin$havoc_ref()
    __t19 := builtin$havoc_bool()
    __t2 := builtin$havoc_bool()
    _10 := builtin$havoc_ref()
    _29 := builtin$havoc_ref()
    _24 := builtin$havoc_ref()
    __t6 := builtin$havoc_bool()
    _25 := builtin$havoc_ref()
    _14 := builtin$havoc_ref()
    __t18 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    _22 := builtin$havoc_ref()
    _8 := builtin$havoc_ref()
    __t12 := builtin$havoc_bool()
    __t21 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    __t10 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101: Int  :: (((0) <= (_2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101)) && (((_2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101)) && (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101))))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t18 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'_ (*_1)
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_ref, write)
    _21.val_ref := borrow _1.val_ref // L12
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_21.val_ref), read)
    label l5
    // [mir] StorageLive(_22)
    // [mir] _22 = _4
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_int, write)
    unfold acc(usize:None(_4), write)
    _22.val_int := copy _4.val_int
    label l6
    // [mir] _20 = BoolArr32::lookup(move _21, move _22) -> [return: bb13, unwind: bb18]
    label l7
    _20 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_20), write)
    unfold acc(bool:None(_20), write)
    inhale(Stmt) (_20.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_21.val_ref, _22.val_int))
    transfer perm _21.val_ref --> old[l7](_21.val_ref) // unchecked: false
    Goto(cfg:17)
  label l8 // 17
    // ========== l8 ==========
    // MIR edge bb12 --> bb13
    // Expire borrows
    // expire_borrows ReborrowingDAG(L10,L12,)

    if (__t9) && (true) {
    // expire loan L10
} else {}
    if (__t9) && ((__t9) && (true)) {
    // expire loan L12
    transfer perm old[l7](_21.val_ref) --> old[l5](_21.val_ref) // unchecked: false
    exhale acc(m_BoolArr32$_beg_$_end_(old[l5](_21.val_ref)), read)
} else {}
    Goto(cfg:18)
  label loop2_group3_bb13 // 18
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] _24 = &'_ (*_2)
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(_24.val_ref, write)
    _24.val_ref := borrow _2.val_ref // L15
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_24.val_ref), read)
    label l9
    // [mir] StorageLive(_25)
    // [mir] _25 = _4
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_int, write)
    _25.val_int := copy _4.val_int
    label l10
    // [mir] _23 = BoolArr32::lookup(move _24, move _25) -> [return: bb14, unwind: bb18]
    label l11
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_23), write)
    unfold acc(bool:None(_23), write)
    inhale(Stmt) (_23.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _25.val_int))
    transfer perm _24.val_ref --> old[l11](_24.val_ref) // unchecked: false
    Goto(cfg:19)
  label l12 // 19
    // ========== l12 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    // expire_borrows ReborrowingDAG(L11,L15,)

    if (__t10) && (true) {
    // expire loan L11
} else {}
    if (__t10) && ((__t10) && (true)) {
    // expire loan L15
    transfer perm old[l11](_24.val_ref) --> old[l9](_24.val_ref) // unchecked: false
    exhale acc(m_BoolArr32$_beg_$_end_(old[l9](_24.val_ref)), read)
} else {}
    Goto(cfg:20)
  label loop2_group3_bb14 // 20
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_25)
    // [mir] StorageDead(_24)
    // [mir] StorageLive(_26)
    // [mir] StorageLive(_27)
    // [mir] _27 = &'_ mut _3
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(_27.val_ref, write)
    _27.val_ref := mut borrow _3 // L5
    label l13
    // [mir] StorageLive(_28)
    // [mir] _28 = _4
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_int, write)
    _28.val_int := copy _4.val_int
    label l14
    // [mir] _26 = BoolArr32::index_mut(move _27, move _28) -> [return: bb15, unwind: bb18]
    label l15
    assert(Stmt) (((0) <= (_28.val_int)) && (((_28.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref))) && (true))) && (true)
    fold acc(usize:None(_28), write)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_27)) && ((usize$inv<Ref(usize),Bool>(_28)) && (true))
    exhale (acc(_27.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_27.val_ref), write)) && ((acc(usize(_28), write)) && (true)))
    _26 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_26.val_ref, write)) && (acc(bool(_26.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_26)) && (true)
    inhale(Expr) (((unfolding acc(bool:None(_26.val_ref), write) in _26.val_ref.val_bool)) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _28.val_int)))) && (true)
    exhale true
    label l16
    Goto(cfg:21)
  label loop2_group3_bb15 // 21
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_28)
    // [mir] StorageDead(_27)
    // [mir] (*_26) = BitAnd(move _20, move _23)
    unfold acc(bool:None(_26.val_ref), write)
    _26.val_ref.val_bool := copy (_20.val_bool) && (_23.val_bool)
    // expire_borrows ReborrowingDAG(L13,L14,L5,)

    if (__t11) && (true) {
    // expire loan L13
    _old$l16$0 := move _26.val_ref
    inhale(Stmt) (((acc(bool(_old$l16$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l16$0))) && ((true) && (true))) Some(L13) --* (((acc(m_BoolArr32$_beg_$_end_(old[l15](_27.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l15](_27.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref))) == (old[l15](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), old[l15](_28.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l16$0), write) in _old$l16$0.val_bool)))) && ((forall _2_forall_5be58431c8f94233ac0b32ea01095bd7_103: Int  :: (((0) <= (_2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) && (((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref)))) && ((!((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) == (old[l15](_28.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), _2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _2_forall_5be58431c8f94233ac0b32ea01095bd7_103))))) && (true)))) && (true)))
    fold acc(bool:None(_old$l16$0), write)
    apply[L13] ((acc(bool(_old$l16$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l16$0))) && ((true) && (true)) --* ((acc(m_BoolArr32$_beg_$_end_(old[l15](_27.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l15](_27.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref))) == (old[l15](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), old[l15](_28.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l16$0), write) in _old$l16$0.val_bool)))) && ((forall _2_forall_5be58431c8f94233ac0b32ea01095bd7_103: Int  :: (((0) <= (_2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) && (((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref)))) && ((!((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) == (old[l15](_28.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), _2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _2_forall_5be58431c8f94233ac0b32ea01095bd7_103))))) && (true)))) && (true))
    
} else {}
    if (__t11) && ((__t11) && (true)) {
    // expire loan L14
} else {}
    if (__t11) && ((__t11) && ((__t11) && (true))) {
    // expire loan L5
    transfer perm old[l15](_27.val_ref) --> old[l13](_27.val_ref) // unchecked: false
    transfer perm old[l13](_27.val_ref) --> _3 // unchecked: false
} else {}
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_26)
    // [mir] _29 = CheckedAdd(_4, const 1_usize)
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.tuple_0, write)
    inhale(Stmt) acc(_29.tuple_0.val_int, write)
    inhale(Stmt) acc(_29.tuple_1, write)
    inhale(Stmt) acc(_29.tuple_1.val_bool, write)
    _29.tuple_0.val_int := copy (_4.val_int) + (1)
    _29.tuple_1.val_bool := copy false
    // [mir] assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb16, unwind: bb18]
    __t19 := copy _29.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t19)
    Goto(cfg:22)
  label loop2_group3_bb16 // 22
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _4 = move (_29.0: usize)
    _4 := move _29.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:23)
  label loop2_group4_bb2 // 23
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb18]
    Goto(cfg:24)
  label loop2_group4_bb3 // 24
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l18
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t20 := copy _7.val_bool
    GotoSwitch([(Local(__t20: Bool, Position { line: 0, column: 0, id: 0 }), cfg:26)], cfg:25)
  label l19 // 25
    // ========== l19 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:32)
  label l20 // 26
    // ========== l20 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:27)
  label loop2_group5_bb4 // 27
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:28)
  label loop2_group5_bb6 // 28
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t21 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:29)
  label loop2_end_body // 29
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101: Int  :: (((0) <= (_2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101)) && (((_2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101)) && (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 30
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l21
    // [mir] StorageDead(_4)
    // [mir] drop(_3) -> [return: bb17, unwind: bb19]
    Goto(cfg:31)
  label bb17 // 31
    // ========== bb17 ==========
    __t15 := copy true
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l22 // 32
    // ========== l22 ==========
    // drop Acc(old[l5](_21.val_ref), write) (Acc(old[l5](_21.val_ref), write))
    // drop Acc(_24.val_ref, write) (Acc(_24.val_ref, write))
    // drop Acc(_25.val_int, write) (Acc(_25.val_int, write))
    // drop Acc(_29.tuple_1.val_bool, write) (Acc(_29.tuple_1.val_bool, write))
    // drop Acc(old[l9](_24.val_ref), write) (Acc(old[l9](_24.val_ref), write))
    // drop Acc(_29.tuple_0, write) (Acc(_29.tuple_0, write))
    // drop Acc(_14.val_bool, write) (Acc(_14.val_bool, write))
    // drop Acc(_20.val_bool, write) (Acc(_20.val_bool, write))
    // drop Acc(_22.val_int, write) (Acc(_22.val_int, write))
    // drop Acc(_26.val_ref, write) (Acc(_26.val_ref, write))
    // drop Acc(_21.val_ref, write) (Acc(_21.val_ref, write))
    // drop Acc(_23.val_bool, write) (Acc(_23.val_bool, write))
    // drop Acc(_29.tuple_1, write) (Acc(_29.tuple_1, write))
    Goto(cfg:30)
  label end_of_method
}


struct_predicate closure$0_170$3$13114848456984105119(self){
  true
}


struct_predicate closure$0_173$3$5995690350403947267(self){
  true
}


struct_predicate closure$0_171$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_171$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_171$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_170$3$13114848456984105119(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_170$3$13114848456984105119(self.val_ref), write)) && (true))
}


struct_predicate closure$0_172$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_172$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_172$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_175$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_175$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_175$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_174$3$12052970462978565359(self){
  true
}


struct_predicate ref$closure$0_174$3$12052970462978565359(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_174$3$12052970462978565359(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_173$3$5995690350403947267(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_173$3$5995690350403947267(self.val_ref), write)) && (true))
}


struct_predicate closure$0_176$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_176$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_176$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_177$3$3807802852492153155(self){
  true
}


struct_predicate ref$closure$0_177$3$3807802852492153155(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_177$3$3807802852492153155(self.val_ref), write)) && (true))
}


struct_predicate closure$0_166$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_166$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_166$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_165$3$17041045897492703373(self){
  true
}


struct_predicate ref$closure$0_165$3$17041045897492703373(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_165$3$17041045897492703373(self.val_ref), write)) && (true))
}


struct_predicate closure$0_167$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_167$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_167$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_168$3$3807802852492153155(self){
  true
}


struct_predicate ref$closure$0_168$3$3807802852492153155(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_168$3$3807802852492153155(self.val_ref), write)) && (true))
}


method m_xor(2 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t18: Bool
    _old$l16$0: Ref(bool)
    __t19: Bool
    __t20: Bool
    __t21: Bool
    _old$pre$0: Ref(m_BoolArr32$_beg_$_end_)
    _old$pre$1: Ref(m_BoolArr32$_beg_$_end_)
    _1: Ref(ref$m_BoolArr32$_beg_$_end_)
    _2: Ref(ref$m_BoolArr32$_beg_$_end_)
    _3: Ref(m_BoolArr32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_170$3$13114848456984105119)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_173$3$5995690350403947267)
    _16: Ref(ref$usize)
    _17: Ref(ref$m_BoolArr32$_beg_$_end_)
    _18: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _19: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _20: Ref(bool)
    _21: Ref(ref$m_BoolArr32$_beg_$_end_)
    _22: Ref(usize)
    _23: Ref(bool)
    _24: Ref(ref$m_BoolArr32$_beg_$_end_)
    _25: Ref(usize)
    _26: Ref(ref$bool)
    _27: Ref(ref$m_BoolArr32$_beg_$_end_)
    _28: Ref(usize)
    _29: Ref(tuple2$usize$bool)
    _30: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#0}::xor"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:366:5: 380:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_1)) && ((ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l23
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BoolArr32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BoolArr32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_6141c0bff5ec4e7b873ab30d99854094_101: Int  :: (((0) <= (_2_forall_6141c0bff5ec4e7b873ab30d99854094_101)) && (((_2_forall_6141c0bff5ec4e7b873ab30d99854094_101) < (32)) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_6141c0bff5ec4e7b873ab30d99854094_101)) == (!((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$0, _2_forall_6141c0bff5ec4e7b873ab30d99854094_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$1, _2_forall_6141c0bff5ec4e7b873ab30d99854094_101)))))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BoolArr32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BoolArr32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BoolArr32::zero() -> [return: bb1, unwind: bb19]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101: Int  :: (((0) <= (_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)) && (((_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = const 0_usize
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy 0
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb18]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l2
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t16 := copy _7.val_bool
    GotoSwitch([(Local(__t16: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:30)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t17 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$1 := ghost _2.val_ref
    _preserve$0 := ghost _1.val_ref
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_6c9d0f511e42430691075c716aae94d9_101: Int  :: (((0) <= (_2_forall_6c9d0f511e42430691075c716aae94d9_101)) && (((_2_forall_6c9d0f511e42430691075c716aae94d9_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_6c9d0f511e42430691075c716aae94d9_101)) == (!((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_6c9d0f511e42430691075c716aae94d9_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_6c9d0f511e42430691075c716aae94d9_101)))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    __t3 := builtin$havoc_bool()
    _8 := builtin$havoc_ref()
    __t18 := builtin$havoc_bool()
    _27 := builtin$havoc_ref()
    __t5 := builtin$havoc_bool()
    _14 := builtin$havoc_ref()
    __t6 := builtin$havoc_bool()
    _28 := builtin$havoc_ref()
    _21 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    _4 := builtin$havoc_ref()
    _23 := builtin$havoc_ref()
    _24 := builtin$havoc_ref()
    __t21 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    _25 := builtin$havoc_ref()
    __t20 := builtin$havoc_bool()
    _26 := builtin$havoc_ref()
    __t19 := builtin$havoc_bool()
    __t8 := builtin$havoc_bool()
    _20 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    __t2 := builtin$havoc_bool()
    __t12 := builtin$havoc_bool()
    _29 := builtin$havoc_ref()
    _22 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    _10 := builtin$havoc_ref()
    _7 := builtin$havoc_ref()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_6c9d0f511e42430691075c716aae94d9_101: Int  :: (((0) <= (_2_forall_6c9d0f511e42430691075c716aae94d9_101)) && (((_2_forall_6c9d0f511e42430691075c716aae94d9_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_6c9d0f511e42430691075c716aae94d9_101)) == (!((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_6c9d0f511e42430691075c716aae94d9_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_6c9d0f511e42430691075c716aae94d9_101)))))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t18 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'_ (*_1)
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_ref, write)
    _21.val_ref := borrow _1.val_ref // L14
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_21.val_ref), read)
    label l5
    // [mir] StorageLive(_22)
    // [mir] _22 = _4
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_int, write)
    unfold acc(usize:None(_4), write)
    _22.val_int := copy _4.val_int
    label l6
    // [mir] _20 = BoolArr32::lookup(move _21, move _22) -> [return: bb13, unwind: bb18]
    label l7
    _20 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_20), write)
    unfold acc(bool:None(_20), write)
    inhale(Stmt) (_20.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_21.val_ref, _22.val_int))
    transfer perm _21.val_ref --> old[l7](_21.val_ref) // unchecked: false
    Goto(cfg:17)
  label l8 // 17
    // ========== l8 ==========
    // MIR edge bb12 --> bb13
    // Expire borrows
    // expire_borrows ReborrowingDAG(L12,L14,)

    if (__t9) && (true) {
    // expire loan L12
} else {}
    if (__t9) && ((__t9) && (true)) {
    // expire loan L14
    transfer perm old[l7](_21.val_ref) --> old[l5](_21.val_ref) // unchecked: false
    exhale acc(m_BoolArr32$_beg_$_end_(old[l5](_21.val_ref)), read)
} else {}
    Goto(cfg:18)
  label loop2_group3_bb13 // 18
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] _24 = &'_ (*_2)
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(_24.val_ref, write)
    _24.val_ref := borrow _2.val_ref // L13
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_24.val_ref), read)
    label l9
    // [mir] StorageLive(_25)
    // [mir] _25 = _4
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_int, write)
    _25.val_int := copy _4.val_int
    label l10
    // [mir] _23 = BoolArr32::lookup(move _24, move _25) -> [return: bb14, unwind: bb18]
    label l11
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_23), write)
    unfold acc(bool:None(_23), write)
    inhale(Stmt) (_23.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _25.val_int))
    transfer perm _24.val_ref --> old[l11](_24.val_ref) // unchecked: false
    Goto(cfg:19)
  label l12 // 19
    // ========== l12 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    // expire_borrows ReborrowingDAG(L15,L13,)

    if (__t10) && (true) {
    // expire loan L15
} else {}
    if (__t10) && ((__t10) && (true)) {
    // expire loan L13
    transfer perm old[l11](_24.val_ref) --> old[l9](_24.val_ref) // unchecked: false
    exhale acc(m_BoolArr32$_beg_$_end_(old[l9](_24.val_ref)), read)
} else {}
    Goto(cfg:20)
  label loop2_group3_bb14 // 20
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_25)
    // [mir] StorageDead(_24)
    // [mir] StorageLive(_26)
    // [mir] StorageLive(_27)
    // [mir] _27 = &'_ mut _3
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(_27.val_ref, write)
    _27.val_ref := mut borrow _3 // L5
    label l13
    // [mir] StorageLive(_28)
    // [mir] _28 = _4
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_int, write)
    _28.val_int := copy _4.val_int
    label l14
    // [mir] _26 = BoolArr32::index_mut(move _27, move _28) -> [return: bb15, unwind: bb18]
    label l15
    assert(Stmt) (((0) <= (_28.val_int)) && (((_28.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref))) && (true))) && (true)
    fold acc(usize:None(_28), write)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_27)) && ((usize$inv<Ref(usize),Bool>(_28)) && (true))
    exhale (acc(_27.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_27.val_ref), write)) && ((acc(usize(_28), write)) && (true)))
    _26 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_26.val_ref, write)) && (acc(bool(_26.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_26)) && (true)
    inhale(Expr) (((unfolding acc(bool:None(_26.val_ref), write) in _26.val_ref.val_bool)) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _28.val_int)))) && (true)
    exhale true
    label l16
    Goto(cfg:21)
  label loop2_group3_bb15 // 21
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_28)
    // [mir] StorageDead(_27)
    // [mir] (*_26) = BitXor(move _20, move _23)
    unfold acc(bool:None(_26.val_ref), write)
    _26.val_ref.val_bool := copy !((_20.val_bool) == (_23.val_bool))
    // expire_borrows ReborrowingDAG(L10,L11,L5,)

    if (__t11) && (true) {
    // expire loan L10
    _old$l16$0 := move _26.val_ref
    inhale(Stmt) (((acc(bool(_old$l16$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l16$0))) && ((true) && (true))) Some(L10) --* (((acc(m_BoolArr32$_beg_$_end_(old[l15](_27.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l15](_27.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref))) == (old[l15](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), old[l15](_28.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l16$0), write) in _old$l16$0.val_bool)))) && ((forall _2_forall_5be58431c8f94233ac0b32ea01095bd7_103: Int  :: (((0) <= (_2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) && (((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref)))) && ((!((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) == (old[l15](_28.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), _2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _2_forall_5be58431c8f94233ac0b32ea01095bd7_103))))) && (true)))) && (true)))
    fold acc(bool:None(_old$l16$0), write)
    apply[L10] ((acc(bool(_old$l16$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l16$0))) && ((true) && (true)) --* ((acc(m_BoolArr32$_beg_$_end_(old[l15](_27.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l15](_27.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref))) == (old[l15](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), old[l15](_28.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l16$0), write) in _old$l16$0.val_bool)))) && ((forall _2_forall_5be58431c8f94233ac0b32ea01095bd7_103: Int  :: (((0) <= (_2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) && (((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l15](_27.val_ref)))) && ((!((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) == (old[l15](_28.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l15](_27.val_ref), _2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _2_forall_5be58431c8f94233ac0b32ea01095bd7_103))))) && (true)))) && (true))
    
} else {}
    if (__t11) && ((__t11) && (true)) {
    // expire loan L11
} else {}
    if (__t11) && ((__t11) && ((__t11) && (true))) {
    // expire loan L5
    transfer perm old[l15](_27.val_ref) --> old[l13](_27.val_ref) // unchecked: false
    transfer perm old[l13](_27.val_ref) --> _3 // unchecked: false
} else {}
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_26)
    // [mir] _29 = CheckedAdd(_4, const 1_usize)
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.tuple_0, write)
    inhale(Stmt) acc(_29.tuple_0.val_int, write)
    inhale(Stmt) acc(_29.tuple_1, write)
    inhale(Stmt) acc(_29.tuple_1.val_bool, write)
    _29.tuple_0.val_int := copy (_4.val_int) + (1)
    _29.tuple_1.val_bool := copy false
    // [mir] assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb16, unwind: bb18]
    __t19 := copy _29.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t19)
    Goto(cfg:22)
  label loop2_group3_bb16 // 22
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _4 = move (_29.0: usize)
    _4 := move _29.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:23)
  label loop2_group4_bb2 // 23
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb18]
    Goto(cfg:24)
  label loop2_group4_bb3 // 24
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l18
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t20 := copy _7.val_bool
    GotoSwitch([(Local(__t20: Bool, Position { line: 0, column: 0, id: 0 }), cfg:26)], cfg:25)
  label l19 // 25
    // ========== l19 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:32)
  label l20 // 26
    // ========== l20 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:27)
  label loop2_group5_bb4 // 27
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:28)
  label loop2_group5_bb6 // 28
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t21 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:29)
  label loop2_end_body // 29
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_6c9d0f511e42430691075c716aae94d9_101: Int  :: (((0) <= (_2_forall_6c9d0f511e42430691075c716aae94d9_101)) && (((_2_forall_6c9d0f511e42430691075c716aae94d9_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_6c9d0f511e42430691075c716aae94d9_101)) == (!((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_6c9d0f511e42430691075c716aae94d9_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_6c9d0f511e42430691075c716aae94d9_101)))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 30
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l21
    // [mir] StorageDead(_4)
    // [mir] drop(_3) -> [return: bb17, unwind: bb19]
    Goto(cfg:31)
  label bb17 // 31
    // ========== bb17 ==========
    __t15 := copy true
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l22 // 32
    // ========== l22 ==========
    // drop Acc(_22.val_int, write) (Acc(_22.val_int, write))
    // drop Acc(_14.val_bool, write) (Acc(_14.val_bool, write))
    // drop Acc(_29.tuple_1.val_bool, write) (Acc(_29.tuple_1.val_bool, write))
    // drop Acc(_24.val_ref, write) (Acc(_24.val_ref, write))
    // drop Acc(old[l9](_24.val_ref), write) (Acc(old[l9](_24.val_ref), write))
    // drop Acc(_21.val_ref, write) (Acc(_21.val_ref, write))
    // drop Acc(_26.val_ref, write) (Acc(_26.val_ref, write))
    // drop Acc(_25.val_int, write) (Acc(_25.val_int, write))
    // drop Acc(_29.tuple_0, write) (Acc(_29.tuple_0, write))
    // drop Acc(old[l5](_21.val_ref), write) (Acc(old[l5](_21.val_ref), write))
    // drop Acc(_23.val_bool, write) (Acc(_23.val_bool, write))
    // drop Acc(_20.val_bool, write) (Acc(_20.val_bool, write))
    // drop Acc(_29.tuple_1, write) (Acc(_29.tuple_1, write))
    Goto(cfg:30)
  label end_of_method
}


struct_predicate m_BitVec32$_beg_$_end_(self){
  (acc(self.f$v, write)) && ((acc(u32(self.f$v), write)) && (true))
}


struct_predicate closure$0_190$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_190$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_190$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate ref$m_BitVec32$_beg_$_end_(self){
  (acc(self.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(self.val_ref), write)) && (true))
}


function m_main$$$opencur$impl$sharp$1$closecur$$$len(_1: Ref(m_BitVec32$_beg_$_end_)): Int
  requires (acc(m_BitVec32$_beg_$_end_(_1), read)) && (true)
  requires true
  ensures ((__result) == (32)) && (true)


struct_predicate closure$0_193$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_193$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_193$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_194$3$8037587520250505299(self){
  true
}


struct_predicate ref$closure$0_194$3$8037587520250505299(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_194$3$8037587520250505299(self.val_ref), write)) && (true))
}


struct_predicate ref$ref$m_BitVec32$_beg_$_end_(self){
  (acc(self.val_ref, write)) && ((acc(ref$m_BitVec32$_beg_$_end_(self.val_ref), write)) && (true))
}


function m_main$$$opencur$impl$sharp$1$closecur$$$lookup(_1: Ref(m_BitVec32$_beg_$_end_), _2: Int): Bool
  requires (acc(m_BitVec32$_beg_$_end_(_1), read)) && (true)
  requires (((0) <= (_2)) && (((_2) < (m_main$$$opencur$impl$sharp$1$closecur$$$len<Ref(m_BitVec32$_beg_$_end_),Int>(_1))) && (true))) && (true)
  ensures true


struct_predicate closure$0_214$3$13114848456984105119(self){
  true
}


struct_predicate closure$0_217$3$2331299993329797620(self){
  true
}


struct_predicate closure$0_185$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_185$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_185$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_184$3$5634854238285223417(self){
  true
}


struct_predicate ref$closure$0_184$3$5634854238285223417(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_184$3$5634854238285223417(self.val_ref), write)) && (true))
}


struct_predicate closure$0_186$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_186$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_186$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_187$3$13255826576935679396(self){
  true
}


struct_predicate ref$closure$0_187$3$13255826576935679396(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_187$3$13255826576935679396(self.val_ref), write)) && (true))
}


struct_predicate closure$0_215$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_215$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_215$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_214$3$13114848456984105119(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_214$3$13114848456984105119(self.val_ref), write)) && (true))
}


struct_predicate closure$0_216$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_216$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_216$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_219$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_219$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_219$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_218$3$6123593486954012705(self){
  true
}


struct_predicate ref$closure$0_218$3$6123593486954012705(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_218$3$6123593486954012705(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_217$3$2331299993329797620(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_217$3$2331299993329797620(self.val_ref), write)) && (true))
}


struct_predicate closure$0_220$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_220$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_220$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_221$3$11888960811186136071(self){
  true
}


struct_predicate ref$closure$0_221$3$11888960811186136071(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_221$3$11888960811186136071(self.val_ref), write)) && (true))
}


struct_predicate closure$0_197$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_197$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_197$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_198$3$5641262981345148210(self){
  true
}


struct_predicate ref$closure$0_198$3$5641262981345148210(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_198$3$5641262981345148210(self.val_ref), write)) && (true))
}


struct_predicate closure$0_200$3$9939277234896910635(self){
  true
}


struct_predicate ref$closure$0_200$3$9939277234896910635(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_200$3$9939277234896910635(self.val_ref), write)) && (true))
}


struct_predicate closure$0_203$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_203$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_203$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_202$3$746644434486209686(self){
  true
}


struct_predicate ref$closure$0_202$3$746644434486209686(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_202$3$746644434486209686(self.val_ref), write)) && (true))
}


struct_predicate closure$0_204$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_204$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_204$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_205$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_205$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_205$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_206$3$18242494998631174503(self){
  true
}


struct_predicate ref$closure$0_206$3$18242494998631174503(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_206$3$18242494998631174503(self.val_ref), write)) && (true))
}


struct_predicate closure$0_210$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_210$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_210$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_209$3$11508765913596256963(self){
  true
}


struct_predicate ref$closure$0_209$3$11508765913596256963(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_209$3$11508765913596256963(self.val_ref), write)) && (true))
}


struct_predicate closure$0_211$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_211$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_211$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_212$3$11888960811186136071(self){
  true
}


struct_predicate ref$closure$0_212$3$11888960811186136071(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_212$3$11888960811186136071(self.val_ref), write)) && (true))
}


method m_reverse_bits_v(1 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    _preserve$0: Ref(AuxRef)
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    __t21: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(m_BitVec32$_beg_$_end_)
    _3: Ref(usize)
    _4: Ref(tuple0$)
    _5: Ref(tuple0$)
    _6: Ref(bool)
    _7: Ref(usize)
    _8: Ref(tuple0$)
    _9: Ref(bool)
    _10: Ref(closure$0_214$3$13114848456984105119)
    _11: Ref(ref$usize)
    _12: Ref(tuple0$)
    _13: Ref(bool)
    _14: Ref(closure$0_217$3$2331299993329797620)
    _15: Ref(ref$usize)
    _16: Ref(ref$m_BitVec32$_beg_$_end_)
    _17: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _18: Ref(tuple0$)
    _19: Ref(ref$m_BitVec32$_beg_$_end_)
    _20: Ref(usize)
    _21: Ref(bool)
    _22: Ref(ref$m_BitVec32$_beg_$_end_)
    _23: Ref(usize)
    _24: Ref(usize)
    _25: Ref(tuple2$usize$bool)
    _26: Ref(tuple2$usize$bool)
    _27: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#1}::reverse_bits_v"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:506:5: 526:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && (true))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && (true)
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l21
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_4200c771519b4853aa24783f5d76e2df_101: Int  :: (((0) <= (_2_forall_4200c771519b4853aa24783f5d76e2df_101)) && (((_2_forall_4200c771519b4853aa24783f5d76e2df_101) < (32)) && (true))) ==> ((!(false))?((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_0, _2_forall_4200c771519b4853aa24783f5d76e2df_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$0, (31) - (_2_forall_4200c771519b4853aa24783f5d76e2df_101)))):(false))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_2)
    // [mir] _2 = BitVec32::zero() -> [return: bb1, unwind: bb17]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _2 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_2), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_2)) && (true)
    inhale(Expr) (forall _2_forall_6e18d74b08724366806ddc03a6946ae9_101: Int  :: (((0) <= (_2_forall_6e18d74b08724366806ddc03a6946ae9_101)) && (((_2_forall_6e18d74b08724366806ddc03a6946ae9_101) < (32)) && (true))) ==> (!(m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2, _2_forall_6e18d74b08724366806ddc03a6946ae9_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _2)
    // [mir] StorageLive(_3)
    // [mir] _3 = const 0_usize
    _3 := builtin$havoc_ref()
    inhale(Stmt) acc(_3.val_int, write)
    _3.val_int := copy 0
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] _7 = _3
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_int, write)
    _7.val_int := copy _3.val_int
    label l2
    // [mir] _6 = Lt(move _7, const 32_usize)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_bool, write)
    _6.val_bool := copy (_7.val_int) < (32)
    // [mir] StorageDead(_7)
    // [mir] FakeRead(ForMatchedPlace, _6)
    // [mir] switchInt(_6) -> [false: bb5, otherwise: bb4]
    __t15 := copy _6.val_bool
    GotoSwitch([(Local(__t15: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:30)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_8)
    // [mir] StorageLive(_9)
    // [mir] _9 = const false
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy false
    // [mir] switchInt(move _9) -> [false: bb8, otherwise: bb7]
    __t16 := copy _9.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    fold acc(bool:None(_6), write)
    obtain acc(bool(_6), write)
    fold acc(usize:None(_3), write)
    obtain acc(usize(_3), write)
    obtain acc(m_BitVec32$_beg_$_end_(_2), write)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_3), write) in _3.val_int))) && ((((unfolding acc(usize:None(_3), write) in _3.val_int)) < (32)) && (true))) && ((forall _2_forall_8a3439d84ad248588294c52d2faa4353_101: Int  :: (((0) <= (_2_forall_8a3439d84ad248588294c52d2faa4353_101)) && (((_2_forall_8a3439d84ad248588294c52d2faa4353_101) < ((unfolding acc(usize:None(_3), write) in _3.val_int))) && (true))) ==> ((!(false))?((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2, _2_forall_8a3439d84ad248588294c52d2faa4353_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, (31) - (_2_forall_8a3439d84ad248588294c52d2faa4353_101)))):(false))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_6), write)) && ((acc(usize(_3), write)) && ((acc(m_BitVec32$_beg_$_end_(_2), write)) && ((acc(_1.val_ref, read)) && (true))))
    __t7 := builtin$havoc_bool()
    _23 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    __t19 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    _13 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    __t2 := builtin$havoc_bool()
    _9 := builtin$havoc_ref()
    __t11 := builtin$havoc_bool()
    _18 := builtin$havoc_ref()
    _26 := builtin$havoc_ref()
    _19 := builtin$havoc_ref()
    _20 := builtin$havoc_ref()
    _25 := builtin$havoc_ref()
    __t18 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    __t21 := builtin$havoc_bool()
    _6 := builtin$havoc_ref()
    _24 := builtin$havoc_ref()
    _22 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    __t12 := builtin$havoc_bool()
    _3 := builtin$havoc_ref()
    __t20 := builtin$havoc_bool()
    _21 := builtin$havoc_ref()
    __t6 := builtin$havoc_bool()
    __t17 := builtin$havoc_bool()
    _7 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_6), write)) && ((acc(usize(_3), write)) && ((acc(m_BitVec32$_beg_$_end_(_2), write)) && ((acc(_1.val_ref, read)) && (true))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    inhale(Expr) (((0) <= ((unfolding acc(usize:None(_3), write) in _3.val_int))) && ((((unfolding acc(usize:None(_3), write) in _3.val_int)) < (32)) && (true))) && ((forall _2_forall_8a3439d84ad248588294c52d2faa4353_101: Int  :: (((0) <= (_2_forall_8a3439d84ad248588294c52d2faa4353_101)) && (((_2_forall_8a3439d84ad248588294c52d2faa4353_101) < ((unfolding acc(usize:None(_3), write) in _3.val_int))) && (true))) ==> ((!(false))?((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2, _2_forall_8a3439d84ad248588294c52d2faa4353_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, (31) - (_2_forall_8a3439d84ad248588294c52d2faa4353_101)))):(false))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _8 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_8)
    // [mir] StorageLive(_12)
    // [mir] StorageLive(_13)
    // [mir] _13 = const false
    _13 := builtin$havoc_ref()
    inhale(Stmt) acc(_13.val_bool, write)
    _13.val_bool := copy false
    // [mir] switchInt(move _13) -> [false: bb11, otherwise: bb10]
    __t17 := copy _13.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _12 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_13)
    // [mir] StorageDead(_12)
    // [mir] StorageLive(_18)
    // [mir] StorageLive(_19)
    // [mir] _19 = &'_ mut _2
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_ref, write)
    _19.val_ref := mut borrow _2 // L4
    label l5
    // [mir] StorageLive(_20)
    // [mir] _20 = _3
    _20 := builtin$havoc_ref()
    inhale(Stmt) acc(_20.val_int, write)
    unfold acc(usize:None(_3), write)
    _20.val_int := copy _3.val_int
    label l6
    // [mir] StorageLive(_21)
    // [mir] StorageLive(_22)
    // [mir] _22 = &'_ (*_1)
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_ref, write)
    _22.val_ref := borrow _1.val_ref // L8
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_22.val_ref), read)
    label l7
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] _24 = _3
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(_24.val_int, write)
    _24.val_int := copy _3.val_int
    label l8
    // [mir] _25 = CheckedSub(const 31_usize, _24)
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.tuple_0, write)
    inhale(Stmt) acc(_25.tuple_0.val_int, write)
    inhale(Stmt) acc(_25.tuple_1, write)
    inhale(Stmt) acc(_25.tuple_1.val_bool, write)
    _25.tuple_0.val_int := copy (31) - (_24.val_int)
    _25.tuple_1.val_bool := copy false
    // [mir] assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", const 31_usize, move _24) -> [success: bb13, unwind: bb17]
    __t18 := copy _25.tuple_1.val_bool
    // Rust assertion: attempt to subtract with overflow
    assert(Stmt) !(__t18)
    Goto(cfg:17)
  label loop2_group3_bb13 // 17
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] _23 = move (_25.0: usize)
    _23 := move _25.tuple_0
    label l9
    // [mir] StorageDead(_24)
    // [mir] _21 = BitVec32::lookup(move _22, move _23) -> [return: bb14, unwind: bb17]
    label l10
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_21), write)
    unfold acc(bool:None(_21), write)
    inhale(Stmt) (_21.val_bool) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_22.val_ref, _23.val_int))
    transfer perm _22.val_ref --> old[l10](_22.val_ref) // unchecked: false
    Goto(cfg:18)
  label l11 // 18
    // ========== l11 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    // expire_borrows ReborrowingDAG(L9,L8,)

    if (__t10) && (true) {
    // expire loan L9
} else {}
    if (__t9) && ((__t10) && (true)) {
    // expire loan L8
    transfer perm old[l10](_22.val_ref) --> old[l7](_22.val_ref) // unchecked: false
    exhale acc(m_BitVec32$_beg_$_end_(old[l7](_22.val_ref)), read)
} else {}
    Goto(cfg:19)
  label loop2_group3_bb14 // 19
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_22)
    // [mir] _18 = BitVec32::set_bit(move _19, move _20, move _21) -> [return: bb15, unwind: bb17]
    label l12
    assert(Stmt) (((0) <= (_20.val_int)) && (((_20.val_int) < (m_main$$$opencur$impl$sharp$1$closecur$$$len<Ref(m_BitVec32$_beg_$_end_),Int>(_19.val_ref))) && (true))) && (true)
    fold acc(bool:None(_21), write)
    fold acc(usize:None(_20), write)
    assert(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_19)) && ((usize$inv<Ref(usize),Bool>(_20)) && ((bool$inv<Ref(bool),Bool>(_21)) && (true)))
    exhale (acc(_19.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_19.val_ref), write)) && ((acc(usize(_20), write)) && ((acc(bool(_21), write)) && (true))))
    _18 := builtin$havoc_ref()
    inhale(Stmt) (acc(m_BitVec32$_beg_$_end_(old[l12](_19.val_ref)), write)) && (true)
    inhale(Stmt) acc(tuple0$(_18), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(old[l12](_19.val_ref))) && ((tuple0$$inv<Ref(tuple0$),Bool>(_18)) && (true))
    inhale(Expr) ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l12](_19.val_ref), old[l12](_20.val_int))) == (old[l12](_21.val_bool))) && ((forall _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101: Int  :: (((0) <= (_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101)) && (((_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101) < (32)) && ((!((_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101) == (old[l12](_20.val_int)))) && (true)))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l12](_19.val_ref), _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101)) == (old[l12](m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_19.val_ref, _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101))))) && (true))
    exhale true
    label l13
    Goto(cfg:20)
  label l14 // 20
    // ========== l14 ==========
    // MIR edge bb14 --> bb15
    // Expire borrows
    // expire_borrows ReborrowingDAG(L10,L4,)

    if (__t11) && (true) {
    // expire loan L10
} else {}
    if (__t9) && ((__t11) && (true)) {
    // expire loan L4
    transfer perm old[l12](_19.val_ref) --> old[l5](_19.val_ref) // unchecked: false
    transfer perm old[l5](_19.val_ref) --> _2 // unchecked: false
} else {}
    Goto(cfg:21)
  label loop2_group3_bb15 // 21
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_21)
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_18)
    // [mir] _26 = CheckedAdd(_3, const 1_usize)
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.tuple_0, write)
    inhale(Stmt) acc(_26.tuple_0.val_int, write)
    inhale(Stmt) acc(_26.tuple_1, write)
    inhale(Stmt) acc(_26.tuple_1.val_bool, write)
    _26.tuple_0.val_int := copy (_3.val_int) + (1)
    _26.tuple_1.val_bool := copy false
    // [mir] assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_usize) -> [success: bb16, unwind: bb17]
    __t19 := copy _26.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t19)
    Goto(cfg:22)
  label loop2_group3_bb16 // 22
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _3 = move (_26.0: usize)
    _3 := move _26.tuple_0
    label l15
    // [mir] _5 = const ()
    // [mir] StorageDead(_6)
    // [mir] goto -> bb2
    Goto(cfg:23)
  label loop2_group4_bb2 // 23
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:24)
  label loop2_group4_bb3 // 24
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] _7 = _3
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_int, write)
    _7.val_int := copy _3.val_int
    label l16
    // [mir] _6 = Lt(move _7, const 32_usize)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_bool, write)
    _6.val_bool := copy (_7.val_int) < (32)
    // [mir] StorageDead(_7)
    // [mir] FakeRead(ForMatchedPlace, _6)
    // [mir] switchInt(_6) -> [false: bb5, otherwise: bb4]
    __t20 := copy _6.val_bool
    GotoSwitch([(Local(__t20: Bool, Position { line: 0, column: 0, id: 0 }), cfg:26)], cfg:25)
  label l17 // 25
    // ========== l17 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l18 // 26
    // ========== l18 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:27)
  label loop2_group5_bb4 // 27
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:28)
  label loop2_group5_bb6 // 28
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_8)
    // [mir] StorageLive(_9)
    // [mir] _9 = const false
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy false
    // [mir] switchInt(move _9) -> [false: bb8, otherwise: bb7]
    __t21 := copy _9.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:29)
  label loop2_end_body // 29
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_6), write)
    obtain acc(bool(_6), write)
    fold acc(usize:None(_3), write)
    obtain acc(usize(_3), write)
    obtain acc(m_BitVec32$_beg_$_end_(_2), write)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_3), write) in _3.val_int))) && ((((unfolding acc(usize:None(_3), write) in _3.val_int)) < (32)) && (true))) && ((forall _2_forall_8a3439d84ad248588294c52d2faa4353_101: Int  :: (((0) <= (_2_forall_8a3439d84ad248588294c52d2faa4353_101)) && (((_2_forall_8a3439d84ad248588294c52d2faa4353_101) < ((unfolding acc(usize:None(_3), write) in _3.val_int))) && (true))) ==> ((!(false))?((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2, _2_forall_8a3439d84ad248588294c52d2faa4353_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, (31) - (_2_forall_8a3439d84ad248588294c52d2faa4353_101)))):(false))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_6), write)) && ((acc(usize(_3), write)) && ((acc(m_BitVec32$_beg_$_end_(_2), write)) && ((acc(_1.val_ref, read)) && (true))))
    inhale(Stmt) false
    Return
  label bb5 // 30
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _4 = const ()
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_4)
    // [mir] _0 = move _2
    _0 := move _2
    label l19
    // [mir] StorageDead(_3)
    // [mir] StorageDead(_2)
    // [mir] return
    Goto(cfg:1)
  label l20 // 31
    // ========== l20 ==========
    // drop Acc(_24.val_int, write) (Acc(_24.val_int, write))
    // drop Acc(_22.val_ref, write) (Acc(_22.val_ref, write))
    // drop Acc(_25.tuple_0, write) (Acc(_25.tuple_0, write))
    // drop Acc(_23.val_int, write) (Acc(_23.val_int, write))
    // drop Acc(_26.tuple_1.val_bool, write) (Acc(_26.tuple_1.val_bool, write))
    // drop Acc(_26.tuple_0, write) (Acc(_26.tuple_0, write))
    // drop Acc(_25.tuple_1.val_bool, write) (Acc(_25.tuple_1.val_bool, write))
    // drop Acc(_13.val_bool, write) (Acc(_13.val_bool, write))
    // drop Acc(old[l7](_22.val_ref), write) (Acc(old[l7](_22.val_ref), write))
    // drop Pred(_18, write) (Pred(_18, write))
    // drop Acc(_25.tuple_1, write) (Acc(_25.tuple_1, write))
    // drop Acc(_26.tuple_1, write) (Acc(_26.tuple_1, write))
    Goto(cfg:30)
  label end_of_method
}


struct_predicate closure$0_261$3$12351797966212270264(self){
  true
}


struct_predicate closure$0_252$3$2449336065822019816(self){
  true
}


struct_predicate closure$0_245$3$13114848456984105119(self){
  true
}


struct_predicate closure$0_248$3$3859392265678673261(self){
  true
}


struct_predicate closure$0_246$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_246$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_246$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_245$3$13114848456984105119(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_245$3$13114848456984105119(self.val_ref), write)) && (true))
}


struct_predicate closure$0_247$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_247$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_247$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_249$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_249$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_249$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_248$3$3859392265678673261(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_248$3$3859392265678673261(self.val_ref), write)) && (true))
}


struct_predicate closure$0_250$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_250$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_250$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_251$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_251$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_251$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_254$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_254$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_254$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_253$3$10151796348567112990(self){
  true
}


struct_predicate ref$closure$0_253$3$10151796348567112990(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_253$3$10151796348567112990(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_252$3$2449336065822019816(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_252$3$2449336065822019816(self.val_ref), write)) && (true))
}


struct_predicate closure$0_255$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_255$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_255$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_256$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_256$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_256$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_257$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_257$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_257$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_258$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_258$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_258$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_259$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_259$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_259$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_260$3$7504853677232065494(self){
  true
}


struct_predicate ref$closure$0_260$3$7504853677232065494(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_260$3$7504853677232065494(self.val_ref), write)) && (true))
}


struct_predicate closure$0_263$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_263$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_263$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_262$3$5412928828267228331(self){
  true
}


struct_predicate ref$closure$0_262$3$5412928828267228331(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_262$3$5412928828267228331(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_261$3$12351797966212270264(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_261$3$12351797966212270264(self.val_ref), write)) && (true))
}


struct_predicate closure$0_264$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_264$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_264$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_265$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_265$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_265$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_266$3$634645340582930069(self){
  true
}


struct_predicate ref$closure$0_266$3$634645340582930069(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_266$3$634645340582930069(self.val_ref), write)) && (true))
}


struct_predicate closure$0_229$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_229$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_229$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_232$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_232$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_232$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_231$3$17224062769849217658(self){
  true
}


struct_predicate ref$closure$0_231$3$17224062769849217658(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_231$3$17224062769849217658(self.val_ref), write)) && (true))
}


struct_predicate closure$0_233$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_233$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_233$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_234$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_234$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_234$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_235$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_235$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_235$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_236$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_236$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_236$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_237$3$7504853677232065494(self){
  true
}


struct_predicate ref$closure$0_237$3$7504853677232065494(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_237$3$7504853677232065494(self.val_ref), write)) && (true))
}


struct_predicate closure$0_240$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_240$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_240$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_239$3$5412928828267228331(self){
  true
}


struct_predicate ref$closure$0_239$3$5412928828267228331(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_239$3$5412928828267228331(self.val_ref), write)) && (true))
}


struct_predicate closure$0_241$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_241$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_241$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_242$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_242$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_242$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_243$3$634645340582930069(self){
  true
}


struct_predicate ref$closure$0_243$3$634645340582930069(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_243$3$634645340582930069(self.val_ref), write)) && (true))
}


method m_shl_v(2 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    __t21: Bool
    _preserve$0: Ref(AuxRef)
    __t22: Bool
    __t23: Bool
    __t24: Bool
    __t25: Bool
    _old$l15$0: Ref(bool)
    __t26: Bool
    __t27: Bool
    __t28: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(usize)
    _3: Ref(m_BoolArr32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_245$3$13114848456984105119)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_248$3$3859392265678673261)
    _16: Ref(ref$usize)
    _17: Ref(ref$usize)
    _18: Ref(tuple0$)
    _19: Ref(bool)
    _20: Ref(closure$0_252$3$2449336065822019816)
    _21: Ref(ref$usize)
    _22: Ref(ref$usize)
    _23: Ref(ref$m_BoolArr32$_beg_$_end_)
    _24: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _25: Ref(tuple0$)
    _26: Ref(bool)
    _27: Ref(closure$0_261$3$12351797966212270264)
    _28: Ref(ref$usize)
    _29: Ref(ref$m_BoolArr32$_beg_$_end_)
    _30: Ref(bool)
    _31: Ref(ref$m_BitVec32$_beg_$_end_)
    _32: Ref(usize)
    _33: Ref(usize)
    _34: Ref(usize)
    _35: Ref(tuple2$usize$bool)
    _36: Ref(ref$bool)
    _37: Ref(ref$m_BoolArr32$_beg_$_end_)
    _38: Ref(usize)
    _39: Ref(tuple2$usize$bool)
    _40: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#1}::shl_v"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:555:5: 585:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    __t16 := copy false
    __t17 := copy false
    __t18 := copy false
    __t19 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(usize(_2), write)) && (true)))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((usize$inv<Ref(usize),Bool>(_2)) && (true))
    inhale(Expr) ((0) <= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l23
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_ff8e2998b11947cea980d4b7c5a0c4b0_101: Int  :: ((((0) <= (_2_forall_ff8e2998b11947cea980d4b7c5a0c4b0_101)) && (((_2_forall_ff8e2998b11947cea980d4b7c5a0c4b0_101) < (32)) && (true))) && ((((old[pre]((unfolding acc(usize:None(_2), write) in _2.val_int))) <= (_2_forall_ff8e2998b11947cea980d4b7c5a0c4b0_101)) && (((!(false))?(((_2_forall_ff8e2998b11947cea980d4b7c5a0c4b0_101) - (old[pre]((unfolding acc(usize:None(_2), write) in _2.val_int)))) >= (0)):(false)) && (((!(false))?(((_2_forall_ff8e2998b11947cea980d4b7c5a0c4b0_101) - (old[pre]((unfolding acc(usize:None(_2), write) in _2.val_int)))) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_ff8e2998b11947cea980d4b7c5a0c4b0_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$0, (_2_forall_ff8e2998b11947cea980d4b7c5a0c4b0_101) - (old[pre]((unfolding acc(usize:None(_2), write) in _2.val_int)))))):(false))) && ((forall _2_forall_9740b3c02a394f0f87ba8c554487e436_101: Int  :: (((0) <= (_2_forall_9740b3c02a394f0f87ba8c554487e436_101)) && (((_2_forall_9740b3c02a394f0f87ba8c554487e436_101) < (old[pre]((unfolding acc(usize:None(_2), write) in _2.val_int)))) && (((_2_forall_9740b3c02a394f0f87ba8c554487e436_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_9740b3c02a394f0f87ba8c554487e436_101)))) && (true))
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BoolArr32::zero() -> [return: bb1, unwind: bb25]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101: Int  :: (((0) <= (_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)) && (((_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = _2
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    unfold acc(usize:None(_2), write)
    _4.val_int := copy _2.val_int
    label l2
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb24]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l3
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t20 := copy _7.val_bool
    GotoSwitch([(Local(__t20: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l4 // 7
    // ========== l4 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:33)
  label l5 // 8
    // ========== l5 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t21 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    fold acc(usize:None(_2), write)
    obtain acc(usize(_2), read)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && (((((unfolding acc(usize:None(_2), write) in _2.val_int)) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && ((forall _2_forall_977eda70ddb64558b9762160737aeda9_101: Int  :: ((((0) <= (_2_forall_977eda70ddb64558b9762160737aeda9_101)) && (((_2_forall_977eda70ddb64558b9762160737aeda9_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (((_2_forall_977eda70ddb64558b9762160737aeda9_101) >= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (true)))) && (((((unfolding acc(usize:None(_2), write) in _2.val_int)) <= (_2_forall_977eda70ddb64558b9762160737aeda9_101)) && (((!(false))?(((_2_forall_977eda70ddb64558b9762160737aeda9_101) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?(((_2_forall_977eda70ddb64558b9762160737aeda9_101) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_977eda70ddb64558b9762160737aeda9_101)) == ((unfolding acc(usize:None(_2), write) in m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, (_2_forall_977eda70ddb64558b9762160737aeda9_101) - (_2.val_int))))):(false))) && ((forall _2_forall_48ae03eed98344ae9367c48f0018be80_101: Int  :: (((0) <= (_2_forall_48ae03eed98344ae9367c48f0018be80_101)) && (((_2_forall_48ae03eed98344ae9367c48f0018be80_101) < ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (((_2_forall_48ae03eed98344ae9367c48f0018be80_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_48ae03eed98344ae9367c48f0018be80_101)))) && (true))))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    _30 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    _26 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    _35 := builtin$havoc_ref()
    _14 := builtin$havoc_ref()
    __t25 := builtin$havoc_bool()
    __t12 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    _4 := builtin$havoc_ref()
    __t5 := builtin$havoc_bool()
    _8 := builtin$havoc_ref()
    _19 := builtin$havoc_ref()
    _37 := builtin$havoc_ref()
    __t27 := builtin$havoc_bool()
    __t2 := builtin$havoc_bool()
    __t28 := builtin$havoc_bool()
    __t6 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    _38 := builtin$havoc_ref()
    __t17 := builtin$havoc_bool()
    _36 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    _39 := builtin$havoc_ref()
    __t14 := builtin$havoc_bool()
    __t22 := builtin$havoc_bool()
    _10 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    __t16 := builtin$havoc_bool()
    __t26 := builtin$havoc_bool()
    _31 := builtin$havoc_ref()
    _32 := builtin$havoc_ref()
    __t24 := builtin$havoc_bool()
    __t23 := builtin$havoc_bool()
    __t7 := builtin$havoc_bool()
    __t15 := builtin$havoc_bool()
    _7 := builtin$havoc_ref()
    _34 := builtin$havoc_ref()
    _33 := builtin$havoc_ref()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    inhale(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && (((((unfolding acc(usize:None(_2), write) in _2.val_int)) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && ((forall _2_forall_977eda70ddb64558b9762160737aeda9_101: Int  :: ((((0) <= (_2_forall_977eda70ddb64558b9762160737aeda9_101)) && (((_2_forall_977eda70ddb64558b9762160737aeda9_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (((_2_forall_977eda70ddb64558b9762160737aeda9_101) >= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (true)))) && (((((unfolding acc(usize:None(_2), write) in _2.val_int)) <= (_2_forall_977eda70ddb64558b9762160737aeda9_101)) && (((!(false))?(((_2_forall_977eda70ddb64558b9762160737aeda9_101) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?(((_2_forall_977eda70ddb64558b9762160737aeda9_101) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_977eda70ddb64558b9762160737aeda9_101)) == ((unfolding acc(usize:None(_2), write) in m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, (_2_forall_977eda70ddb64558b9762160737aeda9_101) - (_2.val_int))))):(false))) && ((forall _2_forall_48ae03eed98344ae9367c48f0018be80_101: Int  :: (((0) <= (_2_forall_48ae03eed98344ae9367c48f0018be80_101)) && (((_2_forall_48ae03eed98344ae9367c48f0018be80_101) < ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (((_2_forall_48ae03eed98344ae9367c48f0018be80_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_48ae03eed98344ae9367c48f0018be80_101)))) && (true))))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t22 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_18)
    // [mir] StorageLive(_19)
    // [mir] _19 = const false
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_bool, write)
    _19.val_bool := copy false
    // [mir] switchInt(move _19) -> [false: bb14, otherwise: bb13]
    __t23 := copy _19.val_bool
    // Ignore default target bb13, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:17)
  label loop2_group3_bb14 // 17
    // ========== loop2_group3_bb14 ==========
    __t10 := copy true
    // [mir] _18 = const ()
    // [mir] goto -> bb15
    Goto(cfg:18)
  label loop2_group3_bb15 // 18
    // ========== loop2_group3_bb15 ==========
    __t11 := copy true
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_18)
    // [mir] StorageLive(_25)
    // [mir] StorageLive(_26)
    // [mir] _26 = const false
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.val_bool, write)
    _26.val_bool := copy false
    // [mir] switchInt(move _26) -> [false: bb17, otherwise: bb16]
    __t24 := copy _26.val_bool
    // Ignore default target bb16, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:19)
  label loop2_group3_bb17 // 19
    // ========== loop2_group3_bb17 ==========
    __t12 := copy true
    // [mir] _25 = const ()
    // [mir] goto -> bb18
    Goto(cfg:20)
  label loop2_group3_bb18 // 20
    // ========== loop2_group3_bb18 ==========
    __t13 := copy true
    // [mir] StorageDead(_26)
    // [mir] StorageDead(_25)
    // [mir] StorageLive(_30)
    // [mir] StorageLive(_31)
    // [mir] _31 = &'_ (*_1)
    _31 := builtin$havoc_ref()
    inhale(Stmt) acc(_31.val_ref, write)
    _31.val_ref := borrow _1.val_ref // L13
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_31.val_ref), read)
    label l6
    // [mir] StorageLive(_32)
    // [mir] StorageLive(_33)
    // [mir] _33 = _4
    _33 := builtin$havoc_ref()
    inhale(Stmt) acc(_33.val_int, write)
    unfold acc(usize:None(_4), write)
    _33.val_int := copy _4.val_int
    label l7
    // [mir] StorageLive(_34)
    // [mir] _34 = _2
    _34 := builtin$havoc_ref()
    inhale(Stmt) acc(_34.val_int, write)
    unfold acc(usize:None(_2), write)
    _34.val_int := copy _2.val_int
    label l8
    // [mir] _35 = CheckedSub(_33, _34)
    _35 := builtin$havoc_ref()
    inhale(Stmt) acc(_35.tuple_0, write)
    inhale(Stmt) acc(_35.tuple_0.val_int, write)
    inhale(Stmt) acc(_35.tuple_1, write)
    inhale(Stmt) acc(_35.tuple_1.val_bool, write)
    _35.tuple_0.val_int := copy (_33.val_int) - (_34.val_int)
    _35.tuple_1.val_bool := copy false
    // [mir] assert(!move (_35.1: bool), "attempt to compute `{} - {}`, which would overflow", move _33, move _34) -> [success: bb19, unwind: bb24]
    __t25 := copy _35.tuple_1.val_bool
    // Rust assertion: attempt to subtract with overflow
    assert(Stmt) !(__t25)
    Goto(cfg:21)
  label loop2_group3_bb19 // 21
    // ========== loop2_group3_bb19 ==========
    __t14 := copy true
    // [mir] _32 = move (_35.0: usize)
    _32 := move _35.tuple_0
    label l9
    // [mir] StorageDead(_34)
    // [mir] StorageDead(_33)
    // [mir] _30 = BitVec32::lookup(move _31, move _32) -> [return: bb20, unwind: bb24]
    label l10
    _30 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_30), write)
    unfold acc(bool:None(_30), write)
    inhale(Stmt) (_30.val_bool) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_31.val_ref, _32.val_int))
    transfer perm _31.val_ref --> old[l10](_31.val_ref) // unchecked: false
    Goto(cfg:22)
  label l11 // 22
    // ========== l11 ==========
    // MIR edge bb19 --> bb20
    // Expire borrows
    // expire_borrows ReborrowingDAG(L14,L13,)

    if (__t14) && (true) {
    // expire loan L14
} else {}
    if (__t13) && ((__t14) && (true)) {
    // expire loan L13
    transfer perm old[l10](_31.val_ref) --> old[l6](_31.val_ref) // unchecked: false
    exhale acc(m_BitVec32$_beg_$_end_(old[l6](_31.val_ref)), read)
} else {}
    Goto(cfg:23)
  label loop2_group3_bb20 // 23
    // ========== loop2_group3_bb20 ==========
    __t15 := copy true
    // [mir] StorageDead(_32)
    // [mir] StorageDead(_31)
    // [mir] StorageLive(_36)
    // [mir] StorageLive(_37)
    // [mir] _37 = &'_ mut _3
    _37 := builtin$havoc_ref()
    inhale(Stmt) acc(_37.val_ref, write)
    _37.val_ref := mut borrow _3 // L9
    label l12
    // [mir] StorageLive(_38)
    // [mir] _38 = _4
    _38 := builtin$havoc_ref()
    inhale(Stmt) acc(_38.val_int, write)
    _38.val_int := copy _4.val_int
    label l13
    // [mir] _36 = BoolArr32::index_mut(move _37, move _38) -> [return: bb21, unwind: bb24]
    label l14
    assert(Stmt) (((0) <= (_38.val_int)) && (((_38.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_37.val_ref))) && (true))) && (true)
    fold acc(usize:None(_38), write)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_37)) && ((usize$inv<Ref(usize),Bool>(_38)) && (true))
    exhale (acc(_37.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_37.val_ref), write)) && ((acc(usize(_38), write)) && (true)))
    _36 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_36.val_ref, write)) && (acc(bool(_36.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_36)) && (true)
    inhale(Expr) (((unfolding acc(bool:None(_36.val_ref), write) in _36.val_ref.val_bool)) == (old[l14](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_37.val_ref, _38.val_int)))) && (true)
    exhale true
    label l15
    Goto(cfg:24)
  label loop2_group3_bb21 // 24
    // ========== loop2_group3_bb21 ==========
    __t16 := copy true
    // [mir] StorageDead(_38)
    // [mir] StorageDead(_37)
    // [mir] (*_36) = move _30
    _36.val_ref := move _30
    label l16
    // expire_borrows ReborrowingDAG(L15,L16,L9,)

    if (__t15) && (true) {
    // expire loan L15
    _old$l15$0 := move _36.val_ref
    inhale(Stmt) (((acc(bool(_old$l15$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l15$0))) && ((true) && (true))) Some(L15) --* (((acc(m_BoolArr32$_beg_$_end_(old[l14](_37.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l14](_37.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_37.val_ref))) == (old[l14](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_37.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_37.val_ref), old[l14](_38.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l15$0), write) in _old$l15$0.val_bool)))) && ((forall _2_forall_5be58431c8f94233ac0b32ea01095bd7_103: Int  :: (((0) <= (_2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) && (((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_37.val_ref)))) && ((!((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) == (old[l14](_38.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_37.val_ref), _2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) == (old[l14](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_37.val_ref, _2_forall_5be58431c8f94233ac0b32ea01095bd7_103))))) && (true)))) && (true)))
    fold acc(bool:None(_old$l15$0), write)
    apply[L15] ((acc(bool(_old$l15$0), write)) && (bool$inv<Ref(bool),Bool>(_old$l15$0))) && ((true) && (true)) --* ((acc(m_BoolArr32$_beg_$_end_(old[l14](_37.val_ref)), write)) && (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(old[l14](_37.val_ref)))) && ((((m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_37.val_ref))) == (old[l14](m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_37.val_ref)))) && (((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_37.val_ref), old[l14](_38.val_int))) == (old[lhs]((unfolding acc(bool:None(_old$l15$0), write) in _old$l15$0.val_bool)))) && ((forall _2_forall_5be58431c8f94233ac0b32ea01095bd7_103: Int  :: (((0) <= (_2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) && (((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(old[l14](_37.val_ref)))) && ((!((_2_forall_5be58431c8f94233ac0b32ea01095bd7_103) == (old[l14](_38.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(old[l14](_37.val_ref), _2_forall_5be58431c8f94233ac0b32ea01095bd7_103)) == (old[l14](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_37.val_ref, _2_forall_5be58431c8f94233ac0b32ea01095bd7_103))))) && (true)))) && (true))
    
} else {}
    if (__t15) && ((__t15) && (true)) {
    // expire loan L16
} else {}
    if (__t15) && ((__t15) && ((__t15) && (true))) {
    // expire loan L9
    transfer perm old[l14](_37.val_ref) --> old[l12](_37.val_ref) // unchecked: false
    transfer perm old[l12](_37.val_ref) --> _3 // unchecked: false
} else {}
    // [mir] StorageDead(_30)
    // [mir] StorageDead(_36)
    // [mir] _39 = CheckedAdd(_4, const 1_usize)
    _39 := builtin$havoc_ref()
    inhale(Stmt) acc(_39.tuple_0, write)
    inhale(Stmt) acc(_39.tuple_0.val_int, write)
    inhale(Stmt) acc(_39.tuple_1, write)
    inhale(Stmt) acc(_39.tuple_1.val_bool, write)
    _39.tuple_0.val_int := copy (_4.val_int) + (1)
    _39.tuple_1.val_bool := copy false
    // [mir] assert(!move (_39.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb22, unwind: bb24]
    __t26 := copy _39.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t26)
    Goto(cfg:25)
  label loop2_group3_bb22 // 25
    // ========== loop2_group3_bb22 ==========
    __t17 := copy true
    // [mir] _4 = move (_39.0: usize)
    _4 := move _39.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:26)
  label loop2_group4_bb2 // 26
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb24]
    Goto(cfg:27)
  label loop2_group4_bb3 // 27
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l18
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t27 := copy _7.val_bool
    GotoSwitch([(Local(__t27: Bool, Position { line: 0, column: 0, id: 0 }), cfg:29)], cfg:28)
  label l19 // 28
    // ========== l19 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:35)
  label l20 // 29
    // ========== l20 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:30)
  label loop2_group5_bb4 // 30
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:31)
  label loop2_group5_bb6 // 31
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t28 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:32)
  label loop2_end_body // 32
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    fold acc(usize:None(_2), write)
    obtain acc(usize(_2), read)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && (((((unfolding acc(usize:None(_2), write) in _2.val_int)) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?((((unfolding acc(usize:None(_4), write) in _4.val_int)) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && ((forall _2_forall_977eda70ddb64558b9762160737aeda9_101: Int  :: ((((0) <= (_2_forall_977eda70ddb64558b9762160737aeda9_101)) && (((_2_forall_977eda70ddb64558b9762160737aeda9_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (((_2_forall_977eda70ddb64558b9762160737aeda9_101) >= ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (true)))) && (((((unfolding acc(usize:None(_2), write) in _2.val_int)) <= (_2_forall_977eda70ddb64558b9762160737aeda9_101)) && (((!(false))?(((_2_forall_977eda70ddb64558b9762160737aeda9_101) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) >= (0)):(false)) && (((!(false))?(((_2_forall_977eda70ddb64558b9762160737aeda9_101) - ((unfolding acc(usize:None(_2), write) in _2.val_int))) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_977eda70ddb64558b9762160737aeda9_101)) == ((unfolding acc(usize:None(_2), write) in m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, (_2_forall_977eda70ddb64558b9762160737aeda9_101) - (_2.val_int))))):(false))) && ((forall _2_forall_48ae03eed98344ae9367c48f0018be80_101: Int  :: (((0) <= (_2_forall_48ae03eed98344ae9367c48f0018be80_101)) && (((_2_forall_48ae03eed98344ae9367c48f0018be80_101) < ((unfolding acc(usize:None(_2), write) in _2.val_int))) && (((_2_forall_48ae03eed98344ae9367c48f0018be80_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_48ae03eed98344ae9367c48f0018be80_101)))) && (true))))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 33
    // ========== bb5 ==========
    __t18 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l21
    // [mir] StorageDead(_4)
    // [mir] drop(_3) -> [return: bb23, unwind: bb25]
    Goto(cfg:34)
  label bb23 // 34
    // ========== bb23 ==========
    __t19 := copy true
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l22 // 35
    // ========== l22 ==========
    // drop Acc(_36.val_ref, write) (Acc(_36.val_ref, write))
    // drop Acc(_32.val_int, write) (Acc(_32.val_int, write))
    // drop Acc(_31.val_ref, write) (Acc(_31.val_ref, write))
    // drop Acc(_35.tuple_1.val_bool, write) (Acc(_35.tuple_1.val_bool, write))
    // drop Acc(_35.tuple_0, write) (Acc(_35.tuple_0, write))
    // drop Acc(_26.val_bool, write) (Acc(_26.val_bool, write))
    // drop Acc(_39.tuple_0, write) (Acc(_39.tuple_0, write))
    // drop Acc(_39.tuple_1.val_bool, write) (Acc(_39.tuple_1.val_bool, write))
    // drop Acc(_14.val_bool, write) (Acc(_14.val_bool, write))
    // drop Acc(_34.val_int, write) (Acc(_34.val_int, write))
    // drop Acc(old[l6](_31.val_ref), write) (Acc(old[l6](_31.val_ref), write))
    // drop Acc(_33.val_int, write) (Acc(_33.val_int, write))
    // drop Acc(_19.val_bool, write) (Acc(_19.val_bool, write))
    // drop Acc(_35.tuple_1, write) (Acc(_35.tuple_1, write))
    // drop Acc(_39.tuple_1, write) (Acc(_39.tuple_1, write))
    Goto(cfg:33)
  label end_of_method
}


struct_predicate closure$0_290$3$13114848456984105119(self){
  true
}


struct_predicate closure$0_293$3$8125425184230690860(self){
  true
}


struct_predicate closure$0_291$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_291$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_291$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_290$3$13114848456984105119(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_290$3$13114848456984105119(self.val_ref), write)) && (true))
}


struct_predicate closure$0_292$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_292$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_292$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_295$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_295$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_295$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_294$3$7807866430840247371(self){
  true
}


struct_predicate ref$closure$0_294$3$7807866430840247371(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_294$3$7807866430840247371(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_293$3$8125425184230690860(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_293$3$8125425184230690860(self.val_ref), write)) && (true))
}


struct_predicate closure$0_296$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_296$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_296$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_297$3$15496538660126075396(self){
  true
}


struct_predicate ref$closure$0_297$3$15496538660126075396(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_297$3$15496538660126075396(self.val_ref), write)) && (true))
}


struct_predicate closure$0_286$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_286$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_286$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_285$3$8530025436341569256(self){
  true
}


struct_predicate ref$closure$0_285$3$8530025436341569256(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_285$3$8530025436341569256(self.val_ref), write)) && (true))
}


struct_predicate closure$0_287$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_287$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_287$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_288$3$15496538660126075396(self){
  true
}


struct_predicate ref$closure$0_288$3$15496538660126075396(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_288$3$15496538660126075396(self.val_ref), write)) && (true))
}


method m_or_v(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _old$pre$1: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(ref$m_BitVec32$_beg_$_end_)
    _3: Ref(m_BitVec32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_290$3$13114848456984105119)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_293$3$8125425184230690860)
    _16: Ref(ref$usize)
    _17: Ref(ref$m_BitVec32$_beg_$_end_)
    _18: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _19: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _20: Ref(tuple0$)
    _21: Ref(ref$m_BitVec32$_beg_$_end_)
    _22: Ref(usize)
    _23: Ref(bool)
    _24: Ref(bool)
    _25: Ref(ref$m_BitVec32$_beg_$_end_)
    _26: Ref(usize)
    _27: Ref(bool)
    _28: Ref(ref$m_BitVec32$_beg_$_end_)
    _29: Ref(usize)
    _30: Ref(tuple2$usize$bool)
    _31: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#1}::or_v"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:672:5: 686:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l24
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BitVec32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_ac19743804eb42efb3ab27e61ebb36b6_101: Int  :: (((0) <= (_2_forall_ac19743804eb42efb3ab27e61ebb36b6_101)) && (((_2_forall_ac19743804eb42efb3ab27e61ebb36b6_101) < (32)) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_0, _2_forall_ac19743804eb42efb3ab27e61ebb36b6_101)) == ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$0, _2_forall_ac19743804eb42efb3ab27e61ebb36b6_101)) || (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$1, _2_forall_ac19743804eb42efb3ab27e61ebb36b6_101))))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BitVec32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BitVec32::zero() -> [return: bb1, unwind: bb17]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_6e18d74b08724366806ddc03a6946ae9_101: Int  :: (((0) <= (_2_forall_6e18d74b08724366806ddc03a6946ae9_101)) && (((_2_forall_6e18d74b08724366806ddc03a6946ae9_101) < (32)) && (true))) ==> (!(m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_6e18d74b08724366806ddc03a6946ae9_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = const 0_usize
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy 0
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l2
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t15 := copy _7.val_bool
    GotoSwitch([(Local(__t15: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t16 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$1 := ghost _2.val_ref
    _preserve$0 := ghost _1.val_ref
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_7392d10ce94c40ce83334fc5297c310f_101: Int  :: (((0) <= (_2_forall_7392d10ce94c40ce83334fc5297c310f_101)) && (((_2_forall_7392d10ce94c40ce83334fc5297c310f_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_7392d10ce94c40ce83334fc5297c310f_101)) == ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_7392d10ce94c40ce83334fc5297c310f_101)) || (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_7392d10ce94c40ce83334fc5297c310f_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    __t5 := builtin$havoc_bool()
    _8 := builtin$havoc_ref()
    __t18 := builtin$havoc_bool()
    _30 := builtin$havoc_ref()
    _29 := builtin$havoc_ref()
    __t13 := builtin$havoc_bool()
    _10 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    __t10 := builtin$havoc_bool()
    _7 := builtin$havoc_ref()
    __t11 := builtin$havoc_bool()
    _24 := builtin$havoc_ref()
    __t12 := builtin$havoc_bool()
    _23 := builtin$havoc_ref()
    _26 := builtin$havoc_ref()
    _21 := builtin$havoc_ref()
    _4 := builtin$havoc_ref()
    __t6 := builtin$havoc_bool()
    __t8 := builtin$havoc_bool()
    __t3 := builtin$havoc_bool()
    _22 := builtin$havoc_ref()
    _25 := builtin$havoc_ref()
    __t17 := builtin$havoc_bool()
    _14 := builtin$havoc_ref()
    _20 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    __t20 := builtin$havoc_bool()
    __t19 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    _27 := builtin$havoc_ref()
    _28 := builtin$havoc_ref()
    __t2 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_7392d10ce94c40ce83334fc5297c310f_101: Int  :: (((0) <= (_2_forall_7392d10ce94c40ce83334fc5297c310f_101)) && (((_2_forall_7392d10ce94c40ce83334fc5297c310f_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_7392d10ce94c40ce83334fc5297c310f_101)) == ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_7392d10ce94c40ce83334fc5297c310f_101)) || (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_7392d10ce94c40ce83334fc5297c310f_101))))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t17 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'_ mut _3
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_ref, write)
    _21.val_ref := mut borrow _3 // L5
    label l5
    // [mir] StorageLive(_22)
    // [mir] _22 = _4
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_int, write)
    unfold acc(usize:None(_4), write)
    _22.val_int := copy _4.val_int
    label l6
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] StorageLive(_25)
    // [mir] _25 = &'_ (*_1)
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_ref, write)
    _25.val_ref := borrow _1.val_ref // L11
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_25.val_ref), read)
    label l7
    // [mir] StorageLive(_26)
    // [mir] _26 = _4
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.val_int, write)
    _26.val_int := copy _4.val_int
    label l8
    // [mir] _24 = BitVec32::lookup(move _25, move _26) -> [return: bb13, unwind: bb17]
    label l9
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_24), write)
    unfold acc(bool:None(_24), write)
    inhale(Stmt) (_24.val_bool) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_25.val_ref, _26.val_int))
    transfer perm _25.val_ref --> old[l9](_25.val_ref) // unchecked: false
    Goto(cfg:17)
  label l10 // 17
    // ========== l10 ==========
    // MIR edge bb12 --> bb13
    // Expire borrows
    // expire_borrows ReborrowingDAG(L10,L11,)

    if (__t9) && (true) {
    // expire loan L10
} else {}
    if (__t9) && ((__t9) && (true)) {
    // expire loan L11
    transfer perm old[l9](_25.val_ref) --> old[l7](_25.val_ref) // unchecked: false
    exhale acc(m_BitVec32$_beg_$_end_(old[l7](_25.val_ref)), read)
} else {}
    Goto(cfg:18)
  label loop2_group3_bb13 // 18
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_26)
    // [mir] StorageDead(_25)
    // [mir] StorageLive(_27)
    // [mir] StorageLive(_28)
    // [mir] _28 = &'_ (*_2)
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_ref, write)
    _28.val_ref := borrow _2.val_ref // L12
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_28.val_ref), read)
    label l11
    // [mir] StorageLive(_29)
    // [mir] _29 = _4
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.val_int, write)
    _29.val_int := copy _4.val_int
    label l12
    // [mir] _27 = BitVec32::lookup(move _28, move _29) -> [return: bb14, unwind: bb17]
    label l13
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_27), write)
    unfold acc(bool:None(_27), write)
    inhale(Stmt) (_27.val_bool) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_28.val_ref, _29.val_int))
    transfer perm _28.val_ref --> old[l13](_28.val_ref) // unchecked: false
    Goto(cfg:19)
  label l14 // 19
    // ========== l14 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    // expire_borrows ReborrowingDAG(L13,L12,)

    if (__t10) && (true) {
    // expire loan L13
} else {}
    if (__t10) && ((__t10) && (true)) {
    // expire loan L12
    transfer perm old[l13](_28.val_ref) --> old[l11](_28.val_ref) // unchecked: false
    exhale acc(m_BitVec32$_beg_$_end_(old[l11](_28.val_ref)), read)
} else {}
    Goto(cfg:20)
  label loop2_group3_bb14 // 20
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_29)
    // [mir] StorageDead(_28)
    // [mir] _23 = BitOr(move _24, move _27)
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(_23.val_bool, write)
    _23.val_bool := copy (_24.val_bool) || (_27.val_bool)
    // [mir] StorageDead(_27)
    // [mir] StorageDead(_24)
    // [mir] _20 = BitVec32::set_bit(move _21, move _22, move _23) -> [return: bb15, unwind: bb17]
    label l15
    assert(Stmt) (((0) <= (_22.val_int)) && (((_22.val_int) < (m_main$$$opencur$impl$sharp$1$closecur$$$len<Ref(m_BitVec32$_beg_$_end_),Int>(_21.val_ref))) && (true))) && (true)
    fold acc(usize:None(_22), write)
    fold acc(bool:None(_23), write)
    assert(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_21)) && ((usize$inv<Ref(usize),Bool>(_22)) && ((bool$inv<Ref(bool),Bool>(_23)) && (true)))
    exhale (acc(_21.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_21.val_ref), write)) && ((acc(usize(_22), write)) && ((acc(bool(_23), write)) && (true))))
    _20 := builtin$havoc_ref()
    inhale(Stmt) (acc(m_BitVec32$_beg_$_end_(old[l15](_21.val_ref)), write)) && (true)
    inhale(Stmt) acc(tuple0$(_20), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(old[l15](_21.val_ref))) && ((tuple0$$inv<Ref(tuple0$),Bool>(_20)) && (true))
    inhale(Expr) ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l15](_21.val_ref), old[l15](_22.val_int))) == (old[l15](_23.val_bool))) && ((forall _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101: Int  :: (((0) <= (_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101)) && (((_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101) < (32)) && ((!((_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101) == (old[l15](_22.val_int)))) && (true)))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l15](_21.val_ref), _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101)) == (old[l15](m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_21.val_ref, _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101))))) && (true))
    exhale true
    label l16
    Goto(cfg:21)
  label l17 // 21
    // ========== l17 ==========
    // MIR edge bb14 --> bb15
    // Expire borrows
    // expire_borrows ReborrowingDAG(L14,L5,)

    if (__t11) && (true) {
    // expire loan L14
} else {}
    if (__t9) && ((__t11) && (true)) {
    // expire loan L5
    transfer perm old[l15](_21.val_ref) --> old[l5](_21.val_ref) // unchecked: false
    transfer perm old[l5](_21.val_ref) --> _3 // unchecked: false
} else {}
    Goto(cfg:22)
  label loop2_group3_bb15 // 22
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageDead(_20)
    // [mir] _30 = CheckedAdd(_4, const 1_usize)
    _30 := builtin$havoc_ref()
    inhale(Stmt) acc(_30.tuple_0, write)
    inhale(Stmt) acc(_30.tuple_0.val_int, write)
    inhale(Stmt) acc(_30.tuple_1, write)
    inhale(Stmt) acc(_30.tuple_1.val_bool, write)
    _30.tuple_0.val_int := copy (_4.val_int) + (1)
    _30.tuple_1.val_bool := copy false
    // [mir] assert(!move (_30.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb16, unwind: bb17]
    __t18 := copy _30.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t18)
    Goto(cfg:23)
  label loop2_group3_bb16 // 23
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _4 = move (_30.0: usize)
    _4 := move _30.tuple_0
    label l18
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:24)
  label loop2_group4_bb2 // 24
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:25)
  label loop2_group4_bb3 // 25
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l19
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t19 := copy _7.val_bool
    GotoSwitch([(Local(__t19: Bool, Position { line: 0, column: 0, id: 0 }), cfg:27)], cfg:26)
  label l20 // 26
    // ========== l20 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:32)
  label l21 // 27
    // ========== l21 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:28)
  label loop2_group5_bb4 // 28
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:29)
  label loop2_group5_bb6 // 29
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t20 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:30)
  label loop2_end_body // 30
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_7392d10ce94c40ce83334fc5297c310f_101: Int  :: (((0) <= (_2_forall_7392d10ce94c40ce83334fc5297c310f_101)) && (((_2_forall_7392d10ce94c40ce83334fc5297c310f_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_7392d10ce94c40ce83334fc5297c310f_101)) == ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_7392d10ce94c40ce83334fc5297c310f_101)) || (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_7392d10ce94c40ce83334fc5297c310f_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 31
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l22
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l23 // 32
    // ========== l23 ==========
    // drop Acc(_24.val_bool, write) (Acc(_24.val_bool, write))
    // drop Acc(_30.tuple_0, write) (Acc(_30.tuple_0, write))
    // drop Acc(_29.val_int, write) (Acc(_29.val_int, write))
    // drop Acc(_25.val_ref, write) (Acc(_25.val_ref, write))
    // drop Acc(old[l11](_28.val_ref), write) (Acc(old[l11](_28.val_ref), write))
    // drop Acc(_27.val_bool, write) (Acc(_27.val_bool, write))
    // drop Acc(_14.val_bool, write) (Acc(_14.val_bool, write))
    // drop Acc(_30.tuple_1.val_bool, write) (Acc(_30.tuple_1.val_bool, write))
    // drop Acc(_28.val_ref, write) (Acc(_28.val_ref, write))
    // drop Acc(old[l7](_25.val_ref), write) (Acc(old[l7](_25.val_ref), write))
    // drop Acc(_26.val_int, write) (Acc(_26.val_int, write))
    // drop Pred(_20, write) (Pred(_20, write))
    // drop Acc(_30.tuple_1, write) (Acc(_30.tuple_1, write))
    Goto(cfg:31)
  label end_of_method
}


struct_predicate closure$0_310$3$13114848456984105119(self){
  true
}


struct_predicate closure$0_313$3$8125425184230690860(self){
  true
}


struct_predicate closure$0_311$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_311$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_311$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_310$3$13114848456984105119(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_310$3$13114848456984105119(self.val_ref), write)) && (true))
}


struct_predicate closure$0_312$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_312$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_312$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_315$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_315$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_315$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_314$3$7807866430840247371(self){
  true
}


struct_predicate ref$closure$0_314$3$7807866430840247371(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_314$3$7807866430840247371(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_313$3$8125425184230690860(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_313$3$8125425184230690860(self.val_ref), write)) && (true))
}


struct_predicate closure$0_316$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_316$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_316$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_317$3$15496538660126075396(self){
  true
}


struct_predicate ref$closure$0_317$3$15496538660126075396(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_317$3$15496538660126075396(self.val_ref), write)) && (true))
}


struct_predicate closure$0_306$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_306$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_306$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_305$3$8530025436341569256(self){
  true
}


struct_predicate ref$closure$0_305$3$8530025436341569256(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_305$3$8530025436341569256(self.val_ref), write)) && (true))
}


struct_predicate closure$0_307$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_307$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_307$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_308$3$15496538660126075396(self){
  true
}


struct_predicate ref$closure$0_308$3$15496538660126075396(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_308$3$15496538660126075396(self.val_ref), write)) && (true))
}


method m_and_v(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _old$pre$1: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(ref$m_BitVec32$_beg_$_end_)
    _3: Ref(m_BitVec32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_310$3$13114848456984105119)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_313$3$8125425184230690860)
    _16: Ref(ref$usize)
    _17: Ref(ref$m_BitVec32$_beg_$_end_)
    _18: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _19: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _20: Ref(tuple0$)
    _21: Ref(ref$m_BitVec32$_beg_$_end_)
    _22: Ref(usize)
    _23: Ref(bool)
    _24: Ref(bool)
    _25: Ref(ref$m_BitVec32$_beg_$_end_)
    _26: Ref(usize)
    _27: Ref(bool)
    _28: Ref(ref$m_BitVec32$_beg_$_end_)
    _29: Ref(usize)
    _30: Ref(tuple2$usize$bool)
    _31: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#1}::and_v"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:704:5: 718:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l24
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BitVec32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_4db936164c6c46ce900e7b58d4485a2f_101: Int  :: (((0) <= (_2_forall_4db936164c6c46ce900e7b58d4485a2f_101)) && (((_2_forall_4db936164c6c46ce900e7b58d4485a2f_101) < (32)) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_0, _2_forall_4db936164c6c46ce900e7b58d4485a2f_101)) == ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$0, _2_forall_4db936164c6c46ce900e7b58d4485a2f_101)) && (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$1, _2_forall_4db936164c6c46ce900e7b58d4485a2f_101))))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BitVec32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BitVec32::zero() -> [return: bb1, unwind: bb17]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_6e18d74b08724366806ddc03a6946ae9_101: Int  :: (((0) <= (_2_forall_6e18d74b08724366806ddc03a6946ae9_101)) && (((_2_forall_6e18d74b08724366806ddc03a6946ae9_101) < (32)) && (true))) ==> (!(m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_6e18d74b08724366806ddc03a6946ae9_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = const 0_usize
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy 0
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l2
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t15 := copy _7.val_bool
    GotoSwitch([(Local(__t15: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t16 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$1 := ghost _2.val_ref
    _preserve$0 := ghost _1.val_ref
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101: Int  :: (((0) <= (_2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101)) && (((_2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101)) == ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101)) && (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    _8 := builtin$havoc_ref()
    __t20 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    _22 := builtin$havoc_ref()
    _7 := builtin$havoc_ref()
    _21 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    _27 := builtin$havoc_ref()
    _26 := builtin$havoc_ref()
    _28 := builtin$havoc_ref()
    _10 := builtin$havoc_ref()
    __t18 := builtin$havoc_bool()
    _20 := builtin$havoc_ref()
    __t6 := builtin$havoc_bool()
    __t4 := builtin$havoc_bool()
    __t17 := builtin$havoc_bool()
    __t3 := builtin$havoc_bool()
    __t2 := builtin$havoc_bool()
    _24 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    _4 := builtin$havoc_ref()
    _23 := builtin$havoc_ref()
    _30 := builtin$havoc_ref()
    __t12 := builtin$havoc_bool()
    __t10 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    _25 := builtin$havoc_ref()
    _14 := builtin$havoc_ref()
    _29 := builtin$havoc_ref()
    __t19 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101: Int  :: (((0) <= (_2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101)) && (((_2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101)) == ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101)) && (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101))))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t17 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'_ mut _3
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_ref, write)
    _21.val_ref := mut borrow _3 // L5
    label l5
    // [mir] StorageLive(_22)
    // [mir] _22 = _4
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_int, write)
    unfold acc(usize:None(_4), write)
    _22.val_int := copy _4.val_int
    label l6
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] StorageLive(_25)
    // [mir] _25 = &'_ (*_1)
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_ref, write)
    _25.val_ref := borrow _1.val_ref // L13
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_25.val_ref), read)
    label l7
    // [mir] StorageLive(_26)
    // [mir] _26 = _4
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.val_int, write)
    _26.val_int := copy _4.val_int
    label l8
    // [mir] _24 = BitVec32::lookup(move _25, move _26) -> [return: bb13, unwind: bb17]
    label l9
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_24), write)
    unfold acc(bool:None(_24), write)
    inhale(Stmt) (_24.val_bool) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_25.val_ref, _26.val_int))
    transfer perm _25.val_ref --> old[l9](_25.val_ref) // unchecked: false
    Goto(cfg:17)
  label l10 // 17
    // ========== l10 ==========
    // MIR edge bb12 --> bb13
    // Expire borrows
    // expire_borrows ReborrowingDAG(L11,L13,)

    if (__t9) && (true) {
    // expire loan L11
} else {}
    if (__t9) && ((__t9) && (true)) {
    // expire loan L13
    transfer perm old[l9](_25.val_ref) --> old[l7](_25.val_ref) // unchecked: false
    exhale acc(m_BitVec32$_beg_$_end_(old[l7](_25.val_ref)), read)
} else {}
    Goto(cfg:18)
  label loop2_group3_bb13 // 18
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_26)
    // [mir] StorageDead(_25)
    // [mir] StorageLive(_27)
    // [mir] StorageLive(_28)
    // [mir] _28 = &'_ (*_2)
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_ref, write)
    _28.val_ref := borrow _2.val_ref // L14
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_28.val_ref), read)
    label l11
    // [mir] StorageLive(_29)
    // [mir] _29 = _4
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.val_int, write)
    _29.val_int := copy _4.val_int
    label l12
    // [mir] _27 = BitVec32::lookup(move _28, move _29) -> [return: bb14, unwind: bb17]
    label l13
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_27), write)
    unfold acc(bool:None(_27), write)
    inhale(Stmt) (_27.val_bool) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_28.val_ref, _29.val_int))
    transfer perm _28.val_ref --> old[l13](_28.val_ref) // unchecked: false
    Goto(cfg:19)
  label l14 // 19
    // ========== l14 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    // expire_borrows ReborrowingDAG(L12,L14,)

    if (__t10) && (true) {
    // expire loan L12
} else {}
    if (__t10) && ((__t10) && (true)) {
    // expire loan L14
    transfer perm old[l13](_28.val_ref) --> old[l11](_28.val_ref) // unchecked: false
    exhale acc(m_BitVec32$_beg_$_end_(old[l11](_28.val_ref)), read)
} else {}
    Goto(cfg:20)
  label loop2_group3_bb14 // 20
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_29)
    // [mir] StorageDead(_28)
    // [mir] _23 = BitAnd(move _24, move _27)
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(_23.val_bool, write)
    _23.val_bool := copy (_24.val_bool) && (_27.val_bool)
    // [mir] StorageDead(_27)
    // [mir] StorageDead(_24)
    // [mir] _20 = BitVec32::set_bit(move _21, move _22, move _23) -> [return: bb15, unwind: bb17]
    label l15
    assert(Stmt) (((0) <= (_22.val_int)) && (((_22.val_int) < (m_main$$$opencur$impl$sharp$1$closecur$$$len<Ref(m_BitVec32$_beg_$_end_),Int>(_21.val_ref))) && (true))) && (true)
    fold acc(usize:None(_22), write)
    fold acc(bool:None(_23), write)
    assert(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_21)) && ((usize$inv<Ref(usize),Bool>(_22)) && ((bool$inv<Ref(bool),Bool>(_23)) && (true)))
    exhale (acc(_21.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_21.val_ref), write)) && ((acc(usize(_22), write)) && ((acc(bool(_23), write)) && (true))))
    _20 := builtin$havoc_ref()
    inhale(Stmt) (acc(m_BitVec32$_beg_$_end_(old[l15](_21.val_ref)), write)) && (true)
    inhale(Stmt) acc(tuple0$(_20), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(old[l15](_21.val_ref))) && ((tuple0$$inv<Ref(tuple0$),Bool>(_20)) && (true))
    inhale(Expr) ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l15](_21.val_ref), old[l15](_22.val_int))) == (old[l15](_23.val_bool))) && ((forall _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101: Int  :: (((0) <= (_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101)) && (((_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101) < (32)) && ((!((_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101) == (old[l15](_22.val_int)))) && (true)))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l15](_21.val_ref), _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101)) == (old[l15](m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_21.val_ref, _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101))))) && (true))
    exhale true
    label l16
    Goto(cfg:21)
  label l17 // 21
    // ========== l17 ==========
    // MIR edge bb14 --> bb15
    // Expire borrows
    // expire_borrows ReborrowingDAG(L10,L5,)

    if (__t11) && (true) {
    // expire loan L10
} else {}
    if (__t9) && ((__t11) && (true)) {
    // expire loan L5
    transfer perm old[l15](_21.val_ref) --> old[l5](_21.val_ref) // unchecked: false
    transfer perm old[l5](_21.val_ref) --> _3 // unchecked: false
} else {}
    Goto(cfg:22)
  label loop2_group3_bb15 // 22
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageDead(_20)
    // [mir] _30 = CheckedAdd(_4, const 1_usize)
    _30 := builtin$havoc_ref()
    inhale(Stmt) acc(_30.tuple_0, write)
    inhale(Stmt) acc(_30.tuple_0.val_int, write)
    inhale(Stmt) acc(_30.tuple_1, write)
    inhale(Stmt) acc(_30.tuple_1.val_bool, write)
    _30.tuple_0.val_int := copy (_4.val_int) + (1)
    _30.tuple_1.val_bool := copy false
    // [mir] assert(!move (_30.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb16, unwind: bb17]
    __t18 := copy _30.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t18)
    Goto(cfg:23)
  label loop2_group3_bb16 // 23
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _4 = move (_30.0: usize)
    _4 := move _30.tuple_0
    label l18
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:24)
  label loop2_group4_bb2 // 24
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:25)
  label loop2_group4_bb3 // 25
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l19
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t19 := copy _7.val_bool
    GotoSwitch([(Local(__t19: Bool, Position { line: 0, column: 0, id: 0 }), cfg:27)], cfg:26)
  label l20 // 26
    // ========== l20 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:32)
  label l21 // 27
    // ========== l21 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:28)
  label loop2_group5_bb4 // 28
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:29)
  label loop2_group5_bb6 // 29
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t20 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:30)
  label loop2_end_body // 30
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101: Int  :: (((0) <= (_2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101)) && (((_2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101)) == ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101)) && (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 31
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l22
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l23 // 32
    // ========== l23 ==========
    // drop Acc(old[l7](_25.val_ref), write) (Acc(old[l7](_25.val_ref), write))
    // drop Acc(_27.val_bool, write) (Acc(_27.val_bool, write))
    // drop Acc(_30.tuple_0, write) (Acc(_30.tuple_0, write))
    // drop Acc(_30.tuple_1.val_bool, write) (Acc(_30.tuple_1.val_bool, write))
    // drop Acc(_25.val_ref, write) (Acc(_25.val_ref, write))
    // drop Acc(_14.val_bool, write) (Acc(_14.val_bool, write))
    // drop Acc(_29.val_int, write) (Acc(_29.val_int, write))
    // drop Acc(_28.val_ref, write) (Acc(_28.val_ref, write))
    // drop Acc(_24.val_bool, write) (Acc(_24.val_bool, write))
    // drop Acc(_26.val_int, write) (Acc(_26.val_int, write))
    // drop Acc(old[l11](_28.val_ref), write) (Acc(old[l11](_28.val_ref), write))
    // drop Pred(_20, write) (Pred(_20, write))
    // drop Acc(_30.tuple_1, write) (Acc(_30.tuple_1, write))
    Goto(cfg:31)
  label end_of_method
}


struct_predicate closure$0_333$3$8125425184230690860(self){
  true
}


struct_predicate closure$0_330$3$13114848456984105119(self){
  true
}


struct_predicate closure$0_331$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_331$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_331$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_330$3$13114848456984105119(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_330$3$13114848456984105119(self.val_ref), write)) && (true))
}


struct_predicate closure$0_332$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_332$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_332$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_335$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_335$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_335$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_334$3$7807866430840247371(self){
  true
}


struct_predicate ref$closure$0_334$3$7807866430840247371(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_334$3$7807866430840247371(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_333$3$8125425184230690860(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_333$3$8125425184230690860(self.val_ref), write)) && (true))
}


struct_predicate closure$0_336$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_336$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_336$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_337$3$15496538660126075396(self){
  true
}


struct_predicate ref$closure$0_337$3$15496538660126075396(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_337$3$15496538660126075396(self.val_ref), write)) && (true))
}


struct_predicate closure$0_326$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_326$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_326$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_325$3$8530025436341569256(self){
  true
}


struct_predicate ref$closure$0_325$3$8530025436341569256(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_325$3$8530025436341569256(self.val_ref), write)) && (true))
}


struct_predicate closure$0_327$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_327$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_327$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_328$3$15496538660126075396(self){
  true
}


struct_predicate ref$closure$0_328$3$15496538660126075396(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_328$3$15496538660126075396(self.val_ref), write)) && (true))
}


method m_xor_v(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _old$pre$1: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(ref$m_BitVec32$_beg_$_end_)
    _3: Ref(m_BitVec32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_330$3$13114848456984105119)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_333$3$8125425184230690860)
    _16: Ref(ref$usize)
    _17: Ref(ref$m_BitVec32$_beg_$_end_)
    _18: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _19: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _20: Ref(tuple0$)
    _21: Ref(ref$m_BitVec32$_beg_$_end_)
    _22: Ref(usize)
    _23: Ref(bool)
    _24: Ref(bool)
    _25: Ref(ref$m_BitVec32$_beg_$_end_)
    _26: Ref(usize)
    _27: Ref(bool)
    _28: Ref(ref$m_BitVec32$_beg_$_end_)
    _29: Ref(usize)
    _30: Ref(tuple2$usize$bool)
    _31: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#1}::xor_v"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:735:5: 749:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l24
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BitVec32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_5a5dda3e6eca4fe5bec20545ad95f63f_101: Int  :: (((0) <= (_2_forall_5a5dda3e6eca4fe5bec20545ad95f63f_101)) && (((_2_forall_5a5dda3e6eca4fe5bec20545ad95f63f_101) < (32)) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_0, _2_forall_5a5dda3e6eca4fe5bec20545ad95f63f_101)) == (!((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$0, _2_forall_5a5dda3e6eca4fe5bec20545ad95f63f_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$1, _2_forall_5a5dda3e6eca4fe5bec20545ad95f63f_101)))))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BitVec32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BitVec32::zero() -> [return: bb1, unwind: bb17]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_6e18d74b08724366806ddc03a6946ae9_101: Int  :: (((0) <= (_2_forall_6e18d74b08724366806ddc03a6946ae9_101)) && (((_2_forall_6e18d74b08724366806ddc03a6946ae9_101) < (32)) && (true))) ==> (!(m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_6e18d74b08724366806ddc03a6946ae9_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = const 0_usize
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy 0
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l2
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t15 := copy _7.val_bool
    GotoSwitch([(Local(__t15: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t16 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$1 := ghost _2.val_ref
    _preserve$0 := ghost _1.val_ref
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101: Int  :: (((0) <= (_2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)) && (((_2_forall_3cc6a46f084549f7a91e5db4e86abe09_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)) == (!((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    _4 := builtin$havoc_ref()
    __t20 := builtin$havoc_bool()
    _29 := builtin$havoc_ref()
    _21 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    _8 := builtin$havoc_ref()
    __t12 := builtin$havoc_bool()
    _28 := builtin$havoc_ref()
    _14 := builtin$havoc_ref()
    __t6 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    __t18 := builtin$havoc_bool()
    _7 := builtin$havoc_ref()
    _20 := builtin$havoc_ref()
    _22 := builtin$havoc_ref()
    __t2 := builtin$havoc_bool()
    _26 := builtin$havoc_ref()
    _24 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    __t19 := builtin$havoc_bool()
    _30 := builtin$havoc_ref()
    __t5 := builtin$havoc_bool()
    _25 := builtin$havoc_ref()
    _10 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    _23 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    __t10 := builtin$havoc_bool()
    _27 := builtin$havoc_ref()
    __t17 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101: Int  :: (((0) <= (_2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)) && (((_2_forall_3cc6a46f084549f7a91e5db4e86abe09_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)) == (!((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)))))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t17 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'_ mut _3
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_ref, write)
    _21.val_ref := mut borrow _3 // L5
    label l5
    // [mir] StorageLive(_22)
    // [mir] _22 = _4
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_int, write)
    unfold acc(usize:None(_4), write)
    _22.val_int := copy _4.val_int
    label l6
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] StorageLive(_25)
    // [mir] _25 = &'_ (*_1)
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_ref, write)
    _25.val_ref := borrow _1.val_ref // L13
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_25.val_ref), read)
    label l7
    // [mir] StorageLive(_26)
    // [mir] _26 = _4
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.val_int, write)
    _26.val_int := copy _4.val_int
    label l8
    // [mir] _24 = BitVec32::lookup(move _25, move _26) -> [return: bb13, unwind: bb17]
    label l9
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_24), write)
    unfold acc(bool:None(_24), write)
    inhale(Stmt) (_24.val_bool) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_25.val_ref, _26.val_int))
    transfer perm _25.val_ref --> old[l9](_25.val_ref) // unchecked: false
    Goto(cfg:17)
  label l10 // 17
    // ========== l10 ==========
    // MIR edge bb12 --> bb13
    // Expire borrows
    // expire_borrows ReborrowingDAG(L10,L13,)

    if (__t9) && (true) {
    // expire loan L10
} else {}
    if (__t9) && ((__t9) && (true)) {
    // expire loan L13
    transfer perm old[l9](_25.val_ref) --> old[l7](_25.val_ref) // unchecked: false
    exhale acc(m_BitVec32$_beg_$_end_(old[l7](_25.val_ref)), read)
} else {}
    Goto(cfg:18)
  label loop2_group3_bb13 // 18
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_26)
    // [mir] StorageDead(_25)
    // [mir] StorageLive(_27)
    // [mir] StorageLive(_28)
    // [mir] _28 = &'_ (*_2)
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_ref, write)
    _28.val_ref := borrow _2.val_ref // L11
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_28.val_ref), read)
    label l11
    // [mir] StorageLive(_29)
    // [mir] _29 = _4
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.val_int, write)
    _29.val_int := copy _4.val_int
    label l12
    // [mir] _27 = BitVec32::lookup(move _28, move _29) -> [return: bb14, unwind: bb17]
    label l13
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_27), write)
    unfold acc(bool:None(_27), write)
    inhale(Stmt) (_27.val_bool) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_28.val_ref, _29.val_int))
    transfer perm _28.val_ref --> old[l13](_28.val_ref) // unchecked: false
    Goto(cfg:19)
  label l14 // 19
    // ========== l14 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    // expire_borrows ReborrowingDAG(L12,L11,)

    if (__t10) && (true) {
    // expire loan L12
} else {}
    if (__t10) && ((__t10) && (true)) {
    // expire loan L11
    transfer perm old[l13](_28.val_ref) --> old[l11](_28.val_ref) // unchecked: false
    exhale acc(m_BitVec32$_beg_$_end_(old[l11](_28.val_ref)), read)
} else {}
    Goto(cfg:20)
  label loop2_group3_bb14 // 20
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_29)
    // [mir] StorageDead(_28)
    // [mir] _23 = BitXor(move _24, move _27)
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(_23.val_bool, write)
    _23.val_bool := copy !((_24.val_bool) == (_27.val_bool))
    // [mir] StorageDead(_27)
    // [mir] StorageDead(_24)
    // [mir] _20 = BitVec32::set_bit(move _21, move _22, move _23) -> [return: bb15, unwind: bb17]
    label l15
    assert(Stmt) (((0) <= (_22.val_int)) && (((_22.val_int) < (m_main$$$opencur$impl$sharp$1$closecur$$$len<Ref(m_BitVec32$_beg_$_end_),Int>(_21.val_ref))) && (true))) && (true)
    fold acc(bool:None(_23), write)
    fold acc(usize:None(_22), write)
    assert(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_21)) && ((usize$inv<Ref(usize),Bool>(_22)) && ((bool$inv<Ref(bool),Bool>(_23)) && (true)))
    exhale (acc(_21.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_21.val_ref), write)) && ((acc(usize(_22), write)) && ((acc(bool(_23), write)) && (true))))
    _20 := builtin$havoc_ref()
    inhale(Stmt) (acc(m_BitVec32$_beg_$_end_(old[l15](_21.val_ref)), write)) && (true)
    inhale(Stmt) acc(tuple0$(_20), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(old[l15](_21.val_ref))) && ((tuple0$$inv<Ref(tuple0$),Bool>(_20)) && (true))
    inhale(Expr) ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l15](_21.val_ref), old[l15](_22.val_int))) == (old[l15](_23.val_bool))) && ((forall _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101: Int  :: (((0) <= (_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101)) && (((_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101) < (32)) && ((!((_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101) == (old[l15](_22.val_int)))) && (true)))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l15](_21.val_ref), _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101)) == (old[l15](m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_21.val_ref, _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101))))) && (true))
    exhale true
    label l16
    Goto(cfg:21)
  label l17 // 21
    // ========== l17 ==========
    // MIR edge bb14 --> bb15
    // Expire borrows
    // expire_borrows ReborrowingDAG(L14,L5,)

    if (__t11) && (true) {
    // expire loan L14
} else {}
    if (__t9) && ((__t11) && (true)) {
    // expire loan L5
    transfer perm old[l15](_21.val_ref) --> old[l5](_21.val_ref) // unchecked: false
    transfer perm old[l5](_21.val_ref) --> _3 // unchecked: false
} else {}
    Goto(cfg:22)
  label loop2_group3_bb15 // 22
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageDead(_20)
    // [mir] _30 = CheckedAdd(_4, const 1_usize)
    _30 := builtin$havoc_ref()
    inhale(Stmt) acc(_30.tuple_0, write)
    inhale(Stmt) acc(_30.tuple_0.val_int, write)
    inhale(Stmt) acc(_30.tuple_1, write)
    inhale(Stmt) acc(_30.tuple_1.val_bool, write)
    _30.tuple_0.val_int := copy (_4.val_int) + (1)
    _30.tuple_1.val_bool := copy false
    // [mir] assert(!move (_30.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb16, unwind: bb17]
    __t18 := copy _30.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t18)
    Goto(cfg:23)
  label loop2_group3_bb16 // 23
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _4 = move (_30.0: usize)
    _4 := move _30.tuple_0
    label l18
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:24)
  label loop2_group4_bb2 // 24
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:25)
  label loop2_group4_bb3 // 25
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l19
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t19 := copy _7.val_bool
    GotoSwitch([(Local(__t19: Bool, Position { line: 0, column: 0, id: 0 }), cfg:27)], cfg:26)
  label l20 // 26
    // ========== l20 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:32)
  label l21 // 27
    // ========== l21 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:28)
  label loop2_group5_bb4 // 28
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:29)
  label loop2_group5_bb6 // 29
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t20 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:30)
  label loop2_end_body // 30
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_4), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_4), write) in _4.val_int))) && ((((unfolding acc(usize:None(_4), write) in _4.val_int)) < (32)) && (true))) && ((forall _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101: Int  :: (((0) <= (_2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)) && (((_2_forall_3cc6a46f084549f7a91e5db4e86abe09_101) < ((unfolding acc(usize:None(_4), write) in _4.val_int))) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)) == (!((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 31
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l22
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l23 // 32
    // ========== l23 ==========
    // drop Acc(_30.tuple_1.val_bool, write) (Acc(_30.tuple_1.val_bool, write))
    // drop Acc(_14.val_bool, write) (Acc(_14.val_bool, write))
    // drop Acc(old[l7](_25.val_ref), write) (Acc(old[l7](_25.val_ref), write))
    // drop Acc(_24.val_bool, write) (Acc(_24.val_bool, write))
    // drop Acc(_29.val_int, write) (Acc(_29.val_int, write))
    // drop Acc(_26.val_int, write) (Acc(_26.val_int, write))
    // drop Acc(_30.tuple_0, write) (Acc(_30.tuple_0, write))
    // drop Acc(_28.val_ref, write) (Acc(_28.val_ref, write))
    // drop Acc(old[l11](_28.val_ref), write) (Acc(old[l11](_28.val_ref), write))
    // drop Acc(_27.val_bool, write) (Acc(_27.val_bool, write))
    // drop Acc(_25.val_ref, write) (Acc(_25.val_ref, write))
    // drop Pred(_20, write) (Pred(_20, write))
    // drop Acc(_30.tuple_1, write) (Acc(_30.tuple_1, write))
    Goto(cfg:31)
  label end_of_method
}


struct_predicate tuple2$u32$bool(self){
  (acc(self.tuple_0, write)) && ((acc(u32(self.tuple_0), write)) && ((acc(self.tuple_1, write)) && ((acc(bool(self.tuple_1), write)) && (true))))
}


struct_predicate closure$0_345$3$942928111696149103(self){
  true
}


struct_predicate ref$closure$0_345$3$942928111696149103(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_345$3$942928111696149103(self.val_ref), write)) && (true))
}


method m_mul(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _old$pre$1: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(ref$m_BitVec32$_beg_$_end_)
    _3: Ref(u32)
    _4: Ref(u32)
    _5: Ref(u32)
    _6: Ref(tuple2$u32$bool)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#1}::mul"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:766:5: 768:6 (#0)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l5
    // Fold predicates for &mut args and transfer borrow permissions to old
    fold acc(u32:None(_1.val_ref.f$v), read)
    fold acc(m_BitVec32$_beg_$_end_:None(_1.val_ref), read)
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    fold acc(u32:None(_2.val_ref.f$v), read)
    fold acc(m_BitVec32$_beg_$_end_:None(_2.val_ref), read)
    obtain acc(m_BitVec32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    fold acc(u32:None(_0.f$v), write)
    fold acc(m_BitVec32$_beg_$_end_:None(_0), write)
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) ((!(false))?(((unfolding acc(m_BitVec32$_beg_$_end_:None(_0), write) in (unfolding acc(u32:None(_0.f$v), write) in _0.f$v.val_int))) == (((unfolding acc(m_BitVec32$_beg_$_end_:None(_old$pre$0), read) in (unfolding acc(u32:None(_old$pre$0.f$v), read) in _old$pre$0.f$v.val_int))) * ((unfolding acc(m_BitVec32$_beg_$_end_:None(_old$pre$1), read) in (unfolding acc(u32:None(_old$pre$1.f$v), read) in _old$pre$1.f$v.val_int))))):(false)) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BitVec32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] _4 = ((*_1).0: u32)
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    unfold acc(m_BitVec32$_beg_$_end_:None(_1.val_ref), read)
    unfold acc(u32:None(_1.val_ref.f$v), read)
    _4.val_int := copy _1.val_ref.f$v.val_int
    label l0
    // [mir] StorageLive(_5)
    // [mir] _5 = ((*_2).0: u32)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_int, write)
    unfold acc(m_BitVec32$_beg_$_end_:None(_2.val_ref), read)
    unfold acc(u32:None(_2.val_ref.f$v), read)
    _5.val_int := copy _2.val_ref.f$v.val_int
    label l1
    // [mir] _6 = CheckedMul(_4, _5)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.tuple_0, write)
    inhale(Stmt) acc(_6.tuple_0.val_int, write)
    inhale(Stmt) acc(_6.tuple_1, write)
    inhale(Stmt) acc(_6.tuple_1.val_bool, write)
    _6.tuple_0.val_int := copy (_4.val_int) * (_5.val_int)
    _6.tuple_1.val_bool := copy false
    // [mir] assert(!move (_6.1: bool), "attempt to compute `{} * {}`, which would overflow", move _4, move _5) -> [success: bb1, unwind: bb2]
    __t2 := copy _6.tuple_1.val_bool
    // Rust assertion: attempt to multiply with overflow
    assert(Stmt) !(__t2)
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] _3 = move (_6.0: u32)
    _3 := move _6.tuple_0
    label l2
    // [mir] StorageDead(_5)
    // [mir] StorageDead(_4)
    // [mir] _0 = BitVec32 { v: move _3 }
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_0), write)
    unfold acc(m_BitVec32$_beg_$_end_:None(_0), write)
    _0.f$v := move _3
    label l3
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


struct_predicate closure$0_348$3$5051140249578574301(self){
  true
}


struct_predicate ref$closure$0_348$3$5051140249578574301(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_348$3$5051140249578574301(self.val_ref), write)) && (true))
}


struct_predicate closure$0_350$3$942928111696149103(self){
  true
}


struct_predicate ref$closure$0_350$3$942928111696149103(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_350$3$942928111696149103(self.val_ref), write)) && (true))
}


method m_div(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _old$pre$1: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(ref$m_BitVec32$_beg_$_end_)
    _3: Ref(u32)
    _4: Ref(u32)
    _5: Ref(u32)
    _6: Ref(bool)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#1}::div"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:772:5: 774:6 (#0)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) (!(((unfolding acc(m_BitVec32$_beg_$_end_:None(_2.val_ref), read) in (unfolding acc(u32:None(_2.val_ref.f$v), read) in _2.val_ref.f$v.val_int))) == (0))) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l4
    // Fold predicates for &mut args and transfer borrow permissions to old
    fold acc(u32:None(_1.val_ref.f$v), read)
    fold acc(m_BitVec32$_beg_$_end_:None(_1.val_ref), read)
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    fold acc(u32:None(_2.val_ref.f$v), read)
    fold acc(m_BitVec32$_beg_$_end_:None(_2.val_ref), read)
    obtain acc(m_BitVec32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    fold acc(u32:None(_0.f$v), write)
    fold acc(m_BitVec32$_beg_$_end_:None(_0), write)
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) ((!(((unfolding acc(m_BitVec32$_beg_$_end_:None(_old$pre$1), read) in (unfolding acc(u32:None(_old$pre$1.f$v), read) in _old$pre$1.f$v.val_int))) == (0)))?(((unfolding acc(m_BitVec32$_beg_$_end_:None(_0), write) in (unfolding acc(u32:None(_0.f$v), write) in _0.f$v.val_int))) == (((unfolding acc(m_BitVec32$_beg_$_end_:None(_old$pre$0), read) in (unfolding acc(u32:None(_old$pre$0.f$v), read) in _old$pre$0.f$v.val_int))) \ ((unfolding acc(m_BitVec32$_beg_$_end_:None(_old$pre$1), read) in (unfolding acc(u32:None(_old$pre$1.f$v), read) in _old$pre$1.f$v.val_int))))):(false)) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BitVec32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] _4 = ((*_1).0: u32)
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    unfold acc(m_BitVec32$_beg_$_end_:None(_1.val_ref), read)
    unfold acc(u32:None(_1.val_ref.f$v), read)
    _4.val_int := copy _1.val_ref.f$v.val_int
    label l0
    // [mir] StorageLive(_5)
    // [mir] _5 = ((*_2).0: u32)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_int, write)
    unfold acc(m_BitVec32$_beg_$_end_:None(_2.val_ref), read)
    unfold acc(u32:None(_2.val_ref.f$v), read)
    _5.val_int := copy _2.val_ref.f$v.val_int
    label l1
    // [mir] _6 = Eq(_5, const 0_u32)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_bool, write)
    _6.val_bool := copy (_5.val_int) == (0)
    // [mir] assert(!move _6, "attempt to divide `{}` by zero", _4) -> [success: bb1, unwind: bb2]
    __t2 := copy _6.val_bool
    // Rust assertion: attempt to divide by zero
    assert(Stmt) !(__t2)
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] _3 = Div(move _4, move _5)
    _3 := builtin$havoc_ref()
    inhale(Stmt) acc(_3.val_int, write)
    _3.val_int := copy (_4.val_int) \ (_5.val_int)
    // [mir] StorageDead(_5)
    // [mir] StorageDead(_4)
    // [mir] _0 = BitVec32 { v: move _3 }
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_0), write)
    unfold acc(m_BitVec32$_beg_$_end_:None(_0), write)
    _0.f$v := move _3
    label l2
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


struct_predicate closure$0_353$3$5051140249578574301(self){
  true
}


struct_predicate ref$closure$0_353$3$5051140249578574301(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_353$3$5051140249578574301(self.val_ref), write)) && (true))
}


struct_predicate closure$0_355$3$942928111696149103(self){
  true
}


struct_predicate ref$closure$0_355$3$942928111696149103(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_355$3$942928111696149103(self.val_ref), write)) && (true))
}


method m_checked_div(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _old$pre$1: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(ref$m_BitVec32$_beg_$_end_)
    _3: Ref(u32)
    _4: Ref(u32)
    _5: Ref(u32)
    _6: Ref(bool)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#1}::checked_div"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:780:5: 782:6 (#0)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) (!(((unfolding acc(m_BitVec32$_beg_$_end_:None(_2.val_ref), read) in (unfolding acc(u32:None(_2.val_ref.f$v), read) in _2.val_ref.f$v.val_int))) == (0))) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l4
    // Fold predicates for &mut args and transfer borrow permissions to old
    fold acc(u32:None(_1.val_ref.f$v), read)
    fold acc(m_BitVec32$_beg_$_end_:None(_1.val_ref), read)
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    fold acc(u32:None(_2.val_ref.f$v), read)
    fold acc(m_BitVec32$_beg_$_end_:None(_2.val_ref), read)
    obtain acc(m_BitVec32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    fold acc(u32:None(_0.f$v), write)
    fold acc(m_BitVec32$_beg_$_end_:None(_0), write)
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) ((!(((unfolding acc(m_BitVec32$_beg_$_end_:None(_old$pre$1), read) in (unfolding acc(u32:None(_old$pre$1.f$v), read) in _old$pre$1.f$v.val_int))) == (0)))?(((unfolding acc(m_BitVec32$_beg_$_end_:None(_0), write) in (unfolding acc(u32:None(_0.f$v), write) in _0.f$v.val_int))) == (((unfolding acc(m_BitVec32$_beg_$_end_:None(_old$pre$0), read) in (unfolding acc(u32:None(_old$pre$0.f$v), read) in _old$pre$0.f$v.val_int))) \ ((unfolding acc(m_BitVec32$_beg_$_end_:None(_old$pre$1), read) in (unfolding acc(u32:None(_old$pre$1.f$v), read) in _old$pre$1.f$v.val_int))))):(false)) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BitVec32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] _4 = ((*_1).0: u32)
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    unfold acc(m_BitVec32$_beg_$_end_:None(_1.val_ref), read)
    unfold acc(u32:None(_1.val_ref.f$v), read)
    _4.val_int := copy _1.val_ref.f$v.val_int
    label l0
    // [mir] StorageLive(_5)
    // [mir] _5 = ((*_2).0: u32)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_int, write)
    unfold acc(m_BitVec32$_beg_$_end_:None(_2.val_ref), read)
    unfold acc(u32:None(_2.val_ref.f$v), read)
    _5.val_int := copy _2.val_ref.f$v.val_int
    label l1
    // [mir] _6 = Eq(_5, const 0_u32)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_bool, write)
    _6.val_bool := copy (_5.val_int) == (0)
    // [mir] assert(!move _6, "attempt to divide `{}` by zero", _4) -> [success: bb1, unwind: bb2]
    __t2 := copy _6.val_bool
    // Rust assertion: attempt to divide by zero
    assert(Stmt) !(__t2)
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] _3 = Div(move _4, move _5)
    _3 := builtin$havoc_ref()
    inhale(Stmt) acc(_3.val_int, write)
    _3.val_int := copy (_4.val_int) \ (_5.val_int)
    // [mir] StorageDead(_5)
    // [mir] StorageDead(_4)
    // [mir] _0 = BitVec32 { v: move _3 }
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_0), write)
    unfold acc(m_BitVec32$_beg_$_end_:None(_0), write)
    _0.f$v := move _3
    label l2
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


struct_predicate u8(self){
  (acc(self.val_int, write)) && (true)
}


struct_predicate raw_ref$u8(self);


struct_predicate m_PhantomData$_beg_$u8$_end_(self){
  true
}


struct_predicate m_Unique$_beg_$u8$_end_(self){
  (acc(self.f$pointer, write)) && ((acc(raw_ref$u8(self.f$pointer), write)) && ((acc(self.f$_marker, write)) && ((acc(m_PhantomData$_beg_$u8$_end_(self.f$_marker), write)) && (true))))
}


struct_predicate m_RawVec$_beg_$u8$_sep_$m_Global$_beg_$_end_$_end_(self){
  (acc(self.f$ptr, write)) && ((acc(m_Unique$_beg_$u8$_end_(self.f$ptr), write)) && ((acc(self.f$cap, write)) && ((acc(usize(self.f$cap), write)) && ((acc(self.f$alloc, write)) && ((acc(m_Global$_beg_$_end_(self.f$alloc), write)) && (true))))))
}


struct_predicate m_Vec$_beg_$u8$_sep_$m_Global$_beg_$_end_$_end_(self){
  (acc(self.f$buf, write)) && ((acc(m_RawVec$_beg_$u8$_sep_$m_Global$_beg_$_end_$_end_(self.f$buf), write)) && ((acc(self.f$len, write)) && ((acc(usize(self.f$len), write)) && (true))))
}


struct_predicate m_PrustiVec$_beg_$_end_(self){
  (acc(self.f$v, write)) && ((acc(m_Vec$_beg_$u8$_sep_$m_Global$_beg_$_end_$_end_(self.f$v), write)) && (true))
}


struct_predicate closure$0_358$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_358$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_358$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate ref$m_PrustiVec$_beg_$_end_(self){
  (acc(self.val_ref, write)) && ((acc(m_PrustiVec$_beg_$_end_(self.val_ref), write)) && (true))
}


function m_main$$$opencur$impl$sharp$2$closecur$$$len(_1: Ref(m_PrustiVec$_beg_$_end_)): Int
  requires (acc(m_PrustiVec$_beg_$_end_(_1), read)) && (true)
  requires true
  ensures ((0) <= (__result)) && (true)


struct_predicate closure$0_361$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_361$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_361$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_362$3$1766526748840765837(self){
  true
}


struct_predicate ref$closure$0_362$3$1766526748840765837(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_362$3$1766526748840765837(self.val_ref), write)) && (true))
}


struct_predicate ref$ref$m_PrustiVec$_beg_$_end_(self){
  (acc(self.val_ref, write)) && ((acc(ref$m_PrustiVec$_beg_$_end_(self.val_ref), write)) && (true))
}


function m_main$$$opencur$impl$sharp$2$closecur$$$lookup(_1: Ref(m_PrustiVec$_beg_$_end_), _2: Int): Int
  requires (acc(m_PrustiVec$_beg_$_end_(_1), read)) && (true)
  requires (((0) <= (_2)) && (((_2) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1))) && (true))) && (true)
  ensures true


struct_predicate closure$0_377$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_377$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_377$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_378$3$7836625531840506276(self){
  true
}


struct_predicate ref$closure$0_378$3$7836625531840506276(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_378$3$7836625531840506276(self.val_ref), write)) && (true))
}


struct_predicate closure$0_380$3$8971431446524031796(self){
  true
}


struct_predicate ref$closure$0_380$3$8971431446524031796(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_380$3$8971431446524031796(self.val_ref), write)) && (true))
}


struct_predicate closure$0_382$3$8971431446524031796(self){
  true
}


struct_predicate ref$closure$0_382$3$8971431446524031796(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_382$3$8971431446524031796(self.val_ref), write)) && (true))
}


struct_predicate closure$0_384$3$16120224468385193760(self){
  true
}


struct_predicate ref$closure$0_384$3$16120224468385193760(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_384$3$16120224468385193760(self.val_ref), write)) && (true))
}


struct_predicate ref$u8(self){
  (acc(self.val_ref, write)) && ((acc(u8(self.val_ref), write)) && (true))
}


struct_predicate closure$0_387$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_387$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_387$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_386$3$5194155310508031224(self){
  true
}


struct_predicate ref$closure$0_386$3$5194155310508031224(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_386$3$5194155310508031224(self.val_ref), write)) && (true))
}


struct_predicate closure$0_388$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_388$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_388$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_389$3$7836625531840506276(self){
  true
}


struct_predicate ref$closure$0_389$3$7836625531840506276(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_389$3$7836625531840506276(self.val_ref), write)) && (true))
}


struct_predicate closure$0_390$3$7836625531840506276(self){
  true
}


struct_predicate ref$closure$0_390$3$7836625531840506276(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_390$3$7836625531840506276(self.val_ref), write)) && (true))
}


struct_predicate closure$0_391$3$17267179144483917314(self){
  true
}


struct_predicate ref$closure$0_391$3$17267179144483917314(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_391$3$17267179144483917314(self.val_ref), write)) && (true))
}


struct_predicate closure$0_394$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_394$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_394$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_393$3$5194155310508031224(self){
  true
}


struct_predicate ref$closure$0_393$3$5194155310508031224(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_393$3$5194155310508031224(self.val_ref), write)) && (true))
}


struct_predicate closure$0_395$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_395$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_395$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_396$3$7836625531840506276(self){
  true
}


struct_predicate ref$closure$0_396$3$7836625531840506276(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_396$3$7836625531840506276(self.val_ref), write)) && (true))
}


struct_predicate closure$0_397$3$7836625531840506276(self){
  true
}


struct_predicate ref$closure$0_397$3$7836625531840506276(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_397$3$7836625531840506276(self.val_ref), write)) && (true))
}


struct_predicate closure$0_398$3$17267179144483917314(self){
  true
}


struct_predicate ref$closure$0_398$3$17267179144483917314(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_398$3$17267179144483917314(self.val_ref), write)) && (true))
}


struct_predicate closure$0_401$3$8971431446524031796(self){
  true
}


struct_predicate ref$closure$0_401$3$8971431446524031796(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_401$3$8971431446524031796(self.val_ref), write)) && (true))
}


struct_predicate closure$0_403$3$8971431446524031796(self){
  true
}


struct_predicate ref$closure$0_403$3$8971431446524031796(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_403$3$8971431446524031796(self.val_ref), write)) && (true))
}


struct_predicate closure$0_405$3$8971431446524031796(self){
  true
}


struct_predicate ref$closure$0_405$3$8971431446524031796(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_405$3$8971431446524031796(self.val_ref), write)) && (true))
}


struct_predicate closure$0_407$3$8237441797234738713(self){
  true
}


struct_predicate ref$closure$0_407$3$8237441797234738713(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_407$3$8237441797234738713(self.val_ref), write)) && (true))
}


struct_predicate closure$0_410$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_410$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_410$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_409$3$5194155310508031224(self){
  true
}


struct_predicate ref$closure$0_409$3$5194155310508031224(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_409$3$5194155310508031224(self.val_ref), write)) && (true))
}


struct_predicate closure$0_411$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_411$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_411$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_412$3$7836625531840506276(self){
  true
}


struct_predicate ref$closure$0_412$3$7836625531840506276(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_412$3$7836625531840506276(self.val_ref), write)) && (true))
}


struct_predicate closure$0_413$3$7836625531840506276(self){
  true
}


struct_predicate ref$closure$0_413$3$7836625531840506276(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_413$3$7836625531840506276(self.val_ref), write)) && (true))
}


struct_predicate closure$0_414$3$17267179144483917314(self){
  true
}


struct_predicate ref$closure$0_414$3$17267179144483917314(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_414$3$17267179144483917314(self.val_ref), write)) && (true))
}


method m_pop(2 args)
    returns (_0: Ref(u8))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    _old$pre$0: Ref(m_PrustiVec$_beg_$_end_)
    _1: Ref(ref$m_PrustiVec$_beg_$_end_)
    _2: Ref(usize)
    _3: Ref(usize)
    _4: Ref(usize)
    _5: Ref(ref$m_PrustiVec$_beg_$_end_)
    _6: Ref(tuple2$usize$bool)
    _7: Ref(ref$m_PrustiVec$_beg_$_end_)
    _8: Ref(usize)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#2}::pop"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:868:5: 871:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write)) && ((acc(usize(_2), write)) && (true)))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_PrustiVec$_beg_$_end_$inv<Ref(ref$m_PrustiVec$_beg_$_end_),Bool>(_1)) && ((usize$inv<Ref(usize),Bool>(_2)) && (true))
    inhale(Expr) ((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)) >= (1)) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l10
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(u8(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) ((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_old$pre$0)) == ((old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))) - (1))):(false)) && (((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_old$pre$0)) >= (0)) && (((!(false))?(((unfolding acc(u8:None(_0), write) in _0.val_int)) == (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)) - (1))))):(false)) && ((forall _2_forall_164e1a02575f4a81ac646e8c0a9d0463_101: Int  :: (((0) <= (_2_forall_164e1a02575f4a81ac646e8c0a9d0463_101)) && (((_2_forall_164e1a02575f4a81ac646e8c0a9d0463_101) < (old[pre]((unfolding acc(usize:None(_2), write) in _2.val_int)))) && (((_2_forall_164e1a02575f4a81ac646e8c0a9d0463_101) < (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)))) && (((_2_forall_164e1a02575f4a81ac646e8c0a9d0463_101) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_old$pre$0))) && (true))))) ==> ((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_old$pre$0, _2_forall_164e1a02575f4a81ac646e8c0a9d0463_101)) == (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, _2_forall_164e1a02575f4a81ac646e8c0a9d0463_101))))) && (true))))
    // Assert type invariants
    assert(Stmt) (m_PrustiVec$_beg_$_end_$inv<Ref(m_PrustiVec$_beg_$_end_),Bool>(_old$pre$0)) && ((u8$inv<Ref(u8),Bool>(_0)) && (true))
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_PrustiVec$_beg_$_end_(_old$pre$0), write)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(u8(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = &'_ (*_1)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_ref, write)
    _5.val_ref := borrow _1.val_ref // L0
    exhale acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write-read)
    inhale(Stmt) acc(m_PrustiVec$_beg_$_end_(_5.val_ref), read)
    label l0
    // [mir] _4 = PrustiVec::len(move _5) -> [return: bb1, unwind: bb4]
    label l1
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(usize(_4), write)
    unfold acc(usize:None(_4), write)
    inhale(Stmt) (_4.val_int) == (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_5.val_ref))
    transfer perm _5.val_ref --> old[l1](_5.val_ref) // unchecked: false
    Goto(cfg:3)
  label l2 // 3
    // ========== l2 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    // expire_borrows ReborrowingDAG(L6,L0,)

    if (__t0) && (true) {
    // expire loan L6
} else {}
    if (__t0) && ((__t0) && (true)) {
    // expire loan L0
    transfer perm old[l1](_5.val_ref) --> old[l0](_5.val_ref) // unchecked: false
    exhale acc(m_PrustiVec$_beg_$_end_(old[l0](_5.val_ref)), read)
    inhale(Stmt) acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write-read)
} else {}
    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_5)
    // [mir] _6 = CheckedSub(_4, const 1_usize)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.tuple_0, write)
    inhale(Stmt) acc(_6.tuple_0.val_int, write)
    inhale(Stmt) acc(_6.tuple_1, write)
    inhale(Stmt) acc(_6.tuple_1.val_bool, write)
    _6.tuple_0.val_int := copy (_4.val_int) - (1)
    _6.tuple_1.val_bool := copy false
    // [mir] assert(!move (_6.1: bool), "attempt to compute `{} - {}`, which would overflow", move _4, const 1_usize) -> [success: bb2, unwind: bb4]
    __t4 := copy _6.tuple_1.val_bool
    // Rust assertion: attempt to subtract with overflow
    assert(Stmt) !(__t4)
    Goto(cfg:5)
  label bb2 // 5
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] _3 = move (_6.0: usize)
    _3 := move _6.tuple_0
    label l3
    // [mir] StorageDead(_4)
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_7)
    // [mir] _7 = &'_ mut (*_1)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_ref, write)
    _7.val_ref := mut borrow _1.val_ref // L1
    label l4
    // [mir] StorageLive(_8)
    // [mir] _8 = _3
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _3.val_int
    label l5
    // [mir] _0 = PrustiVec::remove(move _7, move _8) -> [return: bb3, unwind: bb4]
    label l6
    assert(Stmt) (((0) <= (_8.val_int)) && (((_8.val_int) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_7.val_ref))) && (true))) && (true)
    fold acc(usize:None(_8), write)
    assert(Stmt) (ref$m_PrustiVec$_beg_$_end_$inv<Ref(ref$m_PrustiVec$_beg_$_end_),Bool>(_7)) && ((usize$inv<Ref(usize),Bool>(_8)) && (true))
    exhale (acc(_7.val_ref, write)) && ((acc(m_PrustiVec$_beg_$_end_(_7.val_ref), write)) && ((acc(usize(_8), write)) && (true)))
    _0 := builtin$havoc_ref()
    inhale(Stmt) (acc(m_PrustiVec$_beg_$_end_(old[l6](_7.val_ref)), write)) && (true)
    inhale(Stmt) acc(u8(_0), write)
    inhale(Stmt) (m_PrustiVec$_beg_$_end_$inv<Ref(m_PrustiVec$_beg_$_end_),Bool>(old[l6](_7.val_ref))) && ((u8$inv<Ref(u8),Bool>(_0)) && (true))
    inhale(Expr) ((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(old[l6](_7.val_ref))) == ((old[l6](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_7.val_ref))) - (1))):(false)) && (((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(old[l6](_7.val_ref))) >= (0)) && ((((unfolding acc(u8:None(_0), write) in _0.val_int)) == (old[l6](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_7.val_ref, _8.val_int)))) && ((forall _2_forall_15f0f478e164462ba34426e913276433_101: Int  :: (((0) <= (_2_forall_15f0f478e164462ba34426e913276433_101)) && (((_2_forall_15f0f478e164462ba34426e913276433_101) < (old[l6](_8.val_int))) && (((_2_forall_15f0f478e164462ba34426e913276433_101) < (old[l6](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_7.val_ref)))) && (((_2_forall_15f0f478e164462ba34426e913276433_101) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(old[l6](_7.val_ref)))) && (true))))) ==> ((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(old[l6](_7.val_ref), _2_forall_15f0f478e164462ba34426e913276433_101)) == (old[l6](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_7.val_ref, _2_forall_15f0f478e164462ba34426e913276433_101))))) && ((forall _2_forall_6291b57a8391489b9939551ad5a39a45_101: Int  :: (((1) <= (_2_forall_6291b57a8391489b9939551ad5a39a45_101)) && (((old[l6](_8.val_int)) <= (_2_forall_6291b57a8391489b9939551ad5a39a45_101)) && (((_2_forall_6291b57a8391489b9939551ad5a39a45_101) < (old[l6](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_7.val_ref)))) && (((_2_forall_6291b57a8391489b9939551ad5a39a45_101) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(old[l6](_7.val_ref)))) && (true))))) ==> ((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(old[l6](_7.val_ref), (_2_forall_6291b57a8391489b9939551ad5a39a45_101) - (1))) == (old[l6](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_7.val_ref, _2_forall_6291b57a8391489b9939551ad5a39a45_101)))):(false))) && (true)))))
    exhale true
    label l7
    Goto(cfg:6)
  label l8 // 6
    // ========== l8 ==========
    // MIR edge bb2 --> bb3
    // Expire borrows
    // expire_borrows ReborrowingDAG(L5,L1,)

    if (__t2) && (true) {
    // expire loan L5
} else {}
    if (__t2) && ((__t2) && (true)) {
    // expire loan L1
    transfer perm old[l6](_7.val_ref) --> old[l4](_7.val_ref) // unchecked: false
    transfer perm old[l4](_7.val_ref) --> _1.val_ref // unchecked: false
} else {}
    Goto(cfg:7)
  label bb3 // 7
    // ========== bb3 ==========
    __t3 := copy true
    // [mir] StorageDead(_8)
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


struct_predicate closure$0_432$3$10808428406900332318(self){
  true
}


struct_predicate closure$0_434$3$6168722008047593507(self){
  true
}


struct_predicate closure$0_429$3$11337997195384638765(self){
  true
}


struct_predicate closure$0_442$3$3110356988240756096(self){
  true
}


struct_predicate closure$0_430$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_430$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_430$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_429$3$11337997195384638765(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_429$3$11337997195384638765(self.val_ref), write)) && (true))
}


struct_predicate closure$0_431$3$1766526748840765837(self){
  true
}


struct_predicate ref$closure$0_431$3$1766526748840765837(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_431$3$1766526748840765837(self.val_ref), write)) && (true))
}


struct_predicate closure$0_433$3$17267179144483917314(self){
  true
}


struct_predicate ref$closure$0_433$3$17267179144483917314(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_433$3$17267179144483917314(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_432$3$10808428406900332318(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_432$3$10808428406900332318(self.val_ref), write)) && (true))
}


struct_predicate closure$0_436$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_436$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_436$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_435$3$6525889209950051600(self){
  true
}


struct_predicate ref$closure$0_435$3$6525889209950051600(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_435$3$6525889209950051600(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_434$3$6168722008047593507(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_434$3$6168722008047593507(self.val_ref), write)) && (true))
}


struct_predicate closure$0_437$3$2056113137574856578(self){
  true
}


struct_predicate ref$closure$0_437$3$2056113137574856578(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_437$3$2056113137574856578(self.val_ref), write)) && (true))
}


struct_predicate closure$0_438$3$7836625531840506276(self){
  true
}


struct_predicate ref$closure$0_438$3$7836625531840506276(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_438$3$7836625531840506276(self.val_ref), write)) && (true))
}


struct_predicate closure$0_439$3$7836625531840506276(self){
  true
}


struct_predicate ref$closure$0_439$3$7836625531840506276(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_439$3$7836625531840506276(self.val_ref), write)) && (true))
}


struct_predicate closure$0_440$3$1766526748840765837(self){
  true
}


struct_predicate ref$closure$0_440$3$1766526748840765837(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_440$3$1766526748840765837(self.val_ref), write)) && (true))
}


struct_predicate closure$0_441$3$11893427539397804993(self){
  true
}


struct_predicate ref$closure$0_441$3$11893427539397804993(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_441$3$11893427539397804993(self.val_ref), write)) && (true))
}


struct_predicate closure$0_444$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_444$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_444$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_443$3$10877467573264142751(self){
  true
}


struct_predicate ref$closure$0_443$3$10877467573264142751(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_443$3$10877467573264142751(self.val_ref), write)) && (true))
}


struct_predicate ref$closure$0_442$3$3110356988240756096(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_442$3$3110356988240756096(self.val_ref), write)) && (true))
}


struct_predicate closure$0_445$3$7836625531840506276(self){
  true
}


struct_predicate ref$closure$0_445$3$7836625531840506276(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_445$3$7836625531840506276(self.val_ref), write)) && (true))
}


struct_predicate closure$0_446$3$17267179144483917314(self){
  true
}


struct_predicate ref$closure$0_446$3$17267179144483917314(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_446$3$17267179144483917314(self.val_ref), write)) && (true))
}


struct_predicate closure$0_365$3$8971431446524031796(self){
  true
}


struct_predicate ref$closure$0_365$3$8971431446524031796(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_365$3$8971431446524031796(self.val_ref), write)) && (true))
}


struct_predicate closure$0_367$3$8971431446524031796(self){
  true
}


struct_predicate ref$closure$0_367$3$8971431446524031796(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_367$3$8971431446524031796(self.val_ref), write)) && (true))
}


struct_predicate closure$0_369$3$18188746090121573547(self){
  true
}


struct_predicate ref$closure$0_369$3$18188746090121573547(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_369$3$18188746090121573547(self.val_ref), write)) && (true))
}


struct_predicate closure$0_372$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_372$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_372$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_371$3$10877467573264142751(self){
  true
}


struct_predicate ref$closure$0_371$3$10877467573264142751(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_371$3$10877467573264142751(self.val_ref), write)) && (true))
}


struct_predicate closure$0_373$3$7836625531840506276(self){
  true
}


struct_predicate ref$closure$0_373$3$7836625531840506276(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_373$3$7836625531840506276(self.val_ref), write)) && (true))
}


struct_predicate closure$0_374$3$17267179144483917314(self){
  true
}


struct_predicate ref$closure$0_374$3$17267179144483917314(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_374$3$17267179144483917314(self.val_ref), write)) && (true))
}


struct_predicate closure$0_417$3$2096885168097836278(self){
  true
}


struct_predicate ref$closure$0_417$3$2096885168097836278(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_417$3$2096885168097836278(self.val_ref), write)) && (true))
}


struct_predicate closure$0_420$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_420$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_420$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_419$3$12427431875014294228(self){
  true
}


struct_predicate ref$closure$0_419$3$12427431875014294228(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_419$3$12427431875014294228(self.val_ref), write)) && (true))
}


struct_predicate closure$0_421$3$1766526748840765837(self){
  true
}


struct_predicate ref$closure$0_421$3$1766526748840765837(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_421$3$1766526748840765837(self.val_ref), write)) && (true))
}


struct_predicate closure$0_422$3$11893427539397804993(self){
  true
}


struct_predicate ref$closure$0_422$3$11893427539397804993(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_422$3$11893427539397804993(self.val_ref), write)) && (true))
}


struct_predicate closure$0_425$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_425$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_425$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_424$3$10877467573264142751(self){
  true
}


struct_predicate ref$closure$0_424$3$10877467573264142751(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_424$3$10877467573264142751(self.val_ref), write)) && (true))
}


struct_predicate closure$0_426$3$7836625531840506276(self){
  true
}


struct_predicate ref$closure$0_426$3$7836625531840506276(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_426$3$7836625531840506276(self.val_ref), write)) && (true))
}


struct_predicate closure$0_427$3$17267179144483917314(self){
  true
}


struct_predicate ref$closure$0_427$3$17267179144483917314(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_427$3$17267179144483917314(self.val_ref), write)) && (true))
}


method m_append(2 args)
    returns (_0: Ref(tuple0$))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t21: Bool
    __t22: Bool
    __t23: Bool
    __t24: Bool
    __t25: Bool
    __t26: Bool
    _old$pre$0: Ref(m_PrustiVec$_beg_$_end_)
    _old$pre$1: Ref(m_PrustiVec$_beg_$_end_)
    _1: Ref(ref$m_PrustiVec$_beg_$_end_)
    _2: Ref(ref$m_PrustiVec$_beg_$_end_)
    _3: Ref(usize)
    _4: Ref(usize)
    _5: Ref(ref$m_PrustiVec$_beg_$_end_)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(usize)
    _10: Ref(ref$m_PrustiVec$_beg_$_end_)
    _11: Ref(tuple0$)
    _12: Ref(bool)
    _13: Ref(closure$0_429$3$11337997195384638765)
    _14: Ref(ref$usize)
    _15: Ref(ref$ref$m_PrustiVec$_beg_$_end_)
    _16: Ref(tuple0$)
    _17: Ref(bool)
    _18: Ref(closure$0_432$3$10808428406900332318)
    _19: Ref(ref$ref$m_PrustiVec$_beg_$_end_)
    _20: Ref(ref$usize)
    _21: Ref(tuple0$)
    _22: Ref(bool)
    _23: Ref(closure$0_434$3$6168722008047593507)
    _24: Ref(ref$usize)
    _25: Ref(ref$ref$m_PrustiVec$_beg_$_end_)
    _26: Ref(ref$ref$m_PrustiVec$_beg_$_end_)
    _27: Ref(tuple0$)
    _28: Ref(bool)
    _29: Ref(closure$0_442$3$3110356988240756096)
    _30: Ref(ref$ref$m_PrustiVec$_beg_$_end_)
    _31: Ref(tuple0$)
    _32: Ref(ref$m_PrustiVec$_beg_$_end_)
    _33: Ref(u8)
    _34: Ref(ref$m_PrustiVec$_beg_$_end_)
    _35: Ref(usize)
    _36: Ref(tuple2$usize$bool)
    _37: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#2}::append"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:886:5: 909:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    __t16 := copy false
    __t17 := copy false
    __t18 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write)) && ((acc(_2.val_ref, write)) && ((acc(m_PrustiVec$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_PrustiVec$_beg_$_end_$inv<Ref(ref$m_PrustiVec$_beg_$_end_),Bool>(_1)) && ((ref$m_PrustiVec$_beg_$_end_$inv<Ref(ref$m_PrustiVec$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l25
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_PrustiVec$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    fold acc(tuple0$:None(_0), write)
    obtain acc(tuple0$(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) ((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_old$pre$0)) == ((old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))) + (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_old$pre$1)))):(false)) && ((forall _2_forall_3ea8b7088ef64adab11ff9fe1d39ff27_101: Int  :: (((0) <= (_2_forall_3ea8b7088ef64adab11ff9fe1d39ff27_101)) && (((_2_forall_3ea8b7088ef64adab11ff9fe1d39ff27_101) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_old$pre$1))) && (true))) ==> ((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_old$pre$0, (_2_forall_3ea8b7088ef64adab11ff9fe1d39ff27_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))))) == (m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_old$pre$1, _2_forall_3ea8b7088ef64adab11ff9fe1d39ff27_101))):(false))) && ((forall _2_forall_c5ec806e7a184c158060318d6d45f205_101: Int  :: (((0) <= (_2_forall_c5ec806e7a184c158060318d6d45f205_101)) && (((_2_forall_c5ec806e7a184c158060318d6d45f205_101) < (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)))) && (true))) ==> ((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_old$pre$0, _2_forall_c5ec806e7a184c158060318d6d45f205_101)) == (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, _2_forall_c5ec806e7a184c158060318d6d45f205_101))))) && (true)))
    // Assert type invariants
    assert(Stmt) (m_PrustiVec$_beg_$_end_$inv<Ref(m_PrustiVec$_beg_$_end_),Bool>(_old$pre$0)) && ((tuple0$$inv<Ref(tuple0$),Bool>(_0)) && (true))
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_PrustiVec$_beg_$_end_(_old$pre$0), write)) && ((acc(m_PrustiVec$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(tuple0$(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = const 0_usize
    _3 := builtin$havoc_ref()
    inhale(Stmt) acc(_3.val_int, write)
    _3.val_int := copy 0
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = &'_ (*_1)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_ref, write)
    _5.val_ref := borrow _1.val_ref // L0
    exhale acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write-read)
    inhale(Stmt) acc(m_PrustiVec$_beg_$_end_(_5.val_ref), read)
    label l0
    // [mir] _4 = PrustiVec::len(move _5) -> [return: bb1, unwind: bb23]
    label l1
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(usize(_4), write)
    unfold acc(usize:None(_4), write)
    inhale(Stmt) (_4.val_int) == (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_5.val_ref))
    transfer perm _5.val_ref --> old[l1](_5.val_ref) // unchecked: false
    Goto(cfg:3)
  label l2 // 3
    // ========== l2 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    // expire_borrows ReborrowingDAG(L19,L0,)

    if (__t0) && (true) {
    // expire loan L19
} else {}
    if (__t0) && ((__t0) && (true)) {
    // expire loan L0
    transfer perm old[l1](_5.val_ref) --> old[l0](_5.val_ref) // unchecked: false
    exhale acc(m_PrustiVec$_beg_$_end_(old[l0](_5.val_ref)), read)
    inhale(Stmt) acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write-read)
} else {}
    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_5)
    // [mir] FakeRead(ForLet, _4)
    // [mir] goto -> bb2
    Goto(cfg:5)
  label loop2_start // 5
    // ========== loop2_start ==========
    Goto(cfg:6)
  label loop2_group1_bb2 // 6
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb23]
    Goto(cfg:7)
  label loop2_group1_bb3 // 7
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _3
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _3.val_int
    label l3
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = &'_ (*_2)
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_ref, write)
    _10.val_ref := borrow _2.val_ref // L18
    inhale(Stmt) acc(m_PrustiVec$_beg_$_end_(_10.val_ref), read)
    label l4
    // [mir] _9 = PrustiVec::len(move _10) -> [return: bb4, unwind: bb23]
    label l5
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(usize(_9), write)
    unfold acc(usize:None(_9), write)
    inhale(Stmt) (_9.val_int) == (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_10.val_ref))
    transfer perm _10.val_ref --> old[l5](_10.val_ref) // unchecked: false
    Goto(cfg:8)
  label l6 // 8
    // ========== l6 ==========
    // MIR edge bb3 --> bb4
    // Expire borrows
    // expire_borrows ReborrowingDAG(L14,L18,)

    if (__t3) && (true) {
    // expire loan L14
} else {}
    if (__t3) && ((__t3) && (true)) {
    // expire loan L18
    transfer perm old[l5](_10.val_ref) --> old[l4](_10.val_ref) // unchecked: false
    exhale acc(m_PrustiVec$_beg_$_end_(old[l4](_10.val_ref)), read)
} else {}
    Goto(cfg:9)
  label loop2_group1_bb4 // 9
    // ========== loop2_group1_bb4 ==========
    __t4 := copy true
    // [mir] StorageDead(_10)
    // [mir] _7 = Lt(move _8, move _9)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (_9.val_int)
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb6, otherwise: bb5]
    __t19 := copy _7.val_bool
    GotoSwitch([(Local(__t19: Bool, Position { line: 0, column: 0, id: 0 }), cfg:11)], cfg:10)
  label l7 // 10
    // ========== l7 ==========
    // MIR edge bb4 --> bb6
    Goto(cfg:38)
  label l8 // 11
    // ========== l8 ==========
    // MIR edge bb4 --> bb5
    Goto(cfg:12)
  label loop2_group2_bb5 // 12
    // ========== loop2_group2_bb5 ==========
    __t5 := copy true
    // [mir] falseEdge -> [real: bb7, imaginary: bb6]
    Goto(cfg:13)
  label loop2_group2_bb7 // 13
    // ========== loop2_group2_bb7 ==========
    __t6 := copy true
    // [mir] StorageLive(_11)
    // [mir] StorageLive(_12)
    // [mir] _12 = const false
    _12 := builtin$havoc_ref()
    inhale(Stmt) acc(_12.val_bool, write)
    _12.val_bool := copy false
    // [mir] switchInt(move _12) -> [false: bb9, otherwise: bb8]
    __t20 := copy _12.val_bool
    // Ignore default target bb8, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:14)
  label loop2_inv_pre // 14
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    _preserve$1 := ghost _2.val_ref
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_3), write)
    obtain acc(usize(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_3), write) in _3.val_int))) && ((((unfolding acc(usize:None(_3), write) in _3.val_int)) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_2.val_ref))) && (true))) && (((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)) == ((old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))) + ((unfolding acc(usize:None(_3), write) in _3.val_int)))):(false)) && ((forall _2_forall_67396f83e8cd4801ae45e414c98ae16e_101: Int  :: ((((0) <= (_2_forall_67396f83e8cd4801ae45e414c98ae16e_101)) && (((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) < ((unfolding acc(usize:None(_3), write) in _3.val_int))) && (true))) && ((((!(false))?((0) <= ((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))))):(false)) && (((!(false))?(((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)))) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))):(false)) && (true))) && (((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_2.val_ref))) && (true)))) ==> ((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, (_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))))) == (m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_2.val_ref, _2_forall_67396f83e8cd4801ae45e414c98ae16e_101))):(false))) && ((forall _2_forall_86902255ca344ade8030c17ca05d40aa_101: Int  :: (((0) <= (_2_forall_86902255ca344ade8030c17ca05d40aa_101)) && (((_2_forall_86902255ca344ade8030c17ca05d40aa_101) < (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)))) && (true))) ==> ((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, _2_forall_86902255ca344ade8030c17ca05d40aa_101)) == (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, _2_forall_86902255ca344ade8030c17ca05d40aa_101))))) && (true))))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write)) && ((acc(_2.val_ref, read)) && (true)))))
    __t10 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    _35 := builtin$havoc_ref()
    __t25 := builtin$havoc_bool()
    _33 := builtin$havoc_ref()
    __t15 := builtin$havoc_bool()
    _12 := builtin$havoc_ref()
    __t2 := builtin$havoc_bool()
    _7 := builtin$havoc_ref()
    __t26 := builtin$havoc_bool()
    _31 := builtin$havoc_ref()
    __t22 := builtin$havoc_bool()
    __t21 := builtin$havoc_bool()
    __t14 := builtin$havoc_bool()
    _9 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    __t16 := builtin$havoc_bool()
    _34 := builtin$havoc_ref()
    __t12 := builtin$havoc_bool()
    _28 := builtin$havoc_ref()
    _32 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    __t17 := builtin$havoc_bool()
    _17 := builtin$havoc_ref()
    __t6 := builtin$havoc_bool()
    __t23 := builtin$havoc_bool()
    _36 := builtin$havoc_ref()
    __t5 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    _10 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    _22 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    _8 := builtin$havoc_ref()
    __t24 := builtin$havoc_bool()
    _3 := builtin$havoc_ref()
    __t9 := builtin$havoc_bool()
    Goto(cfg:15)
  label loop2_inv_post // 15
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= ((unfolding acc(usize:None(_3), write) in _3.val_int))) && ((((unfolding acc(usize:None(_3), write) in _3.val_int)) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_2.val_ref))) && (true))) && (((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)) == ((old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))) + ((unfolding acc(usize:None(_3), write) in _3.val_int)))):(false)) && ((forall _2_forall_67396f83e8cd4801ae45e414c98ae16e_101: Int  :: ((((0) <= (_2_forall_67396f83e8cd4801ae45e414c98ae16e_101)) && (((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) < ((unfolding acc(usize:None(_3), write) in _3.val_int))) && (true))) && ((((!(false))?((0) <= ((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))))):(false)) && (((!(false))?(((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)))) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))):(false)) && (true))) && (((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_2.val_ref))) && (true)))) ==> ((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, (_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))))) == (m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_2.val_ref, _2_forall_67396f83e8cd4801ae45e414c98ae16e_101))):(false))) && ((forall _2_forall_86902255ca344ade8030c17ca05d40aa_101: Int  :: (((0) <= (_2_forall_86902255ca344ade8030c17ca05d40aa_101)) && (((_2_forall_86902255ca344ade8030c17ca05d40aa_101) < (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)))) && (true))) ==> ((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, _2_forall_86902255ca344ade8030c17ca05d40aa_101)) == (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, _2_forall_86902255ca344ade8030c17ca05d40aa_101))))) && (true))))
    Goto(cfg:16)
  label loop2_group3_bb9 // 16
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] _11 = const ()
    // [mir] goto -> bb10
    Goto(cfg:17)
  label loop2_group3_bb10 // 17
    // ========== loop2_group3_bb10 ==========
    __t8 := copy true
    // [mir] StorageDead(_12)
    // [mir] StorageDead(_11)
    // [mir] StorageLive(_16)
    // [mir] StorageLive(_17)
    // [mir] _17 = const false
    _17 := builtin$havoc_ref()
    inhale(Stmt) acc(_17.val_bool, write)
    _17.val_bool := copy false
    // [mir] switchInt(move _17) -> [false: bb12, otherwise: bb11]
    __t21 := copy _17.val_bool
    // Ignore default target bb11, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:18)
  label loop2_group3_bb12 // 18
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] _16 = const ()
    // [mir] goto -> bb13
    Goto(cfg:19)
  label loop2_group3_bb13 // 19
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_17)
    // [mir] StorageDead(_16)
    // [mir] StorageLive(_21)
    // [mir] StorageLive(_22)
    // [mir] _22 = const false
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_bool, write)
    _22.val_bool := copy false
    // [mir] switchInt(move _22) -> [false: bb15, otherwise: bb14]
    __t22 := copy _22.val_bool
    // Ignore default target bb14, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:20)
  label loop2_group3_bb15 // 20
    // ========== loop2_group3_bb15 ==========
    __t11 := copy true
    // [mir] _21 = const ()
    // [mir] goto -> bb16
    Goto(cfg:21)
  label loop2_group3_bb16 // 21
    // ========== loop2_group3_bb16 ==========
    __t12 := copy true
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageLive(_27)
    // [mir] StorageLive(_28)
    // [mir] _28 = const false
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_bool, write)
    _28.val_bool := copy false
    // [mir] switchInt(move _28) -> [false: bb18, otherwise: bb17]
    __t23 := copy _28.val_bool
    // Ignore default target bb17, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:22)
  label loop2_group3_bb18 // 22
    // ========== loop2_group3_bb18 ==========
    __t13 := copy true
    // [mir] _27 = const ()
    // [mir] goto -> bb19
    Goto(cfg:23)
  label loop2_group3_bb19 // 23
    // ========== loop2_group3_bb19 ==========
    __t14 := copy true
    // [mir] StorageDead(_28)
    // [mir] StorageDead(_27)
    // [mir] StorageLive(_31)
    // [mir] StorageLive(_32)
    // [mir] _32 = &'_ mut (*_1)
    _32 := builtin$havoc_ref()
    inhale(Stmt) acc(_32.val_ref, write)
    _32.val_ref := mut borrow _1.val_ref // L9
    label l9
    // [mir] StorageLive(_33)
    // [mir] StorageLive(_34)
    // [mir] _34 = &'_ (*_2)
    _34 := builtin$havoc_ref()
    inhale(Stmt) acc(_34.val_ref, write)
    _34.val_ref := borrow _2.val_ref // L15
    inhale(Stmt) acc(m_PrustiVec$_beg_$_end_(_34.val_ref), read)
    label l10
    // [mir] StorageLive(_35)
    // [mir] _35 = _3
    _35 := builtin$havoc_ref()
    inhale(Stmt) acc(_35.val_int, write)
    unfold acc(usize:None(_3), write)
    _35.val_int := copy _3.val_int
    label l11
    // [mir] _33 = PrustiVec::lookup(move _34, move _35) -> [return: bb20, unwind: bb23]
    label l12
    _33 := builtin$havoc_ref()
    inhale(Stmt) acc(u8(_33), write)
    unfold acc(u8:None(_33), write)
    inhale(Stmt) (_33.val_int) == (m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_34.val_ref, _35.val_int))
    transfer perm _34.val_ref --> old[l12](_34.val_ref) // unchecked: false
    Goto(cfg:24)
  label l13 // 24
    // ========== l13 ==========
    // MIR edge bb19 --> bb20
    // Expire borrows
    // expire_borrows ReborrowingDAG(L16,L15,)

    if (__t14) && (true) {
    // expire loan L16
} else {}
    if (__t14) && ((__t14) && (true)) {
    // expire loan L15
    transfer perm old[l12](_34.val_ref) --> old[l10](_34.val_ref) // unchecked: false
    exhale acc(m_PrustiVec$_beg_$_end_(old[l10](_34.val_ref)), read)
} else {}
    Goto(cfg:25)
  label loop2_group3_bb20 // 25
    // ========== loop2_group3_bb20 ==========
    __t15 := copy true
    // [mir] StorageDead(_35)
    // [mir] StorageDead(_34)
    // [mir] _31 = PrustiVec::push(move _32, move _33) -> [return: bb21, unwind: bb23]
    label l14
    assert(Stmt) true
    fold acc(u8:None(_33), write)
    assert(Stmt) (ref$m_PrustiVec$_beg_$_end_$inv<Ref(ref$m_PrustiVec$_beg_$_end_),Bool>(_32)) && ((u8$inv<Ref(u8),Bool>(_33)) && (true))
    exhale (acc(_32.val_ref, write)) && ((acc(m_PrustiVec$_beg_$_end_(_32.val_ref), write)) && ((acc(u8(_33), write)) && (true)))
    _31 := builtin$havoc_ref()
    inhale(Stmt) (acc(m_PrustiVec$_beg_$_end_(old[l14](_32.val_ref)), write)) && (true)
    inhale(Stmt) acc(tuple0$(_31), write)
    inhale(Stmt) (m_PrustiVec$_beg_$_end_$inv<Ref(m_PrustiVec$_beg_$_end_),Bool>(old[l14](_32.val_ref))) && ((tuple0$$inv<Ref(tuple0$),Bool>(_31)) && (true))
    inhale(Expr) ((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(old[l14](_32.val_ref))) == ((old[l14](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_32.val_ref))) + (1))):(false)) && (((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(old[l14](_32.val_ref))) >= (1)) && (((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(old[l14](_32.val_ref), (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(old[l14](_32.val_ref))) - (1))) == (old[l14](_33.val_int))):(false)) && ((forall _2_forall_44a22c27490449b4b921e331e47dcb60_101: Int  :: (((0) <= (_2_forall_44a22c27490449b4b921e331e47dcb60_101)) && (((_2_forall_44a22c27490449b4b921e331e47dcb60_101) < (old[l14](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_32.val_ref)))) && (true))) ==> ((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(old[l14](_32.val_ref), _2_forall_44a22c27490449b4b921e331e47dcb60_101)) == (old[l14](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_32.val_ref, _2_forall_44a22c27490449b4b921e331e47dcb60_101))))) && (true))))
    exhale true
    label l15
    Goto(cfg:26)
  label l16 // 26
    // ========== l16 ==========
    // MIR edge bb20 --> bb21
    // Expire borrows
    // expire_borrows ReborrowingDAG(L17,L9,)

    if (__t15) && (true) {
    // expire loan L17
} else {}
    if (__t14) && ((__t15) && (true)) {
    // expire loan L9
    transfer perm old[l14](_32.val_ref) --> old[l9](_32.val_ref) // unchecked: false
    transfer perm old[l9](_32.val_ref) --> _1.val_ref // unchecked: false
} else {}
    Goto(cfg:27)
  label loop2_group3_bb21 // 27
    // ========== loop2_group3_bb21 ==========
    __t16 := copy true
    // [mir] StorageDead(_33)
    // [mir] StorageDead(_32)
    // [mir] StorageDead(_31)
    // [mir] _36 = CheckedAdd(_3, const 1_usize)
    _36 := builtin$havoc_ref()
    inhale(Stmt) acc(_36.tuple_0, write)
    inhale(Stmt) acc(_36.tuple_0.val_int, write)
    inhale(Stmt) acc(_36.tuple_1, write)
    inhale(Stmt) acc(_36.tuple_1.val_bool, write)
    _36.tuple_0.val_int := copy (_3.val_int) + (1)
    _36.tuple_1.val_bool := copy false
    // [mir] assert(!move (_36.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_usize) -> [success: bb22, unwind: bb23]
    __t24 := copy _36.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t24)
    Goto(cfg:28)
  label loop2_group3_bb22 // 28
    // ========== loop2_group3_bb22 ==========
    __t17 := copy true
    // [mir] _3 = move (_36.0: usize)
    _3 := move _36.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:29)
  label loop2_group4_bb2 // 29
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb23]
    Goto(cfg:30)
  label loop2_group4_bb3 // 30
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _3
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _3.val_int
    label l18
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = &'_ (*_2)
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_ref, write)
    _10.val_ref := borrow _2.val_ref // L18
    inhale(Stmt) acc(m_PrustiVec$_beg_$_end_(_10.val_ref), read)
    label l19
    // [mir] _9 = PrustiVec::len(move _10) -> [return: bb4, unwind: bb23]
    label l20
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(usize(_9), write)
    unfold acc(usize:None(_9), write)
    inhale(Stmt) (_9.val_int) == (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_10.val_ref))
    transfer perm _10.val_ref --> old[l20](_10.val_ref) // unchecked: false
    Goto(cfg:31)
  label l21 // 31
    // ========== l21 ==========
    // MIR edge bb3 --> bb4
    // Expire borrows
    // expire_borrows ReborrowingDAG(L14,L18,)

    if (__t3) && (true) {
    // expire loan L14
} else {}
    if (__t3) && ((__t3) && (true)) {
    // expire loan L18
    transfer perm old[l20](_10.val_ref) --> old[l19](_10.val_ref) // unchecked: false
    exhale acc(m_PrustiVec$_beg_$_end_(old[l19](_10.val_ref)), read)
} else {}
    Goto(cfg:32)
  label loop2_group4_bb4 // 32
    // ========== loop2_group4_bb4 ==========
    __t4 := copy true
    // [mir] StorageDead(_10)
    // [mir] _7 = Lt(move _8, move _9)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (_9.val_int)
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb6, otherwise: bb5]
    __t25 := copy _7.val_bool
    GotoSwitch([(Local(__t25: Bool, Position { line: 0, column: 0, id: 0 }), cfg:34)], cfg:33)
  label l22 // 33
    // ========== l22 ==========
    // MIR edge bb4 --> bb6
    Goto(cfg:39)
  label l23 // 34
    // ========== l23 ==========
    // MIR edge bb4 --> bb5
    Goto(cfg:35)
  label loop2_group5_bb5 // 35
    // ========== loop2_group5_bb5 ==========
    __t5 := copy true
    // [mir] falseEdge -> [real: bb7, imaginary: bb6]
    Goto(cfg:36)
  label loop2_group5_bb7 // 36
    // ========== loop2_group5_bb7 ==========
    __t6 := copy true
    // [mir] StorageLive(_11)
    // [mir] StorageLive(_12)
    // [mir] _12 = const false
    _12 := builtin$havoc_ref()
    inhale(Stmt) acc(_12.val_bool, write)
    _12.val_bool := copy false
    // [mir] switchInt(move _12) -> [false: bb9, otherwise: bb8]
    __t26 := copy _12.val_bool
    // Ignore default target bb8, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:37)
  label loop2_end_body // 37
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    fold acc(bool:None(_7), write)
    obtain acc(bool(_7), write)
    fold acc(usize:None(_3), write)
    obtain acc(usize(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= ((unfolding acc(usize:None(_3), write) in _3.val_int))) && ((((unfolding acc(usize:None(_3), write) in _3.val_int)) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_2.val_ref))) && (true))) && (((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)) == ((old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))) + ((unfolding acc(usize:None(_3), write) in _3.val_int)))):(false)) && ((forall _2_forall_67396f83e8cd4801ae45e414c98ae16e_101: Int  :: ((((0) <= (_2_forall_67396f83e8cd4801ae45e414c98ae16e_101)) && (((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) < ((unfolding acc(usize:None(_3), write) in _3.val_int))) && (true))) && ((((!(false))?((0) <= ((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))))):(false)) && (((!(false))?(((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)))) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))):(false)) && (true))) && (((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_2.val_ref))) && (true)))) ==> ((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, (_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))))) == (m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_2.val_ref, _2_forall_67396f83e8cd4801ae45e414c98ae16e_101))):(false))) && ((forall _2_forall_86902255ca344ade8030c17ca05d40aa_101: Int  :: (((0) <= (_2_forall_86902255ca344ade8030c17ca05d40aa_101)) && (((_2_forall_86902255ca344ade8030c17ca05d40aa_101) < (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)))) && (true))) ==> ((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, _2_forall_86902255ca344ade8030c17ca05d40aa_101)) == (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, _2_forall_86902255ca344ade8030c17ca05d40aa_101))))) && (true))))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb6 // 38
    // ========== bb6 ==========
    __t18 := copy true
    // [mir] _0 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label l24 // 39
    // ========== l24 ==========
    // drop Acc(_22.val_bool, write) (Acc(_22.val_bool, write))
    // drop Acc(_36.tuple_0, write) (Acc(_36.tuple_0, write))
    // drop Acc(_34.val_ref, write) (Acc(_34.val_ref, write))
    // drop Acc(_36.tuple_1.val_bool, write) (Acc(_36.tuple_1.val_bool, write))
    // drop Acc(old[l19](_10.val_ref), write) (Acc(old[l19](_10.val_ref), write))
    // drop Acc(_28.val_bool, write) (Acc(_28.val_bool, write))
    // drop Acc(_17.val_bool, write) (Acc(_17.val_bool, write))
    // drop Acc(_35.val_int, write) (Acc(_35.val_int, write))
    // drop Acc(old[l10](_34.val_ref), write) (Acc(old[l10](_34.val_ref), write))
    // drop Pred(_31, write) (Pred(_31, write))
    // drop Acc(_36.tuple_1, write) (Acc(_36.tuple_1, write))
    Goto(cfg:38)
  label end_of_method
}


struct_predicate closure$0_448$3$16913811004204853985(self){
  true
}


struct_predicate ref$closure$0_448$3$16913811004204853985(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_448$3$16913811004204853985(self.val_ref), write)) && (true))
}


struct_predicate closure$0_450$3$8495963677228082619(self){
  true
}


struct_predicate ref$closure$0_450$3$8495963677228082619(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_450$3$8495963677228082619(self.val_ref), write)) && (true))
}


struct_predicate closure$0_449$3$2550123926576683856(self){
  true
}


struct_predicate ref$closure$0_449$3$2550123926576683856(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_449$3$2550123926576683856(self.val_ref), write)) && (true))
}


struct_predicate closure$0_451$3$1766526748840765837(self){
  true
}


struct_predicate ref$closure$0_451$3$1766526748840765837(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_451$3$1766526748840765837(self.val_ref), write)) && (true))
}


struct_predicate closure$0_452$3$211906123799298639(self){
  true
}


struct_predicate ref$closure$0_452$3$211906123799298639(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_452$3$211906123799298639(self.val_ref), write)) && (true))
}


function m_contains(_1: Ref(m_PrustiVec$_beg_$_end_), _2: Int): Bool
  requires (acc(m_PrustiVec$_beg_$_end_(_1), read)) && (true)
  requires true
  ensures ((__result) && ((forall _2_forall_470556b7f97a447c822e656db6f37b1d_102: Int  :: (((0) <= (_2_forall_470556b7f97a447c822e656db6f37b1d_102)) && (((_2_forall_470556b7f97a447c822e656db6f37b1d_102) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1))) && (true))) ==> (!((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1, _2_forall_470556b7f97a447c822e656db6f37b1d_102)) == (_2)))) && (true))) && (true)


struct_predicate ref$closure$0_178$3$4476728821056422335(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_178$3$4476728821056422335(self.val_ref), write)) && (true))
}


struct_predicate closure$0_180$3$12253080348307774663(self){
  true
}


struct_predicate ref$closure$0_180$3$12253080348307774663(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_180$3$12253080348307774663(self.val_ref), write)) && (true))
}


struct_predicate closure$0_182$3$12253080348307774663(self){
  true
}


struct_predicate ref$closure$0_182$3$12253080348307774663(self){
  (acc(self.val_ref, write)) && ((acc(closure$0_182$3$12253080348307774663(self.val_ref), write)) && (true))
}


method m_closure$$$opencur$closure$sharp$0$closecur$(3 args)
    returns (_0: Ref(u8))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    _old$pre$0: Ref(closure$0_178$3$4476728821056422335)
    _1: Ref(ref$closure$0_178$3$4476728821056422335)
    _2: Ref(u8)
    _3: Ref(u8)
    _4: Ref(tuple0$)
    _5: Ref(bool)
    _6: Ref(u8)
    _7: Ref(tuple0$)
    _8: Ref(bool)
  label start // 0
    // ========== start ==========
    // Def path: "main::closure::{closure#0}"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:426:15: 430:6 (#90)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(closure$0_178$3$4476728821056422335(_1.val_ref), read)) && ((acc(u8(_2), write)) && ((acc(u8(_3), write)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$closure$0_178$3$4476728821056422335$inv<Ref(ref$closure$0_178$3$4476728821056422335),Bool>(_1)) && ((u8$inv<Ref(u8),Bool>(_2)) && ((u8$inv<Ref(u8),Bool>(_3)) && (true)))
    inhale(Expr) (((unfolding acc(u8:None(_2), write) in _2.val_int)) > ((unfolding acc(u8:None(_3), write) in _3.val_int))) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l7
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(closure$0_178$3$4476728821056422335(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    fold acc(u8:None(_0), write)
    obtain acc(u8(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (((unfolding acc(u8:None(_0), write) in _0.val_int)) > (old[pre]((unfolding acc(u8:None(_3), write) in _3.val_int)))) && (true)
    // Assert type invariants
    assert(Stmt) (u8$inv<Ref(u8),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(closure$0_178$3$4476728821056422335(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(u8(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = const false
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_bool, write)
    _5.val_bool := copy false
    // [mir] switchInt(move _5) -> [false: bb2, otherwise: bb1]
    __t7 := copy _5.val_bool
    GotoSwitch([(UnaryOp(Not, Local(__t7: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:4)], cfg:3)
  label l0 // 3
    // ========== l0 ==========
    // MIR edge bb0 --> bb1
    Goto(cfg:5)
  label l1 // 4
    // ========== l1 ==========
    // MIR edge bb0 --> bb2
    Goto(cfg:6)
  label bb1 // 5
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] _4 = const ()
    // [mir] goto -> bb3
    Goto(cfg:7)
  label bb2 // 6
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] _4 = const ()
    // [mir] goto -> bb3
    Goto(cfg:7)
  label bb3 // 7
    // ========== bb3 ==========
    __t3 := copy true
    // [mir] StorageDead(_5)
    // [mir] StorageDead(_4)
    // [mir] StorageLive(_6)
    // [mir] _6 = _2
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_int, write)
    unfold acc(u8:None(_2), write)
    _6.val_int := copy _2.val_int
    label l2
    // [mir] FakeRead(ForLet, _6)
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = const false
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_bool, write)
    _8.val_bool := copy false
    // [mir] switchInt(move _8) -> [false: bb5, otherwise: bb4]
    __t8 := copy _8.val_bool
    GotoSwitch([(UnaryOp(Not, Local(__t8: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:9)], cfg:8)
  label l3 // 8
    // ========== l3 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:10)
  label l4 // 9
    // ========== l4 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:11)
  label bb4 // 10
    // ========== bb4 ==========
    __t4 := copy true
    // [mir] _7 = const ()
    // [mir] goto -> bb6
    Goto(cfg:12)
  label bb5 // 11
    // ========== bb5 ==========
    __t5 := copy true
    // [mir] _7 = const ()
    // [mir] goto -> bb6
    Goto(cfg:12)
  label bb6 // 12
    // ========== bb6 ==========
    __t6 := copy true
    // [mir] StorageDead(_8)
    // [mir] StorageDead(_7)
    // [mir] _0 = _6
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_int, write)
    _0.val_int := copy _6.val_int
    label l5
    // [mir] StorageDead(_6)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


