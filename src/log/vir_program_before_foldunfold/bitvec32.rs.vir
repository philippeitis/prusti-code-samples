function m_len(_1: Ref(m_BitVec32$_beg_$_end_)): Int
  requires (acc(m_BitVec32$_beg_$_end_(_1), read)) && (true)
  requires true
  ensures ((__result) == (32)) && (true)


function m_lookup(_1: Ref(m_BitVec32$_beg_$_end_), _2: Int): Bool
  requires (acc(m_BitVec32$_beg_$_end_(_1), read)) && (true)
  requires (((0) <= (_2)) && (((_2) < (m_len<Ref(m_BitVec32$_beg_$_end_),Int>(_1))) && (true))) && (true)
  ensures true


method m_reverse_bits_v(1 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    _preserve$0: Ref(AuxRef)
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    __t21: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(m_BitVec32$_beg_$_end_)
    _3: Ref(usize)
    _4: Ref(tuple0$)
    _5: Ref(tuple0$)
    _6: Ref(bool)
    _7: Ref(usize)
    _8: Ref(tuple0$)
    _9: Ref(bool)
    _10: Ref(closure$0_39$3$16937242213512687220)
    _11: Ref(ref$usize)
    _12: Ref(tuple0$)
    _13: Ref(bool)
    _14: Ref(closure$0_42$3$16555333086153632697)
    _15: Ref(ref$usize)
    _16: Ref(ref$m_BitVec32$_beg_$_end_)
    _17: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _18: Ref(tuple0$)
    _19: Ref(ref$m_BitVec32$_beg_$_end_)
    _20: Ref(usize)
    _21: Ref(bool)
    _22: Ref(ref$m_BitVec32$_beg_$_end_)
    _23: Ref(usize)
    _24: Ref(usize)
    _25: Ref(tuple2$usize$bool)
    _26: Ref(tuple2$usize$bool)
    _27: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "bitvec32::{impl#0}::reverse_bits_v"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bitvec32.rs:72:5: 92:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && (true))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && (true)
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l21
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_9f584e285a724495b6f399a712346a25_101: Int  :: (((0) <= (_2_forall_9f584e285a724495b6f399a712346a25_101)) && (((_2_forall_9f584e285a724495b6f399a712346a25_101) < (32)) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_0, _2_forall_9f584e285a724495b6f399a712346a25_101)) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$0, (31) - (_2_forall_9f584e285a724495b6f399a712346a25_101)))):(false))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_2)
    // [mir] _2 = BitVec32::zero() -> [return: bb1, unwind: bb17]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _2 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_2), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_2)) && (true)
    inhale(Expr) (forall _2_forall_a13b84307e2a48c5b4311c4a450c9117_101: Int  :: (((0) <= (_2_forall_a13b84307e2a48c5b4311c4a450c9117_101)) && (((_2_forall_a13b84307e2a48c5b4311c4a450c9117_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2, _2_forall_a13b84307e2a48c5b4311c4a450c9117_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _2)
    // [mir] StorageLive(_3)
    // [mir] _3 = const 0_usize
    _3 := builtin$havoc_ref()
    inhale(Stmt) acc(_3.val_int, write)
    _3.val_int := copy 0
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] _7 = _3
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_int, write)
    _7.val_int := copy _3.val_int
    label l2
    // [mir] _6 = Lt(move _7, const 32_usize)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_bool, write)
    _6.val_bool := copy (_7.val_int) < (32)
    // [mir] StorageDead(_7)
    // [mir] FakeRead(ForMatchedPlace, _6)
    // [mir] switchInt(_6) -> [false: bb5, otherwise: bb4]
    __t15 := copy _6.val_bool
    GotoSwitch([(Local(__t15: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:30)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_8)
    // [mir] StorageLive(_9)
    // [mir] _9 = const false
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy false
    // [mir] switchInt(move _9) -> [false: bb8, otherwise: bb7]
    __t16 := copy _9.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    obtain acc(bool(_6), write)
    obtain acc(usize(_3), write)
    obtain acc(m_BitVec32$_beg_$_end_(_2), write)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= (_3.val_int)) && (((_3.val_int) < (32)) && (true))) && ((forall _2_forall_1f30171d0b234a90a4fd745824942898_101: Int  :: (((0) <= (_2_forall_1f30171d0b234a90a4fd745824942898_101)) && (((_2_forall_1f30171d0b234a90a4fd745824942898_101) < (_3.val_int)) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2, _2_forall_1f30171d0b234a90a4fd745824942898_101)) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, (31) - (_2_forall_1f30171d0b234a90a4fd745824942898_101)))):(false))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_6), write)) && ((acc(usize(_3), write)) && ((acc(m_BitVec32$_beg_$_end_(_2), write)) && ((acc(_1.val_ref, read)) && (true))))
    __t21 := builtin$havoc_bool()
    __t19 := builtin$havoc_bool()
    _23 := builtin$havoc_ref()
    __t11 := builtin$havoc_bool()
    _22 := builtin$havoc_ref()
    _20 := builtin$havoc_ref()
    _21 := builtin$havoc_ref()
    _13 := builtin$havoc_ref()
    _9 := builtin$havoc_ref()
    _19 := builtin$havoc_ref()
    _3 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    _7 := builtin$havoc_ref()
    _24 := builtin$havoc_ref()
    _18 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    __t3 := builtin$havoc_bool()
    _6 := builtin$havoc_ref()
    __t2 := builtin$havoc_bool()
    _25 := builtin$havoc_ref()
    __t17 := builtin$havoc_bool()
    _26 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    __t4 := builtin$havoc_bool()
    __t12 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    __t20 := builtin$havoc_bool()
    __t6 := builtin$havoc_bool()
    __t18 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_6), write)) && ((acc(usize(_3), write)) && ((acc(m_BitVec32$_beg_$_end_(_2), write)) && ((acc(_1.val_ref, read)) && (true))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    inhale(Expr) (((0) <= (_3.val_int)) && (((_3.val_int) < (32)) && (true))) && ((forall _2_forall_1f30171d0b234a90a4fd745824942898_101: Int  :: (((0) <= (_2_forall_1f30171d0b234a90a4fd745824942898_101)) && (((_2_forall_1f30171d0b234a90a4fd745824942898_101) < (_3.val_int)) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2, _2_forall_1f30171d0b234a90a4fd745824942898_101)) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, (31) - (_2_forall_1f30171d0b234a90a4fd745824942898_101)))):(false))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _8 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_8)
    // [mir] StorageLive(_12)
    // [mir] StorageLive(_13)
    // [mir] _13 = const false
    _13 := builtin$havoc_ref()
    inhale(Stmt) acc(_13.val_bool, write)
    _13.val_bool := copy false
    // [mir] switchInt(move _13) -> [false: bb11, otherwise: bb10]
    __t17 := copy _13.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _12 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_13)
    // [mir] StorageDead(_12)
    // [mir] StorageLive(_18)
    // [mir] StorageLive(_19)
    // [mir] _19 = &'_ mut _2
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_ref, write)
    _19.val_ref := mut borrow _2 // L4
    label l5
    // [mir] StorageLive(_20)
    // [mir] _20 = _3
    _20 := builtin$havoc_ref()
    inhale(Stmt) acc(_20.val_int, write)
    _20.val_int := copy _3.val_int
    label l6
    // [mir] StorageLive(_21)
    // [mir] StorageLive(_22)
    // [mir] _22 = &'_ (*_1)
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_ref, write)
    _22.val_ref := borrow _1.val_ref // L9
    label l7
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] _24 = _3
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(_24.val_int, write)
    _24.val_int := copy _3.val_int
    label l8
    // [mir] _25 = CheckedSub(const 31_usize, _24)
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.tuple_0, write)
    inhale(Stmt) acc(_25.tuple_0.val_int, write)
    inhale(Stmt) acc(_25.tuple_1, write)
    inhale(Stmt) acc(_25.tuple_1.val_bool, write)
    _25.tuple_0.val_int := copy (31) - (_24.val_int)
    _25.tuple_1.val_bool := copy false
    // [mir] assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", const 31_usize, move _24) -> [success: bb13, unwind: bb17]
    __t18 := copy _25.tuple_1.val_bool
    // Rust assertion: attempt to subtract with overflow
    assert(Stmt) !(__t18)
    Goto(cfg:17)
  label loop2_group3_bb13 // 17
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] _23 = move (_25.0: usize)
    _23 := move _25.tuple_0
    label l9
    // [mir] StorageDead(_24)
    // [mir] _21 = BitVec32::lookup(move _22, move _23) -> [return: bb14, unwind: bb17]
    label l10
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_21), write)
    inhale(Stmt) (_21.val_bool) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_22.val_ref, _23.val_int))
    transfer perm _22.val_ref --> old[l10](_22.val_ref) // unchecked: false
    Goto(cfg:18)
  label l11 // 18
    // ========== l11 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    expire_borrows ReborrowingDAG(L8,L9,)

    Goto(cfg:19)
  label loop2_group3_bb14 // 19
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_22)
    // [mir] _18 = BitVec32::set_bit(move _19, move _20, move _21) -> [return: bb15, unwind: bb17]
    label l12
    assert(Stmt) (((0) <= (_20.val_int)) && (((_20.val_int) < (m_len<Ref(m_BitVec32$_beg_$_end_),Int>(_19.val_ref))) && (true))) && (true)
    assert(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_19)) && ((usize$inv<Ref(usize),Bool>(_20)) && ((bool$inv<Ref(bool),Bool>(_21)) && (true)))
    exhale (acc(_19.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_19.val_ref), write)) && ((acc(usize(_20), write)) && ((acc(bool(_21), write)) && (true))))
    _18 := builtin$havoc_ref()
    inhale(Stmt) (acc(m_BitVec32$_beg_$_end_(old[l12](_19.val_ref)), write)) && (true)
    inhale(Stmt) acc(tuple0$(_18), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(old[l12](_19.val_ref))) && ((tuple0$$inv<Ref(tuple0$),Bool>(_18)) && (true))
    inhale(Expr) ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l12](_19.val_ref), old[l12](_20.val_int))) == (old[l12](_21.val_bool))) && ((forall _2_forall_468bc94aca334c75ba1a154bfcb30c24_101: Int  :: (((0) <= (_2_forall_468bc94aca334c75ba1a154bfcb30c24_101)) && (((_2_forall_468bc94aca334c75ba1a154bfcb30c24_101) < (32)) && ((!((_2_forall_468bc94aca334c75ba1a154bfcb30c24_101) == (old[l12](_20.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l12](_19.val_ref), _2_forall_468bc94aca334c75ba1a154bfcb30c24_101)) == (old[l12](m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_19.val_ref, _2_forall_468bc94aca334c75ba1a154bfcb30c24_101))))) && (true))
    exhale true
    label l13
    Goto(cfg:20)
  label l14 // 20
    // ========== l14 ==========
    // MIR edge bb14 --> bb15
    // Expire borrows
    expire_borrows ReborrowingDAG(L10,L4,)

    Goto(cfg:21)
  label loop2_group3_bb15 // 21
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_21)
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_18)
    // [mir] _26 = CheckedAdd(_3, const 1_usize)
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.tuple_0, write)
    inhale(Stmt) acc(_26.tuple_0.val_int, write)
    inhale(Stmt) acc(_26.tuple_1, write)
    inhale(Stmt) acc(_26.tuple_1.val_bool, write)
    _26.tuple_0.val_int := copy (_3.val_int) + (1)
    _26.tuple_1.val_bool := copy false
    // [mir] assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_usize) -> [success: bb16, unwind: bb17]
    __t19 := copy _26.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t19)
    Goto(cfg:22)
  label loop2_group3_bb16 // 22
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _3 = move (_26.0: usize)
    _3 := move _26.tuple_0
    label l15
    // [mir] _5 = const ()
    // [mir] StorageDead(_6)
    // [mir] goto -> bb2
    Goto(cfg:23)
  label loop2_group4_bb2 // 23
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:24)
  label loop2_group4_bb3 // 24
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] _7 = _3
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_int, write)
    _7.val_int := copy _3.val_int
    label l16
    // [mir] _6 = Lt(move _7, const 32_usize)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_bool, write)
    _6.val_bool := copy (_7.val_int) < (32)
    // [mir] StorageDead(_7)
    // [mir] FakeRead(ForMatchedPlace, _6)
    // [mir] switchInt(_6) -> [false: bb5, otherwise: bb4]
    __t20 := copy _6.val_bool
    GotoSwitch([(Local(__t20: Bool, Position { line: 0, column: 0, id: 0 }), cfg:26)], cfg:25)
  label l17 // 25
    // ========== l17 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:30)
  label l18 // 26
    // ========== l18 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:27)
  label loop2_group5_bb4 // 27
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:28)
  label loop2_group5_bb6 // 28
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_8)
    // [mir] StorageLive(_9)
    // [mir] _9 = const false
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy false
    // [mir] switchInt(move _9) -> [false: bb8, otherwise: bb7]
    __t21 := copy _9.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:29)
  label loop2_end_body // 29
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    obtain acc(bool(_6), write)
    obtain acc(usize(_3), write)
    obtain acc(m_BitVec32$_beg_$_end_(_2), write)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= (_3.val_int)) && (((_3.val_int) < (32)) && (true))) && ((forall _2_forall_1f30171d0b234a90a4fd745824942898_101: Int  :: (((0) <= (_2_forall_1f30171d0b234a90a4fd745824942898_101)) && (((_2_forall_1f30171d0b234a90a4fd745824942898_101) < (_3.val_int)) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2, _2_forall_1f30171d0b234a90a4fd745824942898_101)) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, (31) - (_2_forall_1f30171d0b234a90a4fd745824942898_101)))):(false))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_6), write)) && ((acc(usize(_3), write)) && ((acc(m_BitVec32$_beg_$_end_(_2), write)) && ((acc(_1.val_ref, read)) && (true))))
    inhale(Stmt) false
    Return
  label bb5 // 30
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _4 = const ()
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_4)
    // [mir] _0 = move _2
    _0 := move _2
    label l19
    // [mir] StorageDead(_3)
    // [mir] StorageDead(_2)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_shl_v(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    _preserve$0: Ref(AuxRef)
    __t21: Bool
    __t22: Bool
    __t23: Bool
    __t24: Bool
    __t25: Bool
    __t26: Bool
    __t27: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(usize)
    _3: Ref(m_BitVec32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_70$3$16937242213512687220)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_73$3$9023550036500310881)
    _16: Ref(ref$usize)
    _17: Ref(ref$usize)
    _18: Ref(tuple0$)
    _19: Ref(bool)
    _20: Ref(closure$0_77$3$6618128591386032580)
    _21: Ref(ref$usize)
    _22: Ref(ref$usize)
    _23: Ref(ref$m_BitVec32$_beg_$_end_)
    _24: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _25: Ref(tuple0$)
    _26: Ref(bool)
    _27: Ref(closure$0_86$3$8499263419258397637)
    _28: Ref(ref$usize)
    _29: Ref(ref$m_BitVec32$_beg_$_end_)
    _30: Ref(tuple0$)
    _31: Ref(ref$m_BitVec32$_beg_$_end_)
    _32: Ref(usize)
    _33: Ref(bool)
    _34: Ref(ref$m_BitVec32$_beg_$_end_)
    _35: Ref(usize)
    _36: Ref(usize)
    _37: Ref(usize)
    _38: Ref(tuple2$usize$bool)
    _39: Ref(tuple2$usize$bool)
    _40: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "bitvec32::{impl#0}::shl_v"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bitvec32.rs:121:5: 151:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    __t16 := copy false
    __t17 := copy false
    __t18 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(usize(_2), write)) && (true)))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((usize$inv<Ref(usize),Bool>(_2)) && (true))
    inhale(Expr) ((0) <= (_2.val_int)) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l23
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_fc7007a249e843e4baa9bcb82c0776a1_101: Int  :: ((((0) <= (_2_forall_fc7007a249e843e4baa9bcb82c0776a1_101)) && (((_2_forall_fc7007a249e843e4baa9bcb82c0776a1_101) < (32)) && (true))) && ((((old[pre](_2.val_int)) <= (_2_forall_fc7007a249e843e4baa9bcb82c0776a1_101)) && (((!(false))?(((_2_forall_fc7007a249e843e4baa9bcb82c0776a1_101) - (old[pre](_2.val_int))) >= (0)):(false)) && (((!(false))?(((_2_forall_fc7007a249e843e4baa9bcb82c0776a1_101) - (old[pre](_2.val_int))) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_0, _2_forall_fc7007a249e843e4baa9bcb82c0776a1_101)) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$0, (_2_forall_fc7007a249e843e4baa9bcb82c0776a1_101) - (old[pre](_2.val_int))))):(false))) && ((forall _2_forall_f985ecf510a341edabd28ef3b0e216ac_101: Int  :: (((0) <= (_2_forall_f985ecf510a341edabd28ef3b0e216ac_101)) && (((_2_forall_f985ecf510a341edabd28ef3b0e216ac_101) < (old[pre](_2.val_int))) && (((_2_forall_f985ecf510a341edabd28ef3b0e216ac_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_0, _2_forall_f985ecf510a341edabd28ef3b0e216ac_101)))) && (true))
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BitVec32::zero() -> [return: bb1, unwind: bb23]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_a13b84307e2a48c5b4311c4a450c9117_101: Int  :: (((0) <= (_2_forall_a13b84307e2a48c5b4311c4a450c9117_101)) && (((_2_forall_a13b84307e2a48c5b4311c4a450c9117_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_a13b84307e2a48c5b4311c4a450c9117_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = _2
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy _2.val_int
    label l2
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb23]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l3
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t19 := copy _7.val_bool
    GotoSwitch([(Local(__t19: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l4 // 7
    // ========== l4 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:34)
  label l5 // 8
    // ========== l5 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t20 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(usize(_2), read)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((((_2.val_int) <= (_4.val_int)) && (((!(false))?(((_4.val_int) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_4.val_int) - (_2.val_int)) < (32)):(false)) && (true)))) && ((forall _2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101: Int  :: ((((0) <= (_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101)) && (((_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101) < (_4.val_int)) && (((_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101) >= (_2.val_int)) && (true)))) && ((((_2.val_int) <= (_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101)) && (((!(false))?(((_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101) - (_2.val_int)) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101)) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, (_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101) - (_2.val_int)))):(false))) && ((forall _2_forall_8704eb0236564e7eba146287c3dbb083_101: Int  :: (((0) <= (_2_forall_8704eb0236564e7eba146287c3dbb083_101)) && (((_2_forall_8704eb0236564e7eba146287c3dbb083_101) < (_2.val_int)) && (((_2_forall_8704eb0236564e7eba146287c3dbb083_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_8704eb0236564e7eba146287c3dbb083_101)))) && (true))))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    __t27 := builtin$havoc_bool()
    __t26 := builtin$havoc_bool()
    _35 := builtin$havoc_ref()
    _31 := builtin$havoc_ref()
    _14 := builtin$havoc_ref()
    _37 := builtin$havoc_ref()
    _4 := builtin$havoc_ref()
    _7 := builtin$havoc_ref()
    _38 := builtin$havoc_ref()
    _26 := builtin$havoc_ref()
    __t9 := builtin$havoc_bool()
    __t7 := builtin$havoc_bool()
    __t15 := builtin$havoc_bool()
    _8 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    _30 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    __t10 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    _33 := builtin$havoc_ref()
    _19 := builtin$havoc_ref()
    __t23 := builtin$havoc_bool()
    __t6 := builtin$havoc_bool()
    __t2 := builtin$havoc_bool()
    __t22 := builtin$havoc_bool()
    __t16 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    _10 := builtin$havoc_ref()
    __t24 := builtin$havoc_bool()
    __t12 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    __t8 := builtin$havoc_bool()
    __t21 := builtin$havoc_bool()
    _39 := builtin$havoc_ref()
    _34 := builtin$havoc_ref()
    __t17 := builtin$havoc_bool()
    _32 := builtin$havoc_ref()
    __t25 := builtin$havoc_bool()
    _36 := builtin$havoc_ref()
    __t14 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    inhale(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((((_2.val_int) <= (_4.val_int)) && (((!(false))?(((_4.val_int) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_4.val_int) - (_2.val_int)) < (32)):(false)) && (true)))) && ((forall _2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101: Int  :: ((((0) <= (_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101)) && (((_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101) < (_4.val_int)) && (((_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101) >= (_2.val_int)) && (true)))) && ((((_2.val_int) <= (_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101)) && (((!(false))?(((_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101) - (_2.val_int)) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101)) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, (_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101) - (_2.val_int)))):(false))) && ((forall _2_forall_8704eb0236564e7eba146287c3dbb083_101: Int  :: (((0) <= (_2_forall_8704eb0236564e7eba146287c3dbb083_101)) && (((_2_forall_8704eb0236564e7eba146287c3dbb083_101) < (_2.val_int)) && (((_2_forall_8704eb0236564e7eba146287c3dbb083_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_8704eb0236564e7eba146287c3dbb083_101)))) && (true))))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t21 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_18)
    // [mir] StorageLive(_19)
    // [mir] _19 = const false
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_bool, write)
    _19.val_bool := copy false
    // [mir] switchInt(move _19) -> [false: bb14, otherwise: bb13]
    __t22 := copy _19.val_bool
    // Ignore default target bb13, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:17)
  label loop2_group3_bb14 // 17
    // ========== loop2_group3_bb14 ==========
    __t10 := copy true
    // [mir] _18 = const ()
    // [mir] goto -> bb15
    Goto(cfg:18)
  label loop2_group3_bb15 // 18
    // ========== loop2_group3_bb15 ==========
    __t11 := copy true
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_18)
    // [mir] StorageLive(_25)
    // [mir] StorageLive(_26)
    // [mir] _26 = const false
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.val_bool, write)
    _26.val_bool := copy false
    // [mir] switchInt(move _26) -> [false: bb17, otherwise: bb16]
    __t23 := copy _26.val_bool
    // Ignore default target bb16, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:19)
  label loop2_group3_bb17 // 19
    // ========== loop2_group3_bb17 ==========
    __t12 := copy true
    // [mir] _25 = const ()
    // [mir] goto -> bb18
    Goto(cfg:20)
  label loop2_group3_bb18 // 20
    // ========== loop2_group3_bb18 ==========
    __t13 := copy true
    // [mir] StorageDead(_26)
    // [mir] StorageDead(_25)
    // [mir] StorageLive(_30)
    // [mir] StorageLive(_31)
    // [mir] _31 = &'_ mut _3
    _31 := builtin$havoc_ref()
    inhale(Stmt) acc(_31.val_ref, write)
    _31.val_ref := mut borrow _3 // L9
    label l6
    // [mir] StorageLive(_32)
    // [mir] _32 = _4
    _32 := builtin$havoc_ref()
    inhale(Stmt) acc(_32.val_int, write)
    _32.val_int := copy _4.val_int
    label l7
    // [mir] StorageLive(_33)
    // [mir] StorageLive(_34)
    // [mir] _34 = &'_ (*_1)
    _34 := builtin$havoc_ref()
    inhale(Stmt) acc(_34.val_ref, write)
    _34.val_ref := borrow _1.val_ref // L15
    label l8
    // [mir] StorageLive(_35)
    // [mir] StorageLive(_36)
    // [mir] _36 = _4
    _36 := builtin$havoc_ref()
    inhale(Stmt) acc(_36.val_int, write)
    _36.val_int := copy _4.val_int
    label l9
    // [mir] StorageLive(_37)
    // [mir] _37 = _2
    _37 := builtin$havoc_ref()
    inhale(Stmt) acc(_37.val_int, write)
    _37.val_int := copy _2.val_int
    label l10
    // [mir] _38 = CheckedSub(_36, _37)
    _38 := builtin$havoc_ref()
    inhale(Stmt) acc(_38.tuple_0, write)
    inhale(Stmt) acc(_38.tuple_0.val_int, write)
    inhale(Stmt) acc(_38.tuple_1, write)
    inhale(Stmt) acc(_38.tuple_1.val_bool, write)
    _38.tuple_0.val_int := copy (_36.val_int) - (_37.val_int)
    _38.tuple_1.val_bool := copy false
    // [mir] assert(!move (_38.1: bool), "attempt to compute `{} - {}`, which would overflow", move _36, move _37) -> [success: bb19, unwind: bb23]
    __t24 := copy _38.tuple_1.val_bool
    // Rust assertion: attempt to subtract with overflow
    assert(Stmt) !(__t24)
    Goto(cfg:21)
  label loop2_group3_bb19 // 21
    // ========== loop2_group3_bb19 ==========
    __t14 := copy true
    // [mir] _35 = move (_38.0: usize)
    _35 := move _38.tuple_0
    label l11
    // [mir] StorageDead(_37)
    // [mir] StorageDead(_36)
    // [mir] _33 = BitVec32::lookup(move _34, move _35) -> [return: bb20, unwind: bb23]
    label l12
    _33 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_33), write)
    inhale(Stmt) (_33.val_bool) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_34.val_ref, _35.val_int))
    transfer perm _34.val_ref --> old[l12](_34.val_ref) // unchecked: false
    Goto(cfg:22)
  label l13 // 22
    // ========== l13 ==========
    // MIR edge bb19 --> bb20
    // Expire borrows
    expire_borrows ReborrowingDAG(L13,L15,)

    Goto(cfg:23)
  label loop2_group3_bb20 // 23
    // ========== loop2_group3_bb20 ==========
    __t15 := copy true
    // [mir] StorageDead(_35)
    // [mir] StorageDead(_34)
    // [mir] _30 = BitVec32::set_bit(move _31, move _32, move _33) -> [return: bb21, unwind: bb23]
    label l14
    assert(Stmt) (((0) <= (_32.val_int)) && (((_32.val_int) < (m_len<Ref(m_BitVec32$_beg_$_end_),Int>(_31.val_ref))) && (true))) && (true)
    assert(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_31)) && ((usize$inv<Ref(usize),Bool>(_32)) && ((bool$inv<Ref(bool),Bool>(_33)) && (true)))
    exhale (acc(_31.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_31.val_ref), write)) && ((acc(usize(_32), write)) && ((acc(bool(_33), write)) && (true))))
    _30 := builtin$havoc_ref()
    inhale(Stmt) (acc(m_BitVec32$_beg_$_end_(old[l14](_31.val_ref)), write)) && (true)
    inhale(Stmt) acc(tuple0$(_30), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(old[l14](_31.val_ref))) && ((tuple0$$inv<Ref(tuple0$),Bool>(_30)) && (true))
    inhale(Expr) ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l14](_31.val_ref), old[l14](_32.val_int))) == (old[l14](_33.val_bool))) && ((forall _2_forall_468bc94aca334c75ba1a154bfcb30c24_101: Int  :: (((0) <= (_2_forall_468bc94aca334c75ba1a154bfcb30c24_101)) && (((_2_forall_468bc94aca334c75ba1a154bfcb30c24_101) < (32)) && ((!((_2_forall_468bc94aca334c75ba1a154bfcb30c24_101) == (old[l14](_32.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l14](_31.val_ref), _2_forall_468bc94aca334c75ba1a154bfcb30c24_101)) == (old[l14](m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_31.val_ref, _2_forall_468bc94aca334c75ba1a154bfcb30c24_101))))) && (true))
    exhale true
    label l15
    Goto(cfg:24)
  label l16 // 24
    // ========== l16 ==========
    // MIR edge bb20 --> bb21
    // Expire borrows
    expire_borrows ReborrowingDAG(L14,L9,)

    Goto(cfg:25)
  label loop2_group3_bb21 // 25
    // ========== loop2_group3_bb21 ==========
    __t16 := copy true
    // [mir] StorageDead(_33)
    // [mir] StorageDead(_32)
    // [mir] StorageDead(_31)
    // [mir] StorageDead(_30)
    // [mir] _39 = CheckedAdd(_4, const 1_usize)
    _39 := builtin$havoc_ref()
    inhale(Stmt) acc(_39.tuple_0, write)
    inhale(Stmt) acc(_39.tuple_0.val_int, write)
    inhale(Stmt) acc(_39.tuple_1, write)
    inhale(Stmt) acc(_39.tuple_1.val_bool, write)
    _39.tuple_0.val_int := copy (_4.val_int) + (1)
    _39.tuple_1.val_bool := copy false
    // [mir] assert(!move (_39.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb22, unwind: bb23]
    __t25 := copy _39.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t25)
    Goto(cfg:26)
  label loop2_group3_bb22 // 26
    // ========== loop2_group3_bb22 ==========
    __t17 := copy true
    // [mir] _4 = move (_39.0: usize)
    _4 := move _39.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:27)
  label loop2_group4_bb2 // 27
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb23]
    Goto(cfg:28)
  label loop2_group4_bb3 // 28
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l18
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t26 := copy _7.val_bool
    GotoSwitch([(Local(__t26: Bool, Position { line: 0, column: 0, id: 0 }), cfg:30)], cfg:29)
  label l19 // 29
    // ========== l19 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:34)
  label l20 // 30
    // ========== l20 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:31)
  label loop2_group5_bb4 // 31
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:32)
  label loop2_group5_bb6 // 32
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t27 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:33)
  label loop2_end_body // 33
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(usize(_2), read)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((((_2.val_int) <= (_4.val_int)) && (((!(false))?(((_4.val_int) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_4.val_int) - (_2.val_int)) < (32)):(false)) && (true)))) && ((forall _2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101: Int  :: ((((0) <= (_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101)) && (((_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101) < (_4.val_int)) && (((_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101) >= (_2.val_int)) && (true)))) && ((((_2.val_int) <= (_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101)) && (((!(false))?(((_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101) - (_2.val_int)) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101)) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, (_2_forall_5f7b2cd0a4154b6fbff84f6c8b7a02ce_101) - (_2.val_int)))):(false))) && ((forall _2_forall_8704eb0236564e7eba146287c3dbb083_101: Int  :: (((0) <= (_2_forall_8704eb0236564e7eba146287c3dbb083_101)) && (((_2_forall_8704eb0236564e7eba146287c3dbb083_101) < (_2.val_int)) && (((_2_forall_8704eb0236564e7eba146287c3dbb083_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_8704eb0236564e7eba146287c3dbb083_101)))) && (true))))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 34
    // ========== bb5 ==========
    __t18 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l21
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_or_v(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _old$pre$1: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(ref$m_BitVec32$_beg_$_end_)
    _3: Ref(m_BitVec32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_115$3$16937242213512687220)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_118$3$11857201229351369724)
    _16: Ref(ref$usize)
    _17: Ref(ref$m_BitVec32$_beg_$_end_)
    _18: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _19: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _20: Ref(tuple0$)
    _21: Ref(ref$m_BitVec32$_beg_$_end_)
    _22: Ref(usize)
    _23: Ref(bool)
    _24: Ref(bool)
    _25: Ref(ref$m_BitVec32$_beg_$_end_)
    _26: Ref(usize)
    _27: Ref(bool)
    _28: Ref(ref$m_BitVec32$_beg_$_end_)
    _29: Ref(usize)
    _30: Ref(tuple2$usize$bool)
    _31: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "bitvec32::{impl#0}::or_v"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bitvec32.rs:238:5: 252:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l24
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BitVec32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_2a12cf01b79948ddab16aef74f5e1252_101: Int  :: (((0) <= (_2_forall_2a12cf01b79948ddab16aef74f5e1252_101)) && (((_2_forall_2a12cf01b79948ddab16aef74f5e1252_101) < (32)) && (true))) ==> ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_0, _2_forall_2a12cf01b79948ddab16aef74f5e1252_101)) == ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$0, _2_forall_2a12cf01b79948ddab16aef74f5e1252_101)) || (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$1, _2_forall_2a12cf01b79948ddab16aef74f5e1252_101))))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BitVec32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BitVec32::zero() -> [return: bb1, unwind: bb17]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_a13b84307e2a48c5b4311c4a450c9117_101: Int  :: (((0) <= (_2_forall_a13b84307e2a48c5b4311c4a450c9117_101)) && (((_2_forall_a13b84307e2a48c5b4311c4a450c9117_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_a13b84307e2a48c5b4311c4a450c9117_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = const 0_usize
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy 0
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l2
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t15 := copy _7.val_bool
    GotoSwitch([(Local(__t15: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t16 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    _preserve$1 := ghost _2.val_ref
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_11b5b70d03f541a7b2045fa5d678ad2d_101: Int  :: (((0) <= (_2_forall_11b5b70d03f541a7b2045fa5d678ad2d_101)) && (((_2_forall_11b5b70d03f541a7b2045fa5d678ad2d_101) < (_4.val_int)) && (true))) ==> ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_11b5b70d03f541a7b2045fa5d678ad2d_101)) == ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_11b5b70d03f541a7b2045fa5d678ad2d_101)) || (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_11b5b70d03f541a7b2045fa5d678ad2d_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    __t10 := builtin$havoc_bool()
    _7 := builtin$havoc_ref()
    __t2 := builtin$havoc_bool()
    _23 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    __t19 := builtin$havoc_bool()
    _30 := builtin$havoc_ref()
    __t6 := builtin$havoc_bool()
    _25 := builtin$havoc_ref()
    _29 := builtin$havoc_ref()
    __t12 := builtin$havoc_bool()
    _21 := builtin$havoc_ref()
    __t13 := builtin$havoc_bool()
    _14 := builtin$havoc_ref()
    __t5 := builtin$havoc_bool()
    _22 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    _24 := builtin$havoc_ref()
    __t18 := builtin$havoc_bool()
    __t4 := builtin$havoc_bool()
    _8 := builtin$havoc_ref()
    _10 := builtin$havoc_ref()
    _20 := builtin$havoc_ref()
    _26 := builtin$havoc_ref()
    __t17 := builtin$havoc_bool()
    __t3 := builtin$havoc_bool()
    _4 := builtin$havoc_ref()
    __t20 := builtin$havoc_bool()
    _27 := builtin$havoc_ref()
    __t11 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    _28 := builtin$havoc_ref()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_11b5b70d03f541a7b2045fa5d678ad2d_101: Int  :: (((0) <= (_2_forall_11b5b70d03f541a7b2045fa5d678ad2d_101)) && (((_2_forall_11b5b70d03f541a7b2045fa5d678ad2d_101) < (_4.val_int)) && (true))) ==> ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_11b5b70d03f541a7b2045fa5d678ad2d_101)) == ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_11b5b70d03f541a7b2045fa5d678ad2d_101)) || (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_11b5b70d03f541a7b2045fa5d678ad2d_101))))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t17 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'_ mut _3
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_ref, write)
    _21.val_ref := mut borrow _3 // L5
    label l5
    // [mir] StorageLive(_22)
    // [mir] _22 = _4
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_int, write)
    _22.val_int := copy _4.val_int
    label l6
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] StorageLive(_25)
    // [mir] _25 = &'_ (*_1)
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_ref, write)
    _25.val_ref := borrow _1.val_ref // L13
    label l7
    // [mir] StorageLive(_26)
    // [mir] _26 = _4
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.val_int, write)
    _26.val_int := copy _4.val_int
    label l8
    // [mir] _24 = BitVec32::lookup(move _25, move _26) -> [return: bb13, unwind: bb17]
    label l9
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_24), write)
    inhale(Stmt) (_24.val_bool) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_25.val_ref, _26.val_int))
    transfer perm _25.val_ref --> old[l9](_25.val_ref) // unchecked: false
    Goto(cfg:17)
  label l10 // 17
    // ========== l10 ==========
    // MIR edge bb12 --> bb13
    // Expire borrows
    expire_borrows ReborrowingDAG(L10,L13,)

    Goto(cfg:18)
  label loop2_group3_bb13 // 18
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_26)
    // [mir] StorageDead(_25)
    // [mir] StorageLive(_27)
    // [mir] StorageLive(_28)
    // [mir] _28 = &'_ (*_2)
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_ref, write)
    _28.val_ref := borrow _2.val_ref // L11
    label l11
    // [mir] StorageLive(_29)
    // [mir] _29 = _4
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.val_int, write)
    _29.val_int := copy _4.val_int
    label l12
    // [mir] _27 = BitVec32::lookup(move _28, move _29) -> [return: bb14, unwind: bb17]
    label l13
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_27), write)
    inhale(Stmt) (_27.val_bool) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_28.val_ref, _29.val_int))
    transfer perm _28.val_ref --> old[l13](_28.val_ref) // unchecked: false
    Goto(cfg:19)
  label l14 // 19
    // ========== l14 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    expire_borrows ReborrowingDAG(L12,L11,)

    Goto(cfg:20)
  label loop2_group3_bb14 // 20
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_29)
    // [mir] StorageDead(_28)
    // [mir] _23 = BitOr(move _24, move _27)
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(_23.val_bool, write)
    _23.val_bool := copy (_24.val_bool) || (_27.val_bool)
    // [mir] StorageDead(_27)
    // [mir] StorageDead(_24)
    // [mir] _20 = BitVec32::set_bit(move _21, move _22, move _23) -> [return: bb15, unwind: bb17]
    label l15
    assert(Stmt) (((0) <= (_22.val_int)) && (((_22.val_int) < (m_len<Ref(m_BitVec32$_beg_$_end_),Int>(_21.val_ref))) && (true))) && (true)
    assert(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_21)) && ((usize$inv<Ref(usize),Bool>(_22)) && ((bool$inv<Ref(bool),Bool>(_23)) && (true)))
    exhale (acc(_21.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_21.val_ref), write)) && ((acc(usize(_22), write)) && ((acc(bool(_23), write)) && (true))))
    _20 := builtin$havoc_ref()
    inhale(Stmt) (acc(m_BitVec32$_beg_$_end_(old[l15](_21.val_ref)), write)) && (true)
    inhale(Stmt) acc(tuple0$(_20), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(old[l15](_21.val_ref))) && ((tuple0$$inv<Ref(tuple0$),Bool>(_20)) && (true))
    inhale(Expr) ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l15](_21.val_ref), old[l15](_22.val_int))) == (old[l15](_23.val_bool))) && ((forall _2_forall_468bc94aca334c75ba1a154bfcb30c24_101: Int  :: (((0) <= (_2_forall_468bc94aca334c75ba1a154bfcb30c24_101)) && (((_2_forall_468bc94aca334c75ba1a154bfcb30c24_101) < (32)) && ((!((_2_forall_468bc94aca334c75ba1a154bfcb30c24_101) == (old[l15](_22.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l15](_21.val_ref), _2_forall_468bc94aca334c75ba1a154bfcb30c24_101)) == (old[l15](m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_21.val_ref, _2_forall_468bc94aca334c75ba1a154bfcb30c24_101))))) && (true))
    exhale true
    label l16
    Goto(cfg:21)
  label l17 // 21
    // ========== l17 ==========
    // MIR edge bb14 --> bb15
    // Expire borrows
    expire_borrows ReborrowingDAG(L14,L5,)

    Goto(cfg:22)
  label loop2_group3_bb15 // 22
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageDead(_20)
    // [mir] _30 = CheckedAdd(_4, const 1_usize)
    _30 := builtin$havoc_ref()
    inhale(Stmt) acc(_30.tuple_0, write)
    inhale(Stmt) acc(_30.tuple_0.val_int, write)
    inhale(Stmt) acc(_30.tuple_1, write)
    inhale(Stmt) acc(_30.tuple_1.val_bool, write)
    _30.tuple_0.val_int := copy (_4.val_int) + (1)
    _30.tuple_1.val_bool := copy false
    // [mir] assert(!move (_30.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb16, unwind: bb17]
    __t18 := copy _30.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t18)
    Goto(cfg:23)
  label loop2_group3_bb16 // 23
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _4 = move (_30.0: usize)
    _4 := move _30.tuple_0
    label l18
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:24)
  label loop2_group4_bb2 // 24
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:25)
  label loop2_group4_bb3 // 25
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l19
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t19 := copy _7.val_bool
    GotoSwitch([(Local(__t19: Bool, Position { line: 0, column: 0, id: 0 }), cfg:27)], cfg:26)
  label l20 // 26
    // ========== l20 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l21 // 27
    // ========== l21 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:28)
  label loop2_group5_bb4 // 28
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:29)
  label loop2_group5_bb6 // 29
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t20 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:30)
  label loop2_end_body // 30
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_11b5b70d03f541a7b2045fa5d678ad2d_101: Int  :: (((0) <= (_2_forall_11b5b70d03f541a7b2045fa5d678ad2d_101)) && (((_2_forall_11b5b70d03f541a7b2045fa5d678ad2d_101) < (_4.val_int)) && (true))) ==> ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_11b5b70d03f541a7b2045fa5d678ad2d_101)) == ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_11b5b70d03f541a7b2045fa5d678ad2d_101)) || (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_11b5b70d03f541a7b2045fa5d678ad2d_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 31
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l22
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_and_v(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _old$pre$1: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(ref$m_BitVec32$_beg_$_end_)
    _3: Ref(m_BitVec32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_135$3$16937242213512687220)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_138$3$11857201229351369724)
    _16: Ref(ref$usize)
    _17: Ref(ref$m_BitVec32$_beg_$_end_)
    _18: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _19: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _20: Ref(tuple0$)
    _21: Ref(ref$m_BitVec32$_beg_$_end_)
    _22: Ref(usize)
    _23: Ref(bool)
    _24: Ref(bool)
    _25: Ref(ref$m_BitVec32$_beg_$_end_)
    _26: Ref(usize)
    _27: Ref(bool)
    _28: Ref(ref$m_BitVec32$_beg_$_end_)
    _29: Ref(usize)
    _30: Ref(tuple2$usize$bool)
    _31: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "bitvec32::{impl#0}::and_v"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bitvec32.rs:270:5: 284:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l24
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BitVec32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_5e212df7634043efb6f2490a16f56864_101: Int  :: (((0) <= (_2_forall_5e212df7634043efb6f2490a16f56864_101)) && (((_2_forall_5e212df7634043efb6f2490a16f56864_101) < (32)) && (true))) ==> ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_0, _2_forall_5e212df7634043efb6f2490a16f56864_101)) == ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$0, _2_forall_5e212df7634043efb6f2490a16f56864_101)) && (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$1, _2_forall_5e212df7634043efb6f2490a16f56864_101))))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BitVec32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BitVec32::zero() -> [return: bb1, unwind: bb17]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_a13b84307e2a48c5b4311c4a450c9117_101: Int  :: (((0) <= (_2_forall_a13b84307e2a48c5b4311c4a450c9117_101)) && (((_2_forall_a13b84307e2a48c5b4311c4a450c9117_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_a13b84307e2a48c5b4311c4a450c9117_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = const 0_usize
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy 0
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l2
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t15 := copy _7.val_bool
    GotoSwitch([(Local(__t15: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t16 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    _preserve$1 := ghost _2.val_ref
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_006c7dd7bca940c388375516165c2112_101: Int  :: (((0) <= (_2_forall_006c7dd7bca940c388375516165c2112_101)) && (((_2_forall_006c7dd7bca940c388375516165c2112_101) < (_4.val_int)) && (true))) ==> ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_006c7dd7bca940c388375516165c2112_101)) == ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_006c7dd7bca940c388375516165c2112_101)) && (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_006c7dd7bca940c388375516165c2112_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    _22 := builtin$havoc_ref()
    _4 := builtin$havoc_ref()
    _24 := builtin$havoc_ref()
    __t18 := builtin$havoc_bool()
    __t4 := builtin$havoc_bool()
    __t19 := builtin$havoc_bool()
    _27 := builtin$havoc_ref()
    _23 := builtin$havoc_ref()
    _21 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    _20 := builtin$havoc_ref()
    _8 := builtin$havoc_ref()
    _26 := builtin$havoc_ref()
    __t2 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    _25 := builtin$havoc_ref()
    __t20 := builtin$havoc_bool()
    __t7 := builtin$havoc_bool()
    _14 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    __t17 := builtin$havoc_bool()
    _29 := builtin$havoc_ref()
    _7 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    __t12 := builtin$havoc_bool()
    _30 := builtin$havoc_ref()
    __t13 := builtin$havoc_bool()
    __t6 := builtin$havoc_bool()
    _10 := builtin$havoc_ref()
    _28 := builtin$havoc_ref()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_006c7dd7bca940c388375516165c2112_101: Int  :: (((0) <= (_2_forall_006c7dd7bca940c388375516165c2112_101)) && (((_2_forall_006c7dd7bca940c388375516165c2112_101) < (_4.val_int)) && (true))) ==> ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_006c7dd7bca940c388375516165c2112_101)) == ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_006c7dd7bca940c388375516165c2112_101)) && (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_006c7dd7bca940c388375516165c2112_101))))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t17 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'_ mut _3
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_ref, write)
    _21.val_ref := mut borrow _3 // L5
    label l5
    // [mir] StorageLive(_22)
    // [mir] _22 = _4
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_int, write)
    _22.val_int := copy _4.val_int
    label l6
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] StorageLive(_25)
    // [mir] _25 = &'_ (*_1)
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_ref, write)
    _25.val_ref := borrow _1.val_ref // L12
    label l7
    // [mir] StorageLive(_26)
    // [mir] _26 = _4
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.val_int, write)
    _26.val_int := copy _4.val_int
    label l8
    // [mir] _24 = BitVec32::lookup(move _25, move _26) -> [return: bb13, unwind: bb17]
    label l9
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_24), write)
    inhale(Stmt) (_24.val_bool) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_25.val_ref, _26.val_int))
    transfer perm _25.val_ref --> old[l9](_25.val_ref) // unchecked: false
    Goto(cfg:17)
  label l10 // 17
    // ========== l10 ==========
    // MIR edge bb12 --> bb13
    // Expire borrows
    expire_borrows ReborrowingDAG(L13,L12,)

    Goto(cfg:18)
  label loop2_group3_bb13 // 18
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_26)
    // [mir] StorageDead(_25)
    // [mir] StorageLive(_27)
    // [mir] StorageLive(_28)
    // [mir] _28 = &'_ (*_2)
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_ref, write)
    _28.val_ref := borrow _2.val_ref // L11
    label l11
    // [mir] StorageLive(_29)
    // [mir] _29 = _4
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.val_int, write)
    _29.val_int := copy _4.val_int
    label l12
    // [mir] _27 = BitVec32::lookup(move _28, move _29) -> [return: bb14, unwind: bb17]
    label l13
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_27), write)
    inhale(Stmt) (_27.val_bool) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_28.val_ref, _29.val_int))
    transfer perm _28.val_ref --> old[l13](_28.val_ref) // unchecked: false
    Goto(cfg:19)
  label l14 // 19
    // ========== l14 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    expire_borrows ReborrowingDAG(L14,L11,)

    Goto(cfg:20)
  label loop2_group3_bb14 // 20
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_29)
    // [mir] StorageDead(_28)
    // [mir] _23 = BitAnd(move _24, move _27)
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(_23.val_bool, write)
    _23.val_bool := copy (_24.val_bool) && (_27.val_bool)
    // [mir] StorageDead(_27)
    // [mir] StorageDead(_24)
    // [mir] _20 = BitVec32::set_bit(move _21, move _22, move _23) -> [return: bb15, unwind: bb17]
    label l15
    assert(Stmt) (((0) <= (_22.val_int)) && (((_22.val_int) < (m_len<Ref(m_BitVec32$_beg_$_end_),Int>(_21.val_ref))) && (true))) && (true)
    assert(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_21)) && ((usize$inv<Ref(usize),Bool>(_22)) && ((bool$inv<Ref(bool),Bool>(_23)) && (true)))
    exhale (acc(_21.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_21.val_ref), write)) && ((acc(usize(_22), write)) && ((acc(bool(_23), write)) && (true))))
    _20 := builtin$havoc_ref()
    inhale(Stmt) (acc(m_BitVec32$_beg_$_end_(old[l15](_21.val_ref)), write)) && (true)
    inhale(Stmt) acc(tuple0$(_20), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(old[l15](_21.val_ref))) && ((tuple0$$inv<Ref(tuple0$),Bool>(_20)) && (true))
    inhale(Expr) ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l15](_21.val_ref), old[l15](_22.val_int))) == (old[l15](_23.val_bool))) && ((forall _2_forall_468bc94aca334c75ba1a154bfcb30c24_101: Int  :: (((0) <= (_2_forall_468bc94aca334c75ba1a154bfcb30c24_101)) && (((_2_forall_468bc94aca334c75ba1a154bfcb30c24_101) < (32)) && ((!((_2_forall_468bc94aca334c75ba1a154bfcb30c24_101) == (old[l15](_22.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l15](_21.val_ref), _2_forall_468bc94aca334c75ba1a154bfcb30c24_101)) == (old[l15](m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_21.val_ref, _2_forall_468bc94aca334c75ba1a154bfcb30c24_101))))) && (true))
    exhale true
    label l16
    Goto(cfg:21)
  label l17 // 21
    // ========== l17 ==========
    // MIR edge bb14 --> bb15
    // Expire borrows
    expire_borrows ReborrowingDAG(L10,L5,)

    Goto(cfg:22)
  label loop2_group3_bb15 // 22
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageDead(_20)
    // [mir] _30 = CheckedAdd(_4, const 1_usize)
    _30 := builtin$havoc_ref()
    inhale(Stmt) acc(_30.tuple_0, write)
    inhale(Stmt) acc(_30.tuple_0.val_int, write)
    inhale(Stmt) acc(_30.tuple_1, write)
    inhale(Stmt) acc(_30.tuple_1.val_bool, write)
    _30.tuple_0.val_int := copy (_4.val_int) + (1)
    _30.tuple_1.val_bool := copy false
    // [mir] assert(!move (_30.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb16, unwind: bb17]
    __t18 := copy _30.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t18)
    Goto(cfg:23)
  label loop2_group3_bb16 // 23
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _4 = move (_30.0: usize)
    _4 := move _30.tuple_0
    label l18
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:24)
  label loop2_group4_bb2 // 24
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:25)
  label loop2_group4_bb3 // 25
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l19
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t19 := copy _7.val_bool
    GotoSwitch([(Local(__t19: Bool, Position { line: 0, column: 0, id: 0 }), cfg:27)], cfg:26)
  label l20 // 26
    // ========== l20 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l21 // 27
    // ========== l21 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:28)
  label loop2_group5_bb4 // 28
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:29)
  label loop2_group5_bb6 // 29
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t20 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:30)
  label loop2_end_body // 30
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_006c7dd7bca940c388375516165c2112_101: Int  :: (((0) <= (_2_forall_006c7dd7bca940c388375516165c2112_101)) && (((_2_forall_006c7dd7bca940c388375516165c2112_101) < (_4.val_int)) && (true))) ==> ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_006c7dd7bca940c388375516165c2112_101)) == ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_006c7dd7bca940c388375516165c2112_101)) && (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_006c7dd7bca940c388375516165c2112_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 31
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l22
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_xor_v(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _old$pre$1: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(ref$m_BitVec32$_beg_$_end_)
    _3: Ref(m_BitVec32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_155$3$16937242213512687220)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_158$3$11857201229351369724)
    _16: Ref(ref$usize)
    _17: Ref(ref$m_BitVec32$_beg_$_end_)
    _18: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _19: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _20: Ref(tuple0$)
    _21: Ref(ref$m_BitVec32$_beg_$_end_)
    _22: Ref(usize)
    _23: Ref(bool)
    _24: Ref(bool)
    _25: Ref(ref$m_BitVec32$_beg_$_end_)
    _26: Ref(usize)
    _27: Ref(bool)
    _28: Ref(ref$m_BitVec32$_beg_$_end_)
    _29: Ref(usize)
    _30: Ref(tuple2$usize$bool)
    _31: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "bitvec32::{impl#0}::xor_v"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bitvec32.rs:301:5: 315:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l24
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BitVec32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_45102f7914104e988ec322b5451ba182_101: Int  :: (((0) <= (_2_forall_45102f7914104e988ec322b5451ba182_101)) && (((_2_forall_45102f7914104e988ec322b5451ba182_101) < (32)) && (true))) ==> ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_0, _2_forall_45102f7914104e988ec322b5451ba182_101)) == (!((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$0, _2_forall_45102f7914104e988ec322b5451ba182_101)) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$1, _2_forall_45102f7914104e988ec322b5451ba182_101)))))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BitVec32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BitVec32::zero() -> [return: bb1, unwind: bb17]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_a13b84307e2a48c5b4311c4a450c9117_101: Int  :: (((0) <= (_2_forall_a13b84307e2a48c5b4311c4a450c9117_101)) && (((_2_forall_a13b84307e2a48c5b4311c4a450c9117_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_a13b84307e2a48c5b4311c4a450c9117_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = const 0_usize
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy 0
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l2
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t15 := copy _7.val_bool
    GotoSwitch([(Local(__t15: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t16 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$1 := ghost _2.val_ref
    _preserve$0 := ghost _1.val_ref
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_5a2b0c0d8da74eb6adf674cdc9efe66b_101: Int  :: (((0) <= (_2_forall_5a2b0c0d8da74eb6adf674cdc9efe66b_101)) && (((_2_forall_5a2b0c0d8da74eb6adf674cdc9efe66b_101) < (_4.val_int)) && (true))) ==> ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_5a2b0c0d8da74eb6adf674cdc9efe66b_101)) == (!((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_5a2b0c0d8da74eb6adf674cdc9efe66b_101)) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_5a2b0c0d8da74eb6adf674cdc9efe66b_101)))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    __t17 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    __t7 := builtin$havoc_bool()
    _28 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    _26 := builtin$havoc_ref()
    _10 := builtin$havoc_ref()
    _20 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    __t6 := builtin$havoc_bool()
    _21 := builtin$havoc_ref()
    _7 := builtin$havoc_ref()
    _4 := builtin$havoc_ref()
    _24 := builtin$havoc_ref()
    __t20 := builtin$havoc_bool()
    __t18 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    __t19 := builtin$havoc_bool()
    _23 := builtin$havoc_ref()
    _25 := builtin$havoc_ref()
    _27 := builtin$havoc_ref()
    _22 := builtin$havoc_ref()
    _14 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    _8 := builtin$havoc_ref()
    __t2 := builtin$havoc_bool()
    __t3 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    _29 := builtin$havoc_ref()
    __t12 := builtin$havoc_bool()
    _30 := builtin$havoc_ref()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_5a2b0c0d8da74eb6adf674cdc9efe66b_101: Int  :: (((0) <= (_2_forall_5a2b0c0d8da74eb6adf674cdc9efe66b_101)) && (((_2_forall_5a2b0c0d8da74eb6adf674cdc9efe66b_101) < (_4.val_int)) && (true))) ==> ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_5a2b0c0d8da74eb6adf674cdc9efe66b_101)) == (!((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_5a2b0c0d8da74eb6adf674cdc9efe66b_101)) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_5a2b0c0d8da74eb6adf674cdc9efe66b_101)))))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t17 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'_ mut _3
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_ref, write)
    _21.val_ref := mut borrow _3 // L5
    label l5
    // [mir] StorageLive(_22)
    // [mir] _22 = _4
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_int, write)
    _22.val_int := copy _4.val_int
    label l6
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] StorageLive(_25)
    // [mir] _25 = &'_ (*_1)
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_ref, write)
    _25.val_ref := borrow _1.val_ref // L10
    label l7
    // [mir] StorageLive(_26)
    // [mir] _26 = _4
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.val_int, write)
    _26.val_int := copy _4.val_int
    label l8
    // [mir] _24 = BitVec32::lookup(move _25, move _26) -> [return: bb13, unwind: bb17]
    label l9
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_24), write)
    inhale(Stmt) (_24.val_bool) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_25.val_ref, _26.val_int))
    transfer perm _25.val_ref --> old[l9](_25.val_ref) // unchecked: false
    Goto(cfg:17)
  label l10 // 17
    // ========== l10 ==========
    // MIR edge bb12 --> bb13
    // Expire borrows
    expire_borrows ReborrowingDAG(L14,L10,)

    Goto(cfg:18)
  label loop2_group3_bb13 // 18
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_26)
    // [mir] StorageDead(_25)
    // [mir] StorageLive(_27)
    // [mir] StorageLive(_28)
    // [mir] _28 = &'_ (*_2)
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_ref, write)
    _28.val_ref := borrow _2.val_ref // L12
    label l11
    // [mir] StorageLive(_29)
    // [mir] _29 = _4
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.val_int, write)
    _29.val_int := copy _4.val_int
    label l12
    // [mir] _27 = BitVec32::lookup(move _28, move _29) -> [return: bb14, unwind: bb17]
    label l13
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_27), write)
    inhale(Stmt) (_27.val_bool) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_28.val_ref, _29.val_int))
    transfer perm _28.val_ref --> old[l13](_28.val_ref) // unchecked: false
    Goto(cfg:19)
  label l14 // 19
    // ========== l14 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    expire_borrows ReborrowingDAG(L11,L12,)

    Goto(cfg:20)
  label loop2_group3_bb14 // 20
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_29)
    // [mir] StorageDead(_28)
    // [mir] _23 = BitXor(move _24, move _27)
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(_23.val_bool, write)
    _23.val_bool := copy !((_24.val_bool) == (_27.val_bool))
    // [mir] StorageDead(_27)
    // [mir] StorageDead(_24)
    // [mir] _20 = BitVec32::set_bit(move _21, move _22, move _23) -> [return: bb15, unwind: bb17]
    label l15
    assert(Stmt) (((0) <= (_22.val_int)) && (((_22.val_int) < (m_len<Ref(m_BitVec32$_beg_$_end_),Int>(_21.val_ref))) && (true))) && (true)
    assert(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_21)) && ((usize$inv<Ref(usize),Bool>(_22)) && ((bool$inv<Ref(bool),Bool>(_23)) && (true)))
    exhale (acc(_21.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_21.val_ref), write)) && ((acc(usize(_22), write)) && ((acc(bool(_23), write)) && (true))))
    _20 := builtin$havoc_ref()
    inhale(Stmt) (acc(m_BitVec32$_beg_$_end_(old[l15](_21.val_ref)), write)) && (true)
    inhale(Stmt) acc(tuple0$(_20), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(old[l15](_21.val_ref))) && ((tuple0$$inv<Ref(tuple0$),Bool>(_20)) && (true))
    inhale(Expr) ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l15](_21.val_ref), old[l15](_22.val_int))) == (old[l15](_23.val_bool))) && ((forall _2_forall_468bc94aca334c75ba1a154bfcb30c24_101: Int  :: (((0) <= (_2_forall_468bc94aca334c75ba1a154bfcb30c24_101)) && (((_2_forall_468bc94aca334c75ba1a154bfcb30c24_101) < (32)) && ((!((_2_forall_468bc94aca334c75ba1a154bfcb30c24_101) == (old[l15](_22.val_int)))) && (true)))) ==> ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l15](_21.val_ref), _2_forall_468bc94aca334c75ba1a154bfcb30c24_101)) == (old[l15](m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_21.val_ref, _2_forall_468bc94aca334c75ba1a154bfcb30c24_101))))) && (true))
    exhale true
    label l16
    Goto(cfg:21)
  label l17 // 21
    // ========== l17 ==========
    // MIR edge bb14 --> bb15
    // Expire borrows
    expire_borrows ReborrowingDAG(L13,L5,)

    Goto(cfg:22)
  label loop2_group3_bb15 // 22
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageDead(_20)
    // [mir] _30 = CheckedAdd(_4, const 1_usize)
    _30 := builtin$havoc_ref()
    inhale(Stmt) acc(_30.tuple_0, write)
    inhale(Stmt) acc(_30.tuple_0.val_int, write)
    inhale(Stmt) acc(_30.tuple_1, write)
    inhale(Stmt) acc(_30.tuple_1.val_bool, write)
    _30.tuple_0.val_int := copy (_4.val_int) + (1)
    _30.tuple_1.val_bool := copy false
    // [mir] assert(!move (_30.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb16, unwind: bb17]
    __t18 := copy _30.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t18)
    Goto(cfg:23)
  label loop2_group3_bb16 // 23
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _4 = move (_30.0: usize)
    _4 := move _30.tuple_0
    label l18
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:24)
  label loop2_group4_bb2 // 24
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:25)
  label loop2_group4_bb3 // 25
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l19
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t19 := copy _7.val_bool
    GotoSwitch([(Local(__t19: Bool, Position { line: 0, column: 0, id: 0 }), cfg:27)], cfg:26)
  label l20 // 26
    // ========== l20 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l21 // 27
    // ========== l21 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:28)
  label loop2_group5_bb4 // 28
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:29)
  label loop2_group5_bb6 // 29
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t20 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:30)
  label loop2_end_body // 30
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_5a2b0c0d8da74eb6adf674cdc9efe66b_101: Int  :: (((0) <= (_2_forall_5a2b0c0d8da74eb6adf674cdc9efe66b_101)) && (((_2_forall_5a2b0c0d8da74eb6adf674cdc9efe66b_101) < (_4.val_int)) && (true))) ==> ((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_5a2b0c0d8da74eb6adf674cdc9efe66b_101)) == (!((m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_5a2b0c0d8da74eb6adf674cdc9efe66b_101)) == (m_lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_5a2b0c0d8da74eb6adf674cdc9efe66b_101)))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 31
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l22
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_mul(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _old$pre$1: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(ref$m_BitVec32$_beg_$_end_)
    _3: Ref(u32)
    _4: Ref(u32)
    _5: Ref(u32)
    _6: Ref(tuple2$u32$bool)
  label start // 0
    // ========== start ==========
    // Def path: "bitvec32::{impl#0}::mul"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bitvec32.rs:332:5: 334:6 (#0)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l5
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BitVec32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) ((!(false))?((_0.f$v.val_int) == ((_old$pre$0.f$v.val_int) * (_old$pre$1.f$v.val_int))):(false)) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BitVec32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] _4 = ((*_1).0: u32)
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy _1.val_ref.f$v.val_int
    label l0
    // [mir] StorageLive(_5)
    // [mir] _5 = ((*_2).0: u32)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_int, write)
    _5.val_int := copy _2.val_ref.f$v.val_int
    label l1
    // [mir] _6 = CheckedMul(_4, _5)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.tuple_0, write)
    inhale(Stmt) acc(_6.tuple_0.val_int, write)
    inhale(Stmt) acc(_6.tuple_1, write)
    inhale(Stmt) acc(_6.tuple_1.val_bool, write)
    _6.tuple_0.val_int := copy (_4.val_int) * (_5.val_int)
    _6.tuple_1.val_bool := copy false
    // [mir] assert(!move (_6.1: bool), "attempt to compute `{} * {}`, which would overflow", move _4, move _5) -> [success: bb1, unwind: bb2]
    __t2 := copy _6.tuple_1.val_bool
    // Rust assertion: attempt to multiply with overflow
    assert(Stmt) !(__t2)
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] _3 = move (_6.0: u32)
    _3 := move _6.tuple_0
    label l2
    // [mir] StorageDead(_5)
    // [mir] StorageDead(_4)
    // [mir] _0 = BitVec32 { v: move _3 }
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_0), write)
    _0.f$v := move _3
    label l3
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_div(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _old$pre$1: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(ref$m_BitVec32$_beg_$_end_)
    _3: Ref(u32)
    _4: Ref(u32)
    _5: Ref(u32)
    _6: Ref(bool)
  label start // 0
    // ========== start ==========
    // Def path: "bitvec32::{impl#0}::div"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bitvec32.rs:338:5: 340:6 (#0)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) (!((_2.val_ref.f$v.val_int) == (0))) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l4
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BitVec32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) ((!((_old$pre$1.f$v.val_int) == (0)))?((_0.f$v.val_int) == ((_old$pre$0.f$v.val_int) \ (_old$pre$1.f$v.val_int))):(false)) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BitVec32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] _4 = ((*_1).0: u32)
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy _1.val_ref.f$v.val_int
    label l0
    // [mir] StorageLive(_5)
    // [mir] _5 = ((*_2).0: u32)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_int, write)
    _5.val_int := copy _2.val_ref.f$v.val_int
    label l1
    // [mir] _6 = Eq(_5, const 0_u32)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_bool, write)
    _6.val_bool := copy (_5.val_int) == (0)
    // [mir] assert(!move _6, "attempt to divide `{}` by zero", _4) -> [success: bb1, unwind: bb2]
    __t2 := copy _6.val_bool
    // Rust assertion: attempt to divide by zero
    assert(Stmt) !(__t2)
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] _3 = Div(move _4, move _5)
    _3 := builtin$havoc_ref()
    inhale(Stmt) acc(_3.val_int, write)
    _3.val_int := copy (_4.val_int) \ (_5.val_int)
    // [mir] StorageDead(_5)
    // [mir] StorageDead(_4)
    // [mir] _0 = BitVec32 { v: move _3 }
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_0), write)
    _0.f$v := move _3
    label l2
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_checked_div(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _old$pre$1: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(ref$m_BitVec32$_beg_$_end_)
    _3: Ref(u32)
    _4: Ref(u32)
    _5: Ref(u32)
    _6: Ref(bool)
  label start // 0
    // ========== start ==========
    // Def path: "bitvec32::{impl#0}::checked_div"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/bitvec32.rs:346:5: 348:6 (#0)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) (!((_2.val_ref.f$v.val_int) == (0))) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l4
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BitVec32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) ((!((_old$pre$1.f$v.val_int) == (0)))?((_0.f$v.val_int) == ((_old$pre$0.f$v.val_int) \ (_old$pre$1.f$v.val_int))):(false)) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BitVec32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] _4 = ((*_1).0: u32)
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy _1.val_ref.f$v.val_int
    label l0
    // [mir] StorageLive(_5)
    // [mir] _5 = ((*_2).0: u32)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_int, write)
    _5.val_int := copy _2.val_ref.f$v.val_int
    label l1
    // [mir] _6 = Eq(_5, const 0_u32)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_bool, write)
    _6.val_bool := copy (_5.val_int) == (0)
    // [mir] assert(!move _6, "attempt to divide `{}` by zero", _4) -> [success: bb1, unwind: bb2]
    __t2 := copy _6.val_bool
    // Rust assertion: attempt to divide by zero
    assert(Stmt) !(__t2)
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] _3 = Div(move _4, move _5)
    _3 := builtin$havoc_ref()
    inhale(Stmt) acc(_3.val_int, write)
    _3.val_int := copy (_4.val_int) \ (_5.val_int)
    // [mir] StorageDead(_5)
    // [mir] StorageDead(_4)
    // [mir] _0 = BitVec32 { v: move _3 }
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_0), write)
    _0.f$v := move _3
    label l2
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


