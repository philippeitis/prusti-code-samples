method m_closure(0 args)
    returns (_0: Ref(tuple0$))
{
    __t0: Bool
    _1: Ref(closure$0_178$3$4476728821056422335)
    _2: Ref(closure$0_178$3$4476728821056422335)
  label start // 0
    // ========== start ==========
    // Def path: "main::closure"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:425:1: 431:2 (#0)
    __t0 := copy false
    // Preconditions:
    inhale(Stmt) true
    inhale(Stmt) true
    inhale(Stmt) true
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l2
    // Fold predicates for &mut args and transfer borrow permissions to old
    // Fold the result
    obtain acc(tuple0$(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) true
    // Assert type invariants
    assert(Stmt) (tuple0$$inv<Ref(tuple0$),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale true
    // Exhale permissions of postcondition (2/3)
    exhale acc(tuple0$(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_1)
    // [mir] StorageLive(_2)
    // [mir] _2 = [closure@/home/philippe/VSCodeProjects/prusti_0/src/main.rs:426:15: 430:6]
    _2 := builtin$havoc_ref()
    inhale(Stmt) acc(closure$0_178$3$4476728821056422335(_2), write)
    // [mir] FakeRead(ForLet, _2)
    // [mir] _1 = _2
    label l0
    // [mir] StorageDead(_2)
    // [mir] FakeRead(ForLet, _1)
    // [mir] _0 = const ()
    // [mir] StorageDead(_1)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


function m_max(_1: Int, _2: Int): Int
  requires true
  requires true
  ensures (((__result) >= (_1)) && (((__result) >= (_2)) && (true))) && (((!((__result) == (_1)))?((!((__result) == (_2)))?(false):(true)):(true)) && (true))
{
	(!((_1) > (_2)))?(_2):(_1)
}

method m_clone(1 args)
    returns (_0: Ref(m_U32Opt$_beg_$_end_))
{
    __t0: Bool
    _old$pre$0: Ref(m_U32Opt$_beg_$_end_)
    _1: Ref(ref$m_U32Opt$_beg_$_end_)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#3}::clone"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:97:27: 97:32 (#9)
    __t0 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_U32Opt$_beg_$_end_(_1.val_ref), read)) && (true))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_1)) && (true)
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l2
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_U32Opt$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(m_U32Opt$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) true
    // Assert type invariants
    assert(Stmt) (m_U32Opt$_beg_$_end_$inv<Ref(m_U32Opt$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_U32Opt$_beg_$_end_(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_U32Opt$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] _0 = (*_1)
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(m_U32Opt$_beg_$_end_(_0), write)
    inhale(Stmt) m_U32Opt$_beg_$_end_$$memory_eq$$<Ref(m_U32Opt$_beg_$_end_), Ref(m_U32Opt$_beg_$_end_),Bool>(_1.val_ref, _0)
    label l0
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_eq(2 args)
    returns (_0: Ref(bool))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    _aux_havoc_ref$m_U32Opt$_beg_$_end_: Ref(ref$m_U32Opt$_beg_$_end_)
    __t18: Int
    __t19: Int
    _old$pre$0: Ref(m_U32Opt$_beg_$_end_)
    _old$pre$1: Ref(m_U32Opt$_beg_$_end_)
    _1: Ref(ref$m_U32Opt$_beg_$_end_)
    _2: Ref(ref$m_U32Opt$_beg_$_end_)
    _3: Ref(isize)
    _4: Ref(ref$m_U32Opt$_beg_$_end_)
    _5: Ref(ref$m_U32Opt$_beg_$_end_)
    _6: Ref(isize)
    _7: Ref(ref$m_U32Opt$_beg_$_end_)
    _8: Ref(ref$m_U32Opt$_beg_$_end_)
    _9: Ref(bool)
    _10: Ref(bool)
    _11: Ref(isize)
    _12: Ref(isize)
    _13: Ref(tuple2$ref$m_U32Opt$_beg_$_end_$ref$m_U32Opt$_beg_$_end_)
    _14: Ref(ref$m_U32Opt$_beg_$_end_)
    _15: Ref(ref$m_U32Opt$_beg_$_end_)
    _16: Ref(isize)
    _17: Ref(isize)
    _18: Ref(ref$u32)
    _19: Ref(ref$u32)
    _20: Ref(u32)
    _21: Ref(u32)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#6}::eq"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:97:10: 97:19 (#11)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_U32Opt$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_U32Opt$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_1)) && ((ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l31
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_U32Opt$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_U32Opt$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(bool(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) true
    // Assert type invariants
    assert(Stmt) (bool$inv<Ref(bool),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_U32Opt$_beg_$_end_(_old$pre$0), read)) && ((acc(m_U32Opt$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(bool(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = &'_ (*_1)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_ref, write)
    _5.val_ref := borrow _1.val_ref // L15
    label l0
    // [mir] _4 = &'_ (*_5)
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_ref, write)
    _4.val_ref := borrow _5.val_ref // L14
    label l1
    // [mir] _3 = std::intrinsics::discriminant_value::<U32Opt>(move _4) -> [return: bb1, unwind: bb15]
    label l2
    assert(Stmt) true
    assert(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_4)) && (true)
    exhale (acc(_4.val_ref, write)) && ((true) && (true))
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(isize(_3), write)
    transfer perm _4.val_ref --> old[l2](_4.val_ref) // unchecked: true
    inhale(Stmt) (isize$inv<Ref(isize),Bool>(_3)) && (true)
    inhale(Expr) true
    exhale true
    label l3
    Goto(cfg:3)
  label l4 // 3
    // ========== l4 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    expire_borrows ReborrowingDAG(L13,L14,L15,)

    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_4)
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageDead(_5)
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = &'_ (*_2)
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_ref, write)
    _8.val_ref := borrow _2.val_ref // L12
    label l5
    // [mir] _7 = &'_ (*_8)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_ref, write)
    _7.val_ref := borrow _8.val_ref // L5
    label l6
    // [mir] _6 = std::intrinsics::discriminant_value::<U32Opt>(move _7) -> [return: bb2, unwind: bb15]
    label l7
    assert(Stmt) true
    assert(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_7)) && (true)
    exhale (acc(_7.val_ref, write)) && ((true) && (true))
    _6 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(isize(_6), write)
    transfer perm _7.val_ref --> old[l7](_7.val_ref) // unchecked: true
    inhale(Stmt) (isize$inv<Ref(isize),Bool>(_6)) && (true)
    inhale(Expr) true
    exhale true
    label l8
    Goto(cfg:5)
  label l9 // 5
    // ========== l9 ==========
    // MIR edge bb1 --> bb2
    // Expire borrows
    expire_borrows ReborrowingDAG(L6,L5,L12,)

    Goto(cfg:6)
  label bb2 // 6
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] StorageDead(_7)
    // [mir] FakeRead(ForLet, _6)
    // [mir] StorageDead(_8)
    // [mir] StorageLive(_9)
    // [mir] switchInt(const true) -> [false: bb4, otherwise: bb5]
    __t15 := copy true
    GotoSwitch([(UnaryOp(Not, Local(__t15: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l10 // 7
    // ========== l10 ==========
    // MIR edge bb2 --> bb5
    Goto(cfg:9)
  label l11 // 8
    // ========== l11 ==========
    // MIR edge bb2 --> bb4
    Goto(cfg:13)
  label bb5 // 9
    // ========== bb5 ==========
    __t3 := copy true
    // [mir] StorageLive(_10)
    // [mir] StorageLive(_11)
    // [mir] _11 = _3
    _11 := builtin$havoc_ref()
    inhale(Stmt) acc(_11.val_int, write)
    _11.val_int := copy _3.val_int
    label l12
    // [mir] StorageLive(_12)
    // [mir] _12 = _6
    _12 := builtin$havoc_ref()
    inhale(Stmt) acc(_12.val_int, write)
    _12.val_int := copy _6.val_int
    label l13
    // [mir] _10 = Eq(move _11, move _12)
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy (_11.val_int) == (_12.val_int)
    // [mir] StorageDead(_12)
    // [mir] StorageDead(_11)
    // [mir] switchInt(move _10) -> [false: bb4, otherwise: bb3]
    __t16 := copy _10.val_bool
    GotoSwitch([(UnaryOp(Not, Local(__t16: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:11)], cfg:10)
  label l14 // 10
    // ========== l14 ==========
    // MIR edge bb5 --> bb3
    Goto(cfg:12)
  label l15 // 11
    // ========== l15 ==========
    // MIR edge bb5 --> bb4
    Goto(cfg:13)
  label bb3 // 12
    // ========== bb3 ==========
    __t4 := copy true
    // [mir] _9 = const true
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy true
    // [mir] goto -> bb6
    Goto(cfg:14)
  label bb4 // 13
    // ========== bb4 ==========
    __t5 := copy true
    // [mir] _9 = const false
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy false
    // [mir] goto -> bb6
    Goto(cfg:14)
  label bb6 // 14
    // ========== bb6 ==========
    __t6 := copy true
    // [mir] StorageDead(_10)
    // [mir] switchInt(move _9) -> [false: bb8, otherwise: bb7]
    __t17 := copy _9.val_bool
    GotoSwitch([(UnaryOp(Not, Local(__t17: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:16)], cfg:15)
  label l16 // 15
    // ========== l16 ==========
    // MIR edge bb6 --> bb7
    Goto(cfg:17)
  label l17 // 16
    // ========== l17 ==========
    // MIR edge bb6 --> bb8
    Goto(cfg:27)
  label bb7 // 17
    // ========== bb7 ==========
    __t7 := copy true
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = &'_ (*_1)
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_ref, write)
    _14.val_ref := borrow _1.val_ref // L7
    label l18
    // [mir] StorageLive(_15)
    // [mir] _15 = &'_ (*_2)
    _15 := builtin$havoc_ref()
    inhale(Stmt) acc(_15.val_ref, write)
    _15.val_ref := borrow _2.val_ref // L8
    label l19
    // [mir] _13 = (move _14, move _15)
    _13 := builtin$havoc_ref()
    inhale(Stmt) acc(tuple2$ref$m_U32Opt$_beg_$_end_$ref$m_U32Opt$_beg_$_end_(_13), write)
    _aux_havoc_ref$m_U32Opt$_beg_$_end_ := builtin$havoc_ref()
    _13.tuple_0 := move _aux_havoc_ref$m_U32Opt$_beg_$_end_
    inhale(Stmt) acc(_13.tuple_0.val_ref, write)
    _13.tuple_0.val_ref := move _14.val_ref
    label l20
    _aux_havoc_ref$m_U32Opt$_beg_$_end_ := builtin$havoc_ref()
    _13.tuple_1 := move _aux_havoc_ref$m_U32Opt$_beg_$_end_
    inhale(Stmt) acc(_13.tuple_1.val_ref, write)
    _13.tuple_1.val_ref := move _15.val_ref
    label l21
    // [mir] StorageDead(_15)
    // [mir] StorageDead(_14)
    // [mir] FakeRead(ForMatchedPlace, _13)
    // [mir] _17 = discriminant((*(_13.0: &U32Opt)))
    _17 := builtin$havoc_ref()
    inhale(Stmt) acc(_17.val_int, write)
    _17.val_int := copy m_U32Opt$_beg_$_end_$$discriminant$$<Ref(m_U32Opt$_beg_$_end_),Int>(_13.tuple_0.val_ref)
    // [mir] switchInt(move _17) -> [0_isize: bb9, otherwise: bb11]
    __t18 := copy _17.val_int
    GotoSwitch([(BinOp(EqCmp, Local(__t18: Int, Position { line: 0, column: 0, id: 0 }), Const(BigInt("0"), Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:19)], cfg:18)
  label l22 // 18
    // ========== l22 ==========
    // MIR edge bb7 --> bb11
    // Expire borrows
    expire_borrows ReborrowingDAG(L10,L9,L8,L7,)

    Goto(cfg:23)
  label l23 // 19
    // ========== l23 ==========
    // MIR edge bb7 --> bb9
    Goto(cfg:20)
  label bb9 // 20
    // ========== bb9 ==========
    __t8 := copy true
    // [mir] _16 = discriminant((*(_13.1: &U32Opt)))
    _16 := builtin$havoc_ref()
    inhale(Stmt) acc(_16.val_int, write)
    _16.val_int := copy m_U32Opt$_beg_$_end_$$discriminant$$<Ref(m_U32Opt$_beg_$_end_),Int>(_13.tuple_1.val_ref)
    // [mir] switchInt(move _16) -> [0_isize: bb10, otherwise: bb11]
    __t19 := copy _16.val_int
    GotoSwitch([(BinOp(EqCmp, Local(__t19: Int, Position { line: 0, column: 0, id: 0 }), Const(BigInt("0"), Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:22)], cfg:21)
  label l24 // 21
    // ========== l24 ==========
    // MIR edge bb9 --> bb11
    // Expire borrows
    expire_borrows ReborrowingDAG(L10,L9,L8,L7,)

    Goto(cfg:23)
  label l25 // 22
    // ========== l25 ==========
    // MIR edge bb9 --> bb10
    Goto(cfg:24)
  label bb11 // 23
    // ========== bb11 ==========
    __t9 := copy true
    // [mir] _0 = const true
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_bool, write)
    _0.val_bool := copy true
    // [mir] goto -> bb13
    Goto(cfg:26)
  label bb10 // 24
    // ========== bb10 ==========
    __t10 := copy true
    // [mir] falseEdge -> [real: bb12, imaginary: bb11]
    Goto(cfg:25)
  label bb12 // 25
    // ========== bb12 ==========
    __t11 := copy true
    // [mir] StorageLive(_18)
    // [mir] _18 = &'_ (((*(_13.0: &U32Opt)) as Some).0: u32)
    _18 := builtin$havoc_ref()
    inhale(Stmt) acc(_18.val_ref, write)
    _18.val_ref := borrow _13.tuple_0.val_ref[enum_Some].f$0 // L4
    label l26
    // [mir] StorageLive(_19)
    // [mir] _19 = &'_ (((*(_13.1: &U32Opt)) as Some).0: u32)
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_ref, write)
    _19.val_ref := borrow _13.tuple_1.val_ref[enum_Some].f$0 // L11
    label l27
    // [mir] StorageLive(_20)
    // [mir] _20 = (*_18)
    _20 := builtin$havoc_ref()
    inhale(Stmt) acc(_20.val_int, write)
    _20.val_int := copy _18.val_ref.val_int
    label l28
    expire_borrows ReborrowingDAG(L4,L9,L7,)

    // [mir] StorageLive(_21)
    // [mir] _21 = (*_19)
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_int, write)
    _21.val_int := copy _19.val_ref.val_int
    label l29
    expire_borrows ReborrowingDAG(L11,L10,L8,)

    // [mir] _0 = Eq(move _20, move _21)
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_bool, write)
    _0.val_bool := copy (_20.val_int) == (_21.val_int)
    // [mir] StorageDead(_21)
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_18)
    // [mir] goto -> bb13
    Goto(cfg:26)
  label bb13 // 26
    // ========== bb13 ==========
    __t12 := copy true
    // [mir] StorageDead(_13)
    // [mir] goto -> bb14
    Goto(cfg:28)
  label bb8 // 27
    // ========== bb8 ==========
    __t13 := copy true
    // [mir] _0 = const false
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_bool, write)
    _0.val_bool := copy false
    // [mir] goto -> bb14
    Goto(cfg:28)
  label bb14 // 28
    // ========== bb14 ==========
    __t14 := copy true
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_ne(2 args)
    returns (_0: Ref(bool))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    _aux_havoc_ref$m_U32Opt$_beg_$_end_: Ref(ref$m_U32Opt$_beg_$_end_)
    __t18: Int
    __t19: Int
    _old$pre$0: Ref(m_U32Opt$_beg_$_end_)
    _old$pre$1: Ref(m_U32Opt$_beg_$_end_)
    _1: Ref(ref$m_U32Opt$_beg_$_end_)
    _2: Ref(ref$m_U32Opt$_beg_$_end_)
    _3: Ref(isize)
    _4: Ref(ref$m_U32Opt$_beg_$_end_)
    _5: Ref(ref$m_U32Opt$_beg_$_end_)
    _6: Ref(isize)
    _7: Ref(ref$m_U32Opt$_beg_$_end_)
    _8: Ref(ref$m_U32Opt$_beg_$_end_)
    _9: Ref(bool)
    _10: Ref(bool)
    _11: Ref(isize)
    _12: Ref(isize)
    _13: Ref(tuple2$ref$m_U32Opt$_beg_$_end_$ref$m_U32Opt$_beg_$_end_)
    _14: Ref(ref$m_U32Opt$_beg_$_end_)
    _15: Ref(ref$m_U32Opt$_beg_$_end_)
    _16: Ref(isize)
    _17: Ref(isize)
    _18: Ref(ref$u32)
    _19: Ref(ref$u32)
    _20: Ref(u32)
    _21: Ref(u32)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#6}::ne"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:97:10: 97:19 (#11)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_U32Opt$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_U32Opt$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_1)) && ((ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l31
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_U32Opt$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_U32Opt$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(bool(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) true
    // Assert type invariants
    assert(Stmt) (bool$inv<Ref(bool),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_U32Opt$_beg_$_end_(_old$pre$0), read)) && ((acc(m_U32Opt$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(bool(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = &'_ (*_1)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_ref, write)
    _5.val_ref := borrow _1.val_ref // L5
    label l0
    // [mir] _4 = &'_ (*_5)
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_ref, write)
    _4.val_ref := borrow _5.val_ref // L4
    label l1
    // [mir] _3 = std::intrinsics::discriminant_value::<U32Opt>(move _4) -> [return: bb1, unwind: bb15]
    label l2
    assert(Stmt) true
    assert(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_4)) && (true)
    exhale (acc(_4.val_ref, write)) && ((true) && (true))
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(isize(_3), write)
    transfer perm _4.val_ref --> old[l2](_4.val_ref) // unchecked: true
    inhale(Stmt) (isize$inv<Ref(isize),Bool>(_3)) && (true)
    inhale(Expr) true
    exhale true
    label l3
    Goto(cfg:3)
  label l4 // 3
    // ========== l4 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    expire_borrows ReborrowingDAG(L9,L4,L5,)

    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_4)
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageDead(_5)
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = &'_ (*_2)
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_ref, write)
    _8.val_ref := borrow _2.val_ref // L15
    label l5
    // [mir] _7 = &'_ (*_8)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_ref, write)
    _7.val_ref := borrow _8.val_ref // L8
    label l6
    // [mir] _6 = std::intrinsics::discriminant_value::<U32Opt>(move _7) -> [return: bb2, unwind: bb15]
    label l7
    assert(Stmt) true
    assert(Stmt) (ref$m_U32Opt$_beg_$_end_$inv<Ref(ref$m_U32Opt$_beg_$_end_),Bool>(_7)) && (true)
    exhale (acc(_7.val_ref, write)) && ((true) && (true))
    _6 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(isize(_6), write)
    transfer perm _7.val_ref --> old[l7](_7.val_ref) // unchecked: true
    inhale(Stmt) (isize$inv<Ref(isize),Bool>(_6)) && (true)
    inhale(Expr) true
    exhale true
    label l8
    Goto(cfg:5)
  label l9 // 5
    // ========== l9 ==========
    // MIR edge bb1 --> bb2
    // Expire borrows
    expire_borrows ReborrowingDAG(L6,L8,L15,)

    Goto(cfg:6)
  label bb2 // 6
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] StorageDead(_7)
    // [mir] FakeRead(ForLet, _6)
    // [mir] StorageDead(_8)
    // [mir] StorageLive(_9)
    // [mir] switchInt(const true) -> [false: bb4, otherwise: bb5]
    __t15 := copy true
    GotoSwitch([(UnaryOp(Not, Local(__t15: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l10 // 7
    // ========== l10 ==========
    // MIR edge bb2 --> bb5
    Goto(cfg:9)
  label l11 // 8
    // ========== l11 ==========
    // MIR edge bb2 --> bb4
    Goto(cfg:13)
  label bb5 // 9
    // ========== bb5 ==========
    __t3 := copy true
    // [mir] StorageLive(_10)
    // [mir] StorageLive(_11)
    // [mir] _11 = _3
    _11 := builtin$havoc_ref()
    inhale(Stmt) acc(_11.val_int, write)
    _11.val_int := copy _3.val_int
    label l12
    // [mir] StorageLive(_12)
    // [mir] _12 = _6
    _12 := builtin$havoc_ref()
    inhale(Stmt) acc(_12.val_int, write)
    _12.val_int := copy _6.val_int
    label l13
    // [mir] _10 = Eq(move _11, move _12)
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy (_11.val_int) == (_12.val_int)
    // [mir] StorageDead(_12)
    // [mir] StorageDead(_11)
    // [mir] switchInt(move _10) -> [false: bb4, otherwise: bb3]
    __t16 := copy _10.val_bool
    GotoSwitch([(UnaryOp(Not, Local(__t16: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:11)], cfg:10)
  label l14 // 10
    // ========== l14 ==========
    // MIR edge bb5 --> bb3
    Goto(cfg:12)
  label l15 // 11
    // ========== l15 ==========
    // MIR edge bb5 --> bb4
    Goto(cfg:13)
  label bb3 // 12
    // ========== bb3 ==========
    __t4 := copy true
    // [mir] _9 = const true
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy true
    // [mir] goto -> bb6
    Goto(cfg:14)
  label bb4 // 13
    // ========== bb4 ==========
    __t5 := copy true
    // [mir] _9 = const false
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy false
    // [mir] goto -> bb6
    Goto(cfg:14)
  label bb6 // 14
    // ========== bb6 ==========
    __t6 := copy true
    // [mir] StorageDead(_10)
    // [mir] switchInt(move _9) -> [false: bb8, otherwise: bb7]
    __t17 := copy _9.val_bool
    GotoSwitch([(UnaryOp(Not, Local(__t17: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:16)], cfg:15)
  label l16 // 15
    // ========== l16 ==========
    // MIR edge bb6 --> bb7
    Goto(cfg:17)
  label l17 // 16
    // ========== l17 ==========
    // MIR edge bb6 --> bb8
    Goto(cfg:27)
  label bb7 // 17
    // ========== bb7 ==========
    __t7 := copy true
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = &'_ (*_1)
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_ref, write)
    _14.val_ref := borrow _1.val_ref // L11
    label l18
    // [mir] StorageLive(_15)
    // [mir] _15 = &'_ (*_2)
    _15 := builtin$havoc_ref()
    inhale(Stmt) acc(_15.val_ref, write)
    _15.val_ref := borrow _2.val_ref // L10
    label l19
    // [mir] _13 = (move _14, move _15)
    _13 := builtin$havoc_ref()
    inhale(Stmt) acc(tuple2$ref$m_U32Opt$_beg_$_end_$ref$m_U32Opt$_beg_$_end_(_13), write)
    _aux_havoc_ref$m_U32Opt$_beg_$_end_ := builtin$havoc_ref()
    _13.tuple_0 := move _aux_havoc_ref$m_U32Opt$_beg_$_end_
    inhale(Stmt) acc(_13.tuple_0.val_ref, write)
    _13.tuple_0.val_ref := move _14.val_ref
    label l20
    _aux_havoc_ref$m_U32Opt$_beg_$_end_ := builtin$havoc_ref()
    _13.tuple_1 := move _aux_havoc_ref$m_U32Opt$_beg_$_end_
    inhale(Stmt) acc(_13.tuple_1.val_ref, write)
    _13.tuple_1.val_ref := move _15.val_ref
    label l21
    // [mir] StorageDead(_15)
    // [mir] StorageDead(_14)
    // [mir] FakeRead(ForMatchedPlace, _13)
    // [mir] _17 = discriminant((*(_13.0: &U32Opt)))
    _17 := builtin$havoc_ref()
    inhale(Stmt) acc(_17.val_int, write)
    _17.val_int := copy m_U32Opt$_beg_$_end_$$discriminant$$<Ref(m_U32Opt$_beg_$_end_),Int>(_13.tuple_0.val_ref)
    // [mir] switchInt(move _17) -> [0_isize: bb9, otherwise: bb11]
    __t18 := copy _17.val_int
    GotoSwitch([(BinOp(EqCmp, Local(__t18: Int, Position { line: 0, column: 0, id: 0 }), Const(BigInt("0"), Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:19)], cfg:18)
  label l22 // 18
    // ========== l22 ==========
    // MIR edge bb7 --> bb11
    // Expire borrows
    expire_borrows ReborrowingDAG(L14,L13,L11,L10,)

    Goto(cfg:23)
  label l23 // 19
    // ========== l23 ==========
    // MIR edge bb7 --> bb9
    Goto(cfg:20)
  label bb9 // 20
    // ========== bb9 ==========
    __t8 := copy true
    // [mir] _16 = discriminant((*(_13.1: &U32Opt)))
    _16 := builtin$havoc_ref()
    inhale(Stmt) acc(_16.val_int, write)
    _16.val_int := copy m_U32Opt$_beg_$_end_$$discriminant$$<Ref(m_U32Opt$_beg_$_end_),Int>(_13.tuple_1.val_ref)
    // [mir] switchInt(move _16) -> [0_isize: bb10, otherwise: bb11]
    __t19 := copy _16.val_int
    GotoSwitch([(BinOp(EqCmp, Local(__t19: Int, Position { line: 0, column: 0, id: 0 }), Const(BigInt("0"), Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:22)], cfg:21)
  label l24 // 21
    // ========== l24 ==========
    // MIR edge bb9 --> bb11
    // Expire borrows
    expire_borrows ReborrowingDAG(L14,L13,L11,L10,)

    Goto(cfg:23)
  label l25 // 22
    // ========== l25 ==========
    // MIR edge bb9 --> bb10
    Goto(cfg:24)
  label bb11 // 23
    // ========== bb11 ==========
    __t9 := copy true
    // [mir] _0 = const false
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_bool, write)
    _0.val_bool := copy false
    // [mir] goto -> bb13
    Goto(cfg:26)
  label bb10 // 24
    // ========== bb10 ==========
    __t10 := copy true
    // [mir] falseEdge -> [real: bb12, imaginary: bb11]
    Goto(cfg:25)
  label bb12 // 25
    // ========== bb12 ==========
    __t11 := copy true
    // [mir] StorageLive(_18)
    // [mir] _18 = &'_ (((*(_13.0: &U32Opt)) as Some).0: u32)
    _18 := builtin$havoc_ref()
    inhale(Stmt) acc(_18.val_ref, write)
    _18.val_ref := borrow _13.tuple_0.val_ref[enum_Some].f$0 // L7
    label l26
    // [mir] StorageLive(_19)
    // [mir] _19 = &'_ (((*(_13.1: &U32Opt)) as Some).0: u32)
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_ref, write)
    _19.val_ref := borrow _13.tuple_1.val_ref[enum_Some].f$0 // L12
    label l27
    // [mir] StorageLive(_20)
    // [mir] _20 = (*_18)
    _20 := builtin$havoc_ref()
    inhale(Stmt) acc(_20.val_int, write)
    _20.val_int := copy _18.val_ref.val_int
    label l28
    expire_borrows ReborrowingDAG(L7,L13,L11,)

    // [mir] StorageLive(_21)
    // [mir] _21 = (*_19)
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_int, write)
    _21.val_int := copy _19.val_ref.val_int
    label l29
    expire_borrows ReborrowingDAG(L12,L14,L10,)

    // [mir] _0 = Ne(move _20, move _21)
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_bool, write)
    _0.val_bool := copy !((_20.val_int) == (_21.val_int))
    // [mir] StorageDead(_21)
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_18)
    // [mir] goto -> bb13
    Goto(cfg:26)
  label bb13 // 26
    // ========== bb13 ==========
    __t12 := copy true
    // [mir] StorageDead(_13)
    // [mir] goto -> bb14
    Goto(cfg:28)
  label bb8 // 27
    // ========== bb8 ==========
    __t13 := copy true
    // [mir] _0 = const true
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_bool, write)
    _0.val_bool := copy true
    // [mir] goto -> bb14
    Goto(cfg:28)
  label bb14 // 28
    // ========== bb14 ==========
    __t14 := copy true
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


function m_len(_1: Ref(m_BoolArr32$_beg_$_end_)): Int
  requires (acc(m_BoolArr32$_beg_$_end_(_1), read)) && (true)
  requires true
  ensures ((__result) == (32)) && (true)


function m_lookup(_1: Ref(m_BoolArr32$_beg_$_end_), _2: Int): Bool
  requires (acc(m_BoolArr32$_beg_$_end_(_1), read)) && (true)
  requires (((0) <= (_2)) && (((_2) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_1))) && (true))) && (true)
  ensures true


method m_flip_bits(1 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    _old$l13$0: Ref(bool)
    __t21: Bool
    __t22: Bool
    __t23: Bool
    _1: Ref(m_BoolArr32$_beg_$_end_)
    _2: Ref(m_BoolArr32$_beg_$_end_)
    _3: Ref(usize)
    _4: Ref(tuple0$)
    _5: Ref(tuple0$)
    _6: Ref(bool)
    _7: Ref(usize)
    _8: Ref(tuple0$)
    _9: Ref(bool)
    _10: Ref(closure$0_67$3$13114848456984105119)
    _11: Ref(ref$usize)
    _12: Ref(tuple0$)
    _13: Ref(bool)
    _14: Ref(closure$0_70$3$7219283737433700658)
    _15: Ref(ref$usize)
    _16: Ref(ref$m_BoolArr32$_beg_$_end_)
    _17: Ref(ref$m_BoolArr32$_beg_$_end_)
    _18: Ref(bool)
    _19: Ref(ref$m_BoolArr32$_beg_$_end_)
    _20: Ref(usize)
    _21: Ref(usize)
    _22: Ref(tuple2$usize$bool)
    _23: Ref(ref$bool)
    _24: Ref(ref$m_BoolArr32$_beg_$_end_)
    _25: Ref(usize)
    _26: Ref(tuple2$usize$bool)
    _27: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#0}::flip_bits"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:199:5: 220:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    __t16 := copy false
    // Preconditions:
    inhale(Stmt) (acc(m_BoolArr32$_beg_$_end_(_1), write)) && (true)
    inhale(Stmt) true
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_1)) && (true)
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l21
    // Fold predicates for &mut args and transfer borrow permissions to old
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_0083a8e4b4f24223afffc7f9d8f3cf80_101: Int  :: (((0) <= (_2_forall_0083a8e4b4f24223afffc7f9d8f3cf80_101)) && (((_2_forall_0083a8e4b4f24223afffc7f9d8f3cf80_101) < (32)) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_0083a8e4b4f24223afffc7f9d8f3cf80_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1, (31) - (_2_forall_0083a8e4b4f24223afffc7f9d8f3cf80_101)))):(false))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale true
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_2)
    // [mir] _2 = BoolArr32::zero() -> [return: bb1, unwind: bb20]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _2 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_2), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_2)) && (true)
    inhale(Expr) (forall _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101: Int  :: (((0) <= (_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)) && (((_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2, _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _2)
    // [mir] StorageLive(_3)
    // [mir] _3 = const 0_usize
    _3 := builtin$havoc_ref()
    inhale(Stmt) acc(_3.val_int, write)
    _3.val_int := copy 0
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb19]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] _7 = _3
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_int, write)
    _7.val_int := copy _3.val_int
    label l2
    // [mir] _6 = Lt(move _7, const 32_usize)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_bool, write)
    _6.val_bool := copy (_7.val_int) < (32)
    // [mir] StorageDead(_7)
    // [mir] FakeRead(ForMatchedPlace, _6)
    // [mir] switchInt(_6) -> [false: bb5, otherwise: bb4]
    __t17 := copy _6.val_bool
    GotoSwitch([(Local(__t17: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:29)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_8)
    // [mir] StorageLive(_9)
    // [mir] _9 = const false
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy false
    // [mir] switchInt(move _9) -> [false: bb8, otherwise: bb7]
    __t18 := copy _9.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    obtain acc(bool(_6), write)
    obtain acc(usize(_3), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_2), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_1), read)
    assert(Expr) (((0) <= (_3.val_int)) && (((_3.val_int) < (32)) && (true))) && ((forall _2_forall_665d1c97d964440a8bd771ad7ee2a15d_101: Int  :: (((0) <= (_2_forall_665d1c97d964440a8bd771ad7ee2a15d_101)) && (((_2_forall_665d1c97d964440a8bd771ad7ee2a15d_101) < (_3.val_int)) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2, _2_forall_665d1c97d964440a8bd771ad7ee2a15d_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1, (31) - (_2_forall_665d1c97d964440a8bd771ad7ee2a15d_101)))):(false))) && (true))
    assert(Expr) true
    exhale (acc(bool(_6), write)) && ((acc(usize(_3), write)) && ((acc(m_BoolArr32$_beg_$_end_(_2), write)) && ((acc(m_BoolArr32$_beg_$_end_(_1), read)) && (true))))
    _26 := builtin$havoc_ref()
    _20 := builtin$havoc_ref()
    _7 := builtin$havoc_ref()
    _3 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    __t6 := builtin$havoc_bool()
    _21 := builtin$havoc_ref()
    __t21 := builtin$havoc_bool()
    __t4 := builtin$havoc_bool()
    _6 := builtin$havoc_ref()
    __t13 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    __t8 := builtin$havoc_bool()
    _13 := builtin$havoc_ref()
    _23 := builtin$havoc_ref()
    _18 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    _24 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    _22 := builtin$havoc_ref()
    __t5 := builtin$havoc_bool()
    __t22 := builtin$havoc_bool()
    _25 := builtin$havoc_ref()
    __t23 := builtin$havoc_bool()
    __t12 := builtin$havoc_bool()
    _19 := builtin$havoc_ref()
    __t19 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    _9 := builtin$havoc_ref()
    __t2 := builtin$havoc_bool()
    __t20 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_6), write)) && ((acc(usize(_3), write)) && ((acc(m_BoolArr32$_beg_$_end_(_2), write)) && ((acc(m_BoolArr32$_beg_$_end_(_1), read)) && (true))))
    inhale(Expr) true
    inhale(Expr) (((0) <= (_3.val_int)) && (((_3.val_int) < (32)) && (true))) && ((forall _2_forall_665d1c97d964440a8bd771ad7ee2a15d_101: Int  :: (((0) <= (_2_forall_665d1c97d964440a8bd771ad7ee2a15d_101)) && (((_2_forall_665d1c97d964440a8bd771ad7ee2a15d_101) < (_3.val_int)) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2, _2_forall_665d1c97d964440a8bd771ad7ee2a15d_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1, (31) - (_2_forall_665d1c97d964440a8bd771ad7ee2a15d_101)))):(false))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _8 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_8)
    // [mir] StorageLive(_12)
    // [mir] StorageLive(_13)
    // [mir] _13 = const false
    _13 := builtin$havoc_ref()
    inhale(Stmt) acc(_13.val_bool, write)
    _13.val_bool := copy false
    // [mir] switchInt(move _13) -> [false: bb11, otherwise: bb10]
    __t19 := copy _13.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _12 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_13)
    // [mir] StorageDead(_12)
    // [mir] StorageLive(_18)
    // [mir] StorageLive(_19)
    // [mir] _19 = &'_ _1
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_ref, write)
    _19.val_ref := borrow _1 // L4
    label l5
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = _3
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_int, write)
    _21.val_int := copy _3.val_int
    label l6
    // [mir] _22 = CheckedSub(const 31_usize, _21)
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.tuple_0, write)
    inhale(Stmt) acc(_22.tuple_0.val_int, write)
    inhale(Stmt) acc(_22.tuple_1, write)
    inhale(Stmt) acc(_22.tuple_1.val_bool, write)
    _22.tuple_0.val_int := copy (31) - (_21.val_int)
    _22.tuple_1.val_bool := copy false
    // [mir] assert(!move (_22.1: bool), "attempt to compute `{} - {}`, which would overflow", const 31_usize, move _21) -> [success: bb13, unwind: bb19]
    __t20 := copy _22.tuple_1.val_bool
    // Rust assertion: attempt to subtract with overflow
    assert(Stmt) !(__t20)
    Goto(cfg:17)
  label loop2_group3_bb13 // 17
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] _20 = move (_22.0: usize)
    _20 := move _22.tuple_0
    label l7
    // [mir] StorageDead(_21)
    // [mir] _18 = BoolArr32::lookup(move _19, move _20) -> [return: bb14, unwind: bb19]
    label l8
    _18 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_18), write)
    inhale(Stmt) (_18.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_19.val_ref, _20.val_int))
    transfer perm _19.val_ref --> old[l8](_19.val_ref) // unchecked: false
    Goto(cfg:18)
  label l9 // 18
    // ========== l9 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    expire_borrows ReborrowingDAG(L8,L4,)

    Goto(cfg:19)
  label loop2_group3_bb14 // 19
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_19)
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] _24 = &'_ mut _2
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(_24.val_ref, write)
    _24.val_ref := mut borrow _2 // L5
    label l10
    // [mir] StorageLive(_25)
    // [mir] _25 = _3
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_int, write)
    _25.val_int := copy _3.val_int
    label l11
    // [mir] _23 = BoolArr32::index_mut(move _24, move _25) -> [return: bb15, unwind: bb19]
    label l12
    assert(Stmt) (((0) <= (_25.val_int)) && (((_25.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_24.val_ref))) && (true))) && (true)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_24)) && ((usize$inv<Ref(usize),Bool>(_25)) && (true))
    exhale (acc(_24.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_24.val_ref), write)) && ((acc(usize(_25), write)) && (true)))
    _23 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_23.val_ref, write)) && (acc(bool(_23.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_23)) && (true)
    inhale(Expr) ((_23.val_ref.val_bool) == (old[l12](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _25.val_int)))) && (true)
    exhale true
    label l13
    Goto(cfg:20)
  label loop2_group3_bb15 // 20
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_25)
    // [mir] StorageDead(_24)
    // [mir] (*_23) = move _18
    _23.val_ref := move _18
    label l14
    expire_borrows ReborrowingDAG(L9,L10,L5,)

    // [mir] StorageDead(_18)
    // [mir] StorageDead(_23)
    // [mir] _26 = CheckedAdd(_3, const 1_usize)
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.tuple_0, write)
    inhale(Stmt) acc(_26.tuple_0.val_int, write)
    inhale(Stmt) acc(_26.tuple_1, write)
    inhale(Stmt) acc(_26.tuple_1.val_bool, write)
    _26.tuple_0.val_int := copy (_3.val_int) + (1)
    _26.tuple_1.val_bool := copy false
    // [mir] assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_usize) -> [success: bb16, unwind: bb19]
    __t21 := copy _26.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t21)
    Goto(cfg:21)
  label loop2_group3_bb16 // 21
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _3 = move (_26.0: usize)
    _3 := move _26.tuple_0
    label l15
    // [mir] _5 = const ()
    // [mir] StorageDead(_6)
    // [mir] goto -> bb2
    Goto(cfg:22)
  label loop2_group4_bb2 // 22
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb19]
    Goto(cfg:23)
  label loop2_group4_bb3 // 23
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] _7 = _3
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_int, write)
    _7.val_int := copy _3.val_int
    label l16
    // [mir] _6 = Lt(move _7, const 32_usize)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_bool, write)
    _6.val_bool := copy (_7.val_int) < (32)
    // [mir] StorageDead(_7)
    // [mir] FakeRead(ForMatchedPlace, _6)
    // [mir] switchInt(_6) -> [false: bb5, otherwise: bb4]
    __t22 := copy _6.val_bool
    GotoSwitch([(Local(__t22: Bool, Position { line: 0, column: 0, id: 0 }), cfg:25)], cfg:24)
  label l17 // 24
    // ========== l17 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:29)
  label l18 // 25
    // ========== l18 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:26)
  label loop2_group5_bb4 // 26
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:27)
  label loop2_group5_bb6 // 27
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_8)
    // [mir] StorageLive(_9)
    // [mir] _9 = const false
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy false
    // [mir] switchInt(move _9) -> [false: bb8, otherwise: bb7]
    __t23 := copy _9.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:28)
  label loop2_end_body // 28
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    obtain acc(bool(_6), write)
    obtain acc(usize(_3), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_2), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_1), read)
    assert(Expr) (((0) <= (_3.val_int)) && (((_3.val_int) < (32)) && (true))) && ((forall _2_forall_665d1c97d964440a8bd771ad7ee2a15d_101: Int  :: (((0) <= (_2_forall_665d1c97d964440a8bd771ad7ee2a15d_101)) && (((_2_forall_665d1c97d964440a8bd771ad7ee2a15d_101) < (_3.val_int)) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2, _2_forall_665d1c97d964440a8bd771ad7ee2a15d_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1, (31) - (_2_forall_665d1c97d964440a8bd771ad7ee2a15d_101)))):(false))) && (true))
    assert(Expr) true
    exhale (acc(bool(_6), write)) && ((acc(usize(_3), write)) && ((acc(m_BoolArr32$_beg_$_end_(_2), write)) && ((acc(m_BoolArr32$_beg_$_end_(_1), read)) && (true))))
    inhale(Stmt) false
    Return
  label bb5 // 29
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _4 = const ()
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_4)
    // [mir] _0 = move _2
    _0 := move _2
    label l19
    // [mir] StorageDead(_3)
    // [mir] drop(_2) -> [return: bb17, unwind: bb20]
    Goto(cfg:30)
  label bb17 // 30
    // ========== bb17 ==========
    __t15 := copy true
    // [mir] StorageDead(_2)
    // [mir] drop(_1) -> [return: bb18, unwind: bb21]
    Goto(cfg:31)
  label bb18 // 31
    // ========== bb18 ==========
    __t16 := copy true
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_shl(2 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    __t21: Bool
    _preserve$0: Ref(AuxRef)
    __t22: Bool
    __t23: Bool
    __t24: Bool
    __t25: Bool
    _old$l15$0: Ref(bool)
    __t26: Bool
    __t27: Bool
    __t28: Bool
    _old$pre$0: Ref(m_BoolArr32$_beg_$_end_)
    _1: Ref(ref$m_BoolArr32$_beg_$_end_)
    _2: Ref(usize)
    _3: Ref(m_BoolArr32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_92$3$13114848456984105119)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_95$3$3859392265678673261)
    _16: Ref(ref$usize)
    _17: Ref(ref$usize)
    _18: Ref(tuple0$)
    _19: Ref(bool)
    _20: Ref(closure$0_99$3$2536757696045608690)
    _21: Ref(ref$usize)
    _22: Ref(ref$usize)
    _23: Ref(ref$m_BoolArr32$_beg_$_end_)
    _24: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _25: Ref(tuple0$)
    _26: Ref(bool)
    _27: Ref(closure$0_108$3$12351797966212270264)
    _28: Ref(ref$usize)
    _29: Ref(ref$m_BoolArr32$_beg_$_end_)
    _30: Ref(bool)
    _31: Ref(ref$m_BoolArr32$_beg_$_end_)
    _32: Ref(usize)
    _33: Ref(usize)
    _34: Ref(usize)
    _35: Ref(tuple2$usize$bool)
    _36: Ref(ref$bool)
    _37: Ref(ref$m_BoolArr32$_beg_$_end_)
    _38: Ref(usize)
    _39: Ref(tuple2$usize$bool)
    _40: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#0}::shl"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:236:5: 266:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    __t16 := copy false
    __t17 := copy false
    __t18 := copy false
    __t19 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_1.val_ref), read)) && ((acc(usize(_2), write)) && (true)))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_1)) && ((usize$inv<Ref(usize),Bool>(_2)) && (true))
    inhale(Expr) ((0) <= (_2.val_int)) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l23
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BoolArr32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_6fc8cfa62033420090e69f867e787a16_101: Int  :: ((((0) <= (_2_forall_6fc8cfa62033420090e69f867e787a16_101)) && (((_2_forall_6fc8cfa62033420090e69f867e787a16_101) < (32)) && (true))) && ((((old[pre](_2.val_int)) <= (_2_forall_6fc8cfa62033420090e69f867e787a16_101)) && (((!(false))?(((_2_forall_6fc8cfa62033420090e69f867e787a16_101) - (old[pre](_2.val_int))) >= (0)):(false)) && (((!(false))?(((_2_forall_6fc8cfa62033420090e69f867e787a16_101) - (old[pre](_2.val_int))) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_6fc8cfa62033420090e69f867e787a16_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$0, (_2_forall_6fc8cfa62033420090e69f867e787a16_101) - (old[pre](_2.val_int))))):(false))) && ((forall _2_forall_eb699bd163134657a845fdab605d9b52_101: Int  :: (((0) <= (_2_forall_eb699bd163134657a845fdab605d9b52_101)) && (((_2_forall_eb699bd163134657a845fdab605d9b52_101) < (old[pre](_2.val_int))) && (((_2_forall_eb699bd163134657a845fdab605d9b52_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_eb699bd163134657a845fdab605d9b52_101)))) && (true))
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BoolArr32$_beg_$_end_(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BoolArr32::zero() -> [return: bb1, unwind: bb25]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101: Int  :: (((0) <= (_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)) && (((_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = _2
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy _2.val_int
    label l2
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb24]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l3
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t20 := copy _7.val_bool
    GotoSwitch([(Local(__t20: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l4 // 7
    // ========== l4 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:33)
  label l5 // 8
    // ========== l5 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t21 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(usize(_2), read)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((((_2.val_int) <= (_4.val_int)) && (((!(false))?(((_4.val_int) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_4.val_int) - (_2.val_int)) < (32)):(false)) && (true)))) && ((forall _2_forall_82b69defbea14d588fa5d817ac980abe_101: Int  :: ((((0) <= (_2_forall_82b69defbea14d588fa5d817ac980abe_101)) && (((_2_forall_82b69defbea14d588fa5d817ac980abe_101) < (_4.val_int)) && (((_2_forall_82b69defbea14d588fa5d817ac980abe_101) >= (_2.val_int)) && (true)))) && ((((_2.val_int) <= (_2_forall_82b69defbea14d588fa5d817ac980abe_101)) && (((!(false))?(((_2_forall_82b69defbea14d588fa5d817ac980abe_101) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_2_forall_82b69defbea14d588fa5d817ac980abe_101) - (_2.val_int)) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_82b69defbea14d588fa5d817ac980abe_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, (_2_forall_82b69defbea14d588fa5d817ac980abe_101) - (_2.val_int)))):(false))) && ((forall _2_forall_dbb1f07c505c467c94b331d686ce7ac5_101: Int  :: (((0) <= (_2_forall_dbb1f07c505c467c94b331d686ce7ac5_101)) && (((_2_forall_dbb1f07c505c467c94b331d686ce7ac5_101) < (_2.val_int)) && (((_2_forall_dbb1f07c505c467c94b331d686ce7ac5_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_dbb1f07c505c467c94b331d686ce7ac5_101)))) && (true))))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    __t22 := builtin$havoc_bool()
    _10 := builtin$havoc_ref()
    _39 := builtin$havoc_ref()
    _30 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    _35 := builtin$havoc_ref()
    __t13 := builtin$havoc_bool()
    __t7 := builtin$havoc_bool()
    __t15 := builtin$havoc_bool()
    __t12 := builtin$havoc_bool()
    _14 := builtin$havoc_ref()
    __t14 := builtin$havoc_bool()
    _36 := builtin$havoc_ref()
    __t24 := builtin$havoc_bool()
    _31 := builtin$havoc_ref()
    __t16 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    _37 := builtin$havoc_ref()
    __t2 := builtin$havoc_bool()
    _34 := builtin$havoc_ref()
    _4 := builtin$havoc_ref()
    __t28 := builtin$havoc_bool()
    _38 := builtin$havoc_ref()
    _7 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    __t26 := builtin$havoc_bool()
    __t4 := builtin$havoc_bool()
    __t3 := builtin$havoc_bool()
    _26 := builtin$havoc_ref()
    _33 := builtin$havoc_ref()
    _19 := builtin$havoc_ref()
    __t23 := builtin$havoc_bool()
    __t27 := builtin$havoc_bool()
    __t6 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    __t25 := builtin$havoc_bool()
    _32 := builtin$havoc_ref()
    _8 := builtin$havoc_ref()
    __t17 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    inhale(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((((_2.val_int) <= (_4.val_int)) && (((!(false))?(((_4.val_int) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_4.val_int) - (_2.val_int)) < (32)):(false)) && (true)))) && ((forall _2_forall_82b69defbea14d588fa5d817ac980abe_101: Int  :: ((((0) <= (_2_forall_82b69defbea14d588fa5d817ac980abe_101)) && (((_2_forall_82b69defbea14d588fa5d817ac980abe_101) < (_4.val_int)) && (((_2_forall_82b69defbea14d588fa5d817ac980abe_101) >= (_2.val_int)) && (true)))) && ((((_2.val_int) <= (_2_forall_82b69defbea14d588fa5d817ac980abe_101)) && (((!(false))?(((_2_forall_82b69defbea14d588fa5d817ac980abe_101) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_2_forall_82b69defbea14d588fa5d817ac980abe_101) - (_2.val_int)) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_82b69defbea14d588fa5d817ac980abe_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, (_2_forall_82b69defbea14d588fa5d817ac980abe_101) - (_2.val_int)))):(false))) && ((forall _2_forall_dbb1f07c505c467c94b331d686ce7ac5_101: Int  :: (((0) <= (_2_forall_dbb1f07c505c467c94b331d686ce7ac5_101)) && (((_2_forall_dbb1f07c505c467c94b331d686ce7ac5_101) < (_2.val_int)) && (((_2_forall_dbb1f07c505c467c94b331d686ce7ac5_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_dbb1f07c505c467c94b331d686ce7ac5_101)))) && (true))))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t22 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_18)
    // [mir] StorageLive(_19)
    // [mir] _19 = const false
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_bool, write)
    _19.val_bool := copy false
    // [mir] switchInt(move _19) -> [false: bb14, otherwise: bb13]
    __t23 := copy _19.val_bool
    // Ignore default target bb13, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:17)
  label loop2_group3_bb14 // 17
    // ========== loop2_group3_bb14 ==========
    __t10 := copy true
    // [mir] _18 = const ()
    // [mir] goto -> bb15
    Goto(cfg:18)
  label loop2_group3_bb15 // 18
    // ========== loop2_group3_bb15 ==========
    __t11 := copy true
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_18)
    // [mir] StorageLive(_25)
    // [mir] StorageLive(_26)
    // [mir] _26 = const false
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.val_bool, write)
    _26.val_bool := copy false
    // [mir] switchInt(move _26) -> [false: bb17, otherwise: bb16]
    __t24 := copy _26.val_bool
    // Ignore default target bb16, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:19)
  label loop2_group3_bb17 // 19
    // ========== loop2_group3_bb17 ==========
    __t12 := copy true
    // [mir] _25 = const ()
    // [mir] goto -> bb18
    Goto(cfg:20)
  label loop2_group3_bb18 // 20
    // ========== loop2_group3_bb18 ==========
    __t13 := copy true
    // [mir] StorageDead(_26)
    // [mir] StorageDead(_25)
    // [mir] StorageLive(_30)
    // [mir] StorageLive(_31)
    // [mir] _31 = &'_ (*_1)
    _31 := builtin$havoc_ref()
    inhale(Stmt) acc(_31.val_ref, write)
    _31.val_ref := borrow _1.val_ref // L13
    label l6
    // [mir] StorageLive(_32)
    // [mir] StorageLive(_33)
    // [mir] _33 = _4
    _33 := builtin$havoc_ref()
    inhale(Stmt) acc(_33.val_int, write)
    _33.val_int := copy _4.val_int
    label l7
    // [mir] StorageLive(_34)
    // [mir] _34 = _2
    _34 := builtin$havoc_ref()
    inhale(Stmt) acc(_34.val_int, write)
    _34.val_int := copy _2.val_int
    label l8
    // [mir] _35 = CheckedSub(_33, _34)
    _35 := builtin$havoc_ref()
    inhale(Stmt) acc(_35.tuple_0, write)
    inhale(Stmt) acc(_35.tuple_0.val_int, write)
    inhale(Stmt) acc(_35.tuple_1, write)
    inhale(Stmt) acc(_35.tuple_1.val_bool, write)
    _35.tuple_0.val_int := copy (_33.val_int) - (_34.val_int)
    _35.tuple_1.val_bool := copy false
    // [mir] assert(!move (_35.1: bool), "attempt to compute `{} - {}`, which would overflow", move _33, move _34) -> [success: bb19, unwind: bb24]
    __t25 := copy _35.tuple_1.val_bool
    // Rust assertion: attempt to subtract with overflow
    assert(Stmt) !(__t25)
    Goto(cfg:21)
  label loop2_group3_bb19 // 21
    // ========== loop2_group3_bb19 ==========
    __t14 := copy true
    // [mir] _32 = move (_35.0: usize)
    _32 := move _35.tuple_0
    label l9
    // [mir] StorageDead(_34)
    // [mir] StorageDead(_33)
    // [mir] _30 = BoolArr32::lookup(move _31, move _32) -> [return: bb20, unwind: bb24]
    label l10
    _30 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_30), write)
    inhale(Stmt) (_30.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_31.val_ref, _32.val_int))
    transfer perm _31.val_ref --> old[l10](_31.val_ref) // unchecked: false
    Goto(cfg:22)
  label l11 // 22
    // ========== l11 ==========
    // MIR edge bb19 --> bb20
    // Expire borrows
    expire_borrows ReborrowingDAG(L14,L13,)

    Goto(cfg:23)
  label loop2_group3_bb20 // 23
    // ========== loop2_group3_bb20 ==========
    __t15 := copy true
    // [mir] StorageDead(_32)
    // [mir] StorageDead(_31)
    // [mir] StorageLive(_36)
    // [mir] StorageLive(_37)
    // [mir] _37 = &'_ mut _3
    _37 := builtin$havoc_ref()
    inhale(Stmt) acc(_37.val_ref, write)
    _37.val_ref := mut borrow _3 // L9
    label l12
    // [mir] StorageLive(_38)
    // [mir] _38 = _4
    _38 := builtin$havoc_ref()
    inhale(Stmt) acc(_38.val_int, write)
    _38.val_int := copy _4.val_int
    label l13
    // [mir] _36 = BoolArr32::index_mut(move _37, move _38) -> [return: bb21, unwind: bb24]
    label l14
    assert(Stmt) (((0) <= (_38.val_int)) && (((_38.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_37.val_ref))) && (true))) && (true)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_37)) && ((usize$inv<Ref(usize),Bool>(_38)) && (true))
    exhale (acc(_37.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_37.val_ref), write)) && ((acc(usize(_38), write)) && (true)))
    _36 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_36.val_ref, write)) && (acc(bool(_36.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_36)) && (true)
    inhale(Expr) ((_36.val_ref.val_bool) == (old[l14](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_37.val_ref, _38.val_int)))) && (true)
    exhale true
    label l15
    Goto(cfg:24)
  label loop2_group3_bb21 // 24
    // ========== loop2_group3_bb21 ==========
    __t16 := copy true
    // [mir] StorageDead(_38)
    // [mir] StorageDead(_37)
    // [mir] (*_36) = move _30
    _36.val_ref := move _30
    label l16
    expire_borrows ReborrowingDAG(L15,L16,L9,)

    // [mir] StorageDead(_30)
    // [mir] StorageDead(_36)
    // [mir] _39 = CheckedAdd(_4, const 1_usize)
    _39 := builtin$havoc_ref()
    inhale(Stmt) acc(_39.tuple_0, write)
    inhale(Stmt) acc(_39.tuple_0.val_int, write)
    inhale(Stmt) acc(_39.tuple_1, write)
    inhale(Stmt) acc(_39.tuple_1.val_bool, write)
    _39.tuple_0.val_int := copy (_4.val_int) + (1)
    _39.tuple_1.val_bool := copy false
    // [mir] assert(!move (_39.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb22, unwind: bb24]
    __t26 := copy _39.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t26)
    Goto(cfg:25)
  label loop2_group3_bb22 // 25
    // ========== loop2_group3_bb22 ==========
    __t17 := copy true
    // [mir] _4 = move (_39.0: usize)
    _4 := move _39.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:26)
  label loop2_group4_bb2 // 26
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb24]
    Goto(cfg:27)
  label loop2_group4_bb3 // 27
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l18
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t27 := copy _7.val_bool
    GotoSwitch([(Local(__t27: Bool, Position { line: 0, column: 0, id: 0 }), cfg:29)], cfg:28)
  label l19 // 28
    // ========== l19 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:33)
  label l20 // 29
    // ========== l20 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:30)
  label loop2_group5_bb4 // 30
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:31)
  label loop2_group5_bb6 // 31
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t28 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:32)
  label loop2_end_body // 32
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(usize(_2), read)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((((_2.val_int) <= (_4.val_int)) && (((!(false))?(((_4.val_int) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_4.val_int) - (_2.val_int)) < (32)):(false)) && (true)))) && ((forall _2_forall_82b69defbea14d588fa5d817ac980abe_101: Int  :: ((((0) <= (_2_forall_82b69defbea14d588fa5d817ac980abe_101)) && (((_2_forall_82b69defbea14d588fa5d817ac980abe_101) < (_4.val_int)) && (((_2_forall_82b69defbea14d588fa5d817ac980abe_101) >= (_2.val_int)) && (true)))) && ((((_2.val_int) <= (_2_forall_82b69defbea14d588fa5d817ac980abe_101)) && (((!(false))?(((_2_forall_82b69defbea14d588fa5d817ac980abe_101) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_2_forall_82b69defbea14d588fa5d817ac980abe_101) - (_2.val_int)) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_82b69defbea14d588fa5d817ac980abe_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, (_2_forall_82b69defbea14d588fa5d817ac980abe_101) - (_2.val_int)))):(false))) && ((forall _2_forall_dbb1f07c505c467c94b331d686ce7ac5_101: Int  :: (((0) <= (_2_forall_dbb1f07c505c467c94b331d686ce7ac5_101)) && (((_2_forall_dbb1f07c505c467c94b331d686ce7ac5_101) < (_2.val_int)) && (((_2_forall_dbb1f07c505c467c94b331d686ce7ac5_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_dbb1f07c505c467c94b331d686ce7ac5_101)))) && (true))))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 33
    // ========== bb5 ==========
    __t18 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l21
    // [mir] StorageDead(_4)
    // [mir] drop(_3) -> [return: bb23, unwind: bb25]
    Goto(cfg:34)
  label bb23 // 34
    // ========== bb23 ==========
    __t19 := copy true
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_shr(2 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    __t18: Bool
    __t19: Bool
    _preserve$0: Ref(AuxRef)
    __t20: Bool
    __t21: Bool
    __t22: Bool
    _old$l15$0: Ref(bool)
    __t23: Bool
    __t24: Bool
    __t25: Bool
    _old$pre$0: Ref(m_BoolArr32$_beg_$_end_)
    _1: Ref(ref$m_BoolArr32$_beg_$_end_)
    _2: Ref(usize)
    _3: Ref(m_BoolArr32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_123$3$13114848456984105119)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_126$3$3859392265678673261)
    _16: Ref(ref$usize)
    _17: Ref(ref$usize)
    _18: Ref(tuple0$)
    _19: Ref(bool)
    _20: Ref(closure$0_130$3$12351797966212270264)
    _21: Ref(ref$usize)
    _22: Ref(ref$m_BoolArr32$_beg_$_end_)
    _23: Ref(bool)
    _24: Ref(ref$m_BoolArr32$_beg_$_end_)
    _25: Ref(usize)
    _26: Ref(ref$bool)
    _27: Ref(ref$m_BoolArr32$_beg_$_end_)
    _28: Ref(usize)
    _29: Ref(usize)
    _30: Ref(usize)
    _31: Ref(tuple2$usize$bool)
    _32: Ref(tuple2$usize$bool)
    _33: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#0}::shr"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:284:5: 317:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    __t16 := copy false
    __t17 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_1.val_ref), read)) && ((acc(usize(_2), write)) && (true)))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_1)) && ((usize$inv<Ref(usize),Bool>(_2)) && (true))
    inhale(Expr) ((0) <= (_2.val_int)) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l23
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BoolArr32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_9061e768819d46e1a5959b481ddd9804_101: Int  :: (((0) <= (_2_forall_9061e768819d46e1a5959b481ddd9804_101)) && (((!(false))?((_2_forall_9061e768819d46e1a5959b481ddd9804_101) > ((32) - (old[pre](_2.val_int)))):(false)) && (((_2_forall_9061e768819d46e1a5959b481ddd9804_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_9061e768819d46e1a5959b481ddd9804_101)))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BoolArr32$_beg_$_end_(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BoolArr32::zero() -> [return: bb1, unwind: bb22]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101: Int  :: (((0) <= (_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)) && (((_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = _2
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy _2.val_int
    label l2
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb21]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l3
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t18 := copy _7.val_bool
    GotoSwitch([(Local(__t18: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l4 // 7
    // ========== l4 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l5 // 8
    // ========== l5 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t19 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(usize(_2), read)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((((_4.val_int) >= (_2.val_int)) && (((!(false))?(((_4.val_int) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_4.val_int) - (_2.val_int)) < (32)):(false)) && (true)))) && ((forall _2_forall_3a96b4c5fd354600a880df6bda7c9430_101: Int  :: (((0) <= (_2_forall_3a96b4c5fd354600a880df6bda7c9430_101)) && (((!(false))?((_2_forall_3a96b4c5fd354600a880df6bda7c9430_101) > ((32) - (_2.val_int))):(false)) && (((_2_forall_3a96b4c5fd354600a880df6bda7c9430_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_3a96b4c5fd354600a880df6bda7c9430_101)))) && (true)))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    _7 := builtin$havoc_ref()
    __t12 := builtin$havoc_bool()
    _25 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    __t21 := builtin$havoc_bool()
    __t24 := builtin$havoc_bool()
    __t6 := builtin$havoc_bool()
    __t15 := builtin$havoc_bool()
    __t23 := builtin$havoc_bool()
    __t14 := builtin$havoc_bool()
    _31 := builtin$havoc_ref()
    __t11 := builtin$havoc_bool()
    _23 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    _24 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    _26 := builtin$havoc_ref()
    _4 := builtin$havoc_ref()
    _10 := builtin$havoc_ref()
    _14 := builtin$havoc_ref()
    __t9 := builtin$havoc_bool()
    __t2 := builtin$havoc_bool()
    _28 := builtin$havoc_ref()
    _19 := builtin$havoc_ref()
    __t13 := builtin$havoc_bool()
    __t25 := builtin$havoc_bool()
    _29 := builtin$havoc_ref()
    _32 := builtin$havoc_ref()
    __t20 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    __t3 := builtin$havoc_bool()
    _30 := builtin$havoc_ref()
    _27 := builtin$havoc_ref()
    _8 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    __t22 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    inhale(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((((_4.val_int) >= (_2.val_int)) && (((!(false))?(((_4.val_int) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_4.val_int) - (_2.val_int)) < (32)):(false)) && (true)))) && ((forall _2_forall_3a96b4c5fd354600a880df6bda7c9430_101: Int  :: (((0) <= (_2_forall_3a96b4c5fd354600a880df6bda7c9430_101)) && (((!(false))?((_2_forall_3a96b4c5fd354600a880df6bda7c9430_101) > ((32) - (_2.val_int))):(false)) && (((_2_forall_3a96b4c5fd354600a880df6bda7c9430_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_3a96b4c5fd354600a880df6bda7c9430_101)))) && (true)))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t20 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_18)
    // [mir] StorageLive(_19)
    // [mir] _19 = const false
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_bool, write)
    _19.val_bool := copy false
    // [mir] switchInt(move _19) -> [false: bb14, otherwise: bb13]
    __t21 := copy _19.val_bool
    // Ignore default target bb13, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:17)
  label loop2_group3_bb14 // 17
    // ========== loop2_group3_bb14 ==========
    __t10 := copy true
    // [mir] _18 = const ()
    // [mir] goto -> bb15
    Goto(cfg:18)
  label loop2_group3_bb15 // 18
    // ========== loop2_group3_bb15 ==========
    __t11 := copy true
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_18)
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] _24 = &'_ (*_1)
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(_24.val_ref, write)
    _24.val_ref := borrow _1.val_ref // L11
    label l6
    // [mir] StorageLive(_25)
    // [mir] _25 = _4
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_int, write)
    _25.val_int := copy _4.val_int
    label l7
    // [mir] _23 = BoolArr32::lookup(move _24, move _25) -> [return: bb16, unwind: bb21]
    label l8
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_23), write)
    inhale(Stmt) (_23.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _25.val_int))
    transfer perm _24.val_ref --> old[l8](_24.val_ref) // unchecked: false
    Goto(cfg:19)
  label l9 // 19
    // ========== l9 ==========
    // MIR edge bb15 --> bb16
    // Expire borrows
    expire_borrows ReborrowingDAG(L12,L11,)

    Goto(cfg:20)
  label loop2_group3_bb16 // 20
    // ========== loop2_group3_bb16 ==========
    __t12 := copy true
    // [mir] StorageDead(_25)
    // [mir] StorageDead(_24)
    // [mir] StorageLive(_26)
    // [mir] StorageLive(_27)
    // [mir] _27 = &'_ mut _3
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(_27.val_ref, write)
    _27.val_ref := mut borrow _3 // L5
    label l10
    // [mir] StorageLive(_28)
    // [mir] StorageLive(_29)
    // [mir] _29 = _4
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.val_int, write)
    _29.val_int := copy _4.val_int
    label l11
    // [mir] StorageLive(_30)
    // [mir] _30 = _2
    _30 := builtin$havoc_ref()
    inhale(Stmt) acc(_30.val_int, write)
    _30.val_int := copy _2.val_int
    label l12
    // [mir] _31 = CheckedSub(_29, _30)
    _31 := builtin$havoc_ref()
    inhale(Stmt) acc(_31.tuple_0, write)
    inhale(Stmt) acc(_31.tuple_0.val_int, write)
    inhale(Stmt) acc(_31.tuple_1, write)
    inhale(Stmt) acc(_31.tuple_1.val_bool, write)
    _31.tuple_0.val_int := copy (_29.val_int) - (_30.val_int)
    _31.tuple_1.val_bool := copy false
    // [mir] assert(!move (_31.1: bool), "attempt to compute `{} - {}`, which would overflow", move _29, move _30) -> [success: bb17, unwind: bb21]
    __t22 := copy _31.tuple_1.val_bool
    // Rust assertion: attempt to subtract with overflow
    assert(Stmt) !(__t22)
    Goto(cfg:21)
  label loop2_group3_bb17 // 21
    // ========== loop2_group3_bb17 ==========
    __t13 := copy true
    // [mir] _28 = move (_31.0: usize)
    _28 := move _31.tuple_0
    label l13
    // [mir] StorageDead(_30)
    // [mir] StorageDead(_29)
    // [mir] _26 = BoolArr32::index_mut(move _27, move _28) -> [return: bb18, unwind: bb21]
    label l14
    assert(Stmt) (((0) <= (_28.val_int)) && (((_28.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref))) && (true))) && (true)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_27)) && ((usize$inv<Ref(usize),Bool>(_28)) && (true))
    exhale (acc(_27.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_27.val_ref), write)) && ((acc(usize(_28), write)) && (true)))
    _26 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_26.val_ref, write)) && (acc(bool(_26.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_26)) && (true)
    inhale(Expr) ((_26.val_ref.val_bool) == (old[l14](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _28.val_int)))) && (true)
    exhale true
    label l15
    Goto(cfg:22)
  label loop2_group3_bb18 // 22
    // ========== loop2_group3_bb18 ==========
    __t14 := copy true
    // [mir] StorageDead(_28)
    // [mir] StorageDead(_27)
    // [mir] (*_26) = move _23
    _26.val_ref := move _23
    label l16
    expire_borrows ReborrowingDAG(L9,L10,L5,)

    // [mir] StorageDead(_23)
    // [mir] StorageDead(_26)
    // [mir] _32 = CheckedAdd(_4, const 1_usize)
    _32 := builtin$havoc_ref()
    inhale(Stmt) acc(_32.tuple_0, write)
    inhale(Stmt) acc(_32.tuple_0.val_int, write)
    inhale(Stmt) acc(_32.tuple_1, write)
    inhale(Stmt) acc(_32.tuple_1.val_bool, write)
    _32.tuple_0.val_int := copy (_4.val_int) + (1)
    _32.tuple_1.val_bool := copy false
    // [mir] assert(!move (_32.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb19, unwind: bb21]
    __t23 := copy _32.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t23)
    Goto(cfg:23)
  label loop2_group3_bb19 // 23
    // ========== loop2_group3_bb19 ==========
    __t15 := copy true
    // [mir] _4 = move (_32.0: usize)
    _4 := move _32.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:24)
  label loop2_group4_bb2 // 24
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb21]
    Goto(cfg:25)
  label loop2_group4_bb3 // 25
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l18
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t24 := copy _7.val_bool
    GotoSwitch([(Local(__t24: Bool, Position { line: 0, column: 0, id: 0 }), cfg:27)], cfg:26)
  label l19 // 26
    // ========== l19 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l20 // 27
    // ========== l20 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:28)
  label loop2_group5_bb4 // 28
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:29)
  label loop2_group5_bb6 // 29
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t25 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:30)
  label loop2_end_body // 30
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(usize(_2), read)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((((_4.val_int) >= (_2.val_int)) && (((!(false))?(((_4.val_int) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_4.val_int) - (_2.val_int)) < (32)):(false)) && (true)))) && ((forall _2_forall_3a96b4c5fd354600a880df6bda7c9430_101: Int  :: (((0) <= (_2_forall_3a96b4c5fd354600a880df6bda7c9430_101)) && (((!(false))?((_2_forall_3a96b4c5fd354600a880df6bda7c9430_101) > ((32) - (_2.val_int))):(false)) && (((_2_forall_3a96b4c5fd354600a880df6bda7c9430_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_3a96b4c5fd354600a880df6bda7c9430_101)))) && (true)))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 31
    // ========== bb5 ==========
    __t16 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l21
    // [mir] StorageDead(_4)
    // [mir] drop(_3) -> [return: bb20, unwind: bb22]
    Goto(cfg:32)
  label bb20 // 32
    // ========== bb20 ==========
    __t17 := copy true
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_or(2 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t18: Bool
    _old$l16$0: Ref(bool)
    __t19: Bool
    __t20: Bool
    __t21: Bool
    _old$pre$0: Ref(m_BoolArr32$_beg_$_end_)
    _old$pre$1: Ref(m_BoolArr32$_beg_$_end_)
    _1: Ref(ref$m_BoolArr32$_beg_$_end_)
    _2: Ref(ref$m_BoolArr32$_beg_$_end_)
    _3: Ref(m_BoolArr32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_142$3$13114848456984105119)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_145$3$5995690350403947267)
    _16: Ref(ref$usize)
    _17: Ref(ref$m_BoolArr32$_beg_$_end_)
    _18: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _19: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _20: Ref(bool)
    _21: Ref(ref$m_BoolArr32$_beg_$_end_)
    _22: Ref(usize)
    _23: Ref(bool)
    _24: Ref(ref$m_BoolArr32$_beg_$_end_)
    _25: Ref(usize)
    _26: Ref(ref$bool)
    _27: Ref(ref$m_BoolArr32$_beg_$_end_)
    _28: Ref(usize)
    _29: Ref(tuple2$usize$bool)
    _30: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#0}::or"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:324:5: 338:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_1)) && ((ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l23
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BoolArr32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BoolArr32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_0441df0c956548a09e2230baf180e174_101: Int  :: (((0) <= (_2_forall_0441df0c956548a09e2230baf180e174_101)) && (((_2_forall_0441df0c956548a09e2230baf180e174_101) < (32)) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_0441df0c956548a09e2230baf180e174_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$0, _2_forall_0441df0c956548a09e2230baf180e174_101)) || (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$1, _2_forall_0441df0c956548a09e2230baf180e174_101))))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BoolArr32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BoolArr32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BoolArr32::zero() -> [return: bb1, unwind: bb19]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101: Int  :: (((0) <= (_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)) && (((_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = const 0_usize
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy 0
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb18]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l2
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t16 := copy _7.val_bool
    GotoSwitch([(Local(__t16: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:30)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t17 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$1 := ghost _2.val_ref
    _preserve$0 := ghost _1.val_ref
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_605176880ec840179c4ee5c7355c11fa_101: Int  :: (((0) <= (_2_forall_605176880ec840179c4ee5c7355c11fa_101)) && (((_2_forall_605176880ec840179c4ee5c7355c11fa_101) < (_4.val_int)) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_605176880ec840179c4ee5c7355c11fa_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_605176880ec840179c4ee5c7355c11fa_101)) || (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_605176880ec840179c4ee5c7355c11fa_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    __t6 := builtin$havoc_bool()
    _26 := builtin$havoc_ref()
    __t21 := builtin$havoc_bool()
    _28 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    __t2 := builtin$havoc_bool()
    _4 := builtin$havoc_ref()
    __t11 := builtin$havoc_bool()
    _20 := builtin$havoc_ref()
    __t20 := builtin$havoc_bool()
    __t12 := builtin$havoc_bool()
    __t4 := builtin$havoc_bool()
    _29 := builtin$havoc_ref()
    _10 := builtin$havoc_ref()
    _25 := builtin$havoc_ref()
    __t9 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    _24 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    _7 := builtin$havoc_ref()
    __t5 := builtin$havoc_bool()
    _23 := builtin$havoc_ref()
    _14 := builtin$havoc_ref()
    _27 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    _21 := builtin$havoc_ref()
    _8 := builtin$havoc_ref()
    __t19 := builtin$havoc_bool()
    __t18 := builtin$havoc_bool()
    _22 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_605176880ec840179c4ee5c7355c11fa_101: Int  :: (((0) <= (_2_forall_605176880ec840179c4ee5c7355c11fa_101)) && (((_2_forall_605176880ec840179c4ee5c7355c11fa_101) < (_4.val_int)) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_605176880ec840179c4ee5c7355c11fa_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_605176880ec840179c4ee5c7355c11fa_101)) || (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_605176880ec840179c4ee5c7355c11fa_101))))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t18 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'_ (*_1)
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_ref, write)
    _21.val_ref := borrow _1.val_ref // L12
    label l5
    // [mir] StorageLive(_22)
    // [mir] _22 = _4
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_int, write)
    _22.val_int := copy _4.val_int
    label l6
    // [mir] _20 = BoolArr32::lookup(move _21, move _22) -> [return: bb13, unwind: bb18]
    label l7
    _20 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_20), write)
    inhale(Stmt) (_20.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_21.val_ref, _22.val_int))
    transfer perm _21.val_ref --> old[l7](_21.val_ref) // unchecked: false
    Goto(cfg:17)
  label l8 // 17
    // ========== l8 ==========
    // MIR edge bb12 --> bb13
    // Expire borrows
    expire_borrows ReborrowingDAG(L15,L12,)

    Goto(cfg:18)
  label loop2_group3_bb13 // 18
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] _24 = &'_ (*_2)
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(_24.val_ref, write)
    _24.val_ref := borrow _2.val_ref // L13
    label l9
    // [mir] StorageLive(_25)
    // [mir] _25 = _4
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_int, write)
    _25.val_int := copy _4.val_int
    label l10
    // [mir] _23 = BoolArr32::lookup(move _24, move _25) -> [return: bb14, unwind: bb18]
    label l11
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_23), write)
    inhale(Stmt) (_23.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _25.val_int))
    transfer perm _24.val_ref --> old[l11](_24.val_ref) // unchecked: false
    Goto(cfg:19)
  label l12 // 19
    // ========== l12 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    expire_borrows ReborrowingDAG(L14,L13,)

    Goto(cfg:20)
  label loop2_group3_bb14 // 20
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_25)
    // [mir] StorageDead(_24)
    // [mir] StorageLive(_26)
    // [mir] StorageLive(_27)
    // [mir] _27 = &'_ mut _3
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(_27.val_ref, write)
    _27.val_ref := mut borrow _3 // L5
    label l13
    // [mir] StorageLive(_28)
    // [mir] _28 = _4
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_int, write)
    _28.val_int := copy _4.val_int
    label l14
    // [mir] _26 = BoolArr32::index_mut(move _27, move _28) -> [return: bb15, unwind: bb18]
    label l15
    assert(Stmt) (((0) <= (_28.val_int)) && (((_28.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref))) && (true))) && (true)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_27)) && ((usize$inv<Ref(usize),Bool>(_28)) && (true))
    exhale (acc(_27.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_27.val_ref), write)) && ((acc(usize(_28), write)) && (true)))
    _26 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_26.val_ref, write)) && (acc(bool(_26.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_26)) && (true)
    inhale(Expr) ((_26.val_ref.val_bool) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _28.val_int)))) && (true)
    exhale true
    label l16
    Goto(cfg:21)
  label loop2_group3_bb15 // 21
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_28)
    // [mir] StorageDead(_27)
    // [mir] (*_26) = BitOr(move _20, move _23)
    _26.val_ref.val_bool := copy (_20.val_bool) || (_23.val_bool)
    expire_borrows ReborrowingDAG(L10,L11,L5,)

    // [mir] StorageDead(_23)
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_26)
    // [mir] _29 = CheckedAdd(_4, const 1_usize)
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.tuple_0, write)
    inhale(Stmt) acc(_29.tuple_0.val_int, write)
    inhale(Stmt) acc(_29.tuple_1, write)
    inhale(Stmt) acc(_29.tuple_1.val_bool, write)
    _29.tuple_0.val_int := copy (_4.val_int) + (1)
    _29.tuple_1.val_bool := copy false
    // [mir] assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb16, unwind: bb18]
    __t19 := copy _29.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t19)
    Goto(cfg:22)
  label loop2_group3_bb16 // 22
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _4 = move (_29.0: usize)
    _4 := move _29.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:23)
  label loop2_group4_bb2 // 23
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb18]
    Goto(cfg:24)
  label loop2_group4_bb3 // 24
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l18
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t20 := copy _7.val_bool
    GotoSwitch([(Local(__t20: Bool, Position { line: 0, column: 0, id: 0 }), cfg:26)], cfg:25)
  label l19 // 25
    // ========== l19 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:30)
  label l20 // 26
    // ========== l20 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:27)
  label loop2_group5_bb4 // 27
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:28)
  label loop2_group5_bb6 // 28
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t21 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:29)
  label loop2_end_body // 29
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_605176880ec840179c4ee5c7355c11fa_101: Int  :: (((0) <= (_2_forall_605176880ec840179c4ee5c7355c11fa_101)) && (((_2_forall_605176880ec840179c4ee5c7355c11fa_101) < (_4.val_int)) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_605176880ec840179c4ee5c7355c11fa_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_605176880ec840179c4ee5c7355c11fa_101)) || (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_605176880ec840179c4ee5c7355c11fa_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 30
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l21
    // [mir] StorageDead(_4)
    // [mir] drop(_3) -> [return: bb17, unwind: bb19]
    Goto(cfg:31)
  label bb17 // 31
    // ========== bb17 ==========
    __t15 := copy true
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_and(2 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t18: Bool
    _old$l16$0: Ref(bool)
    __t19: Bool
    __t20: Bool
    __t21: Bool
    _old$pre$0: Ref(m_BoolArr32$_beg_$_end_)
    _old$pre$1: Ref(m_BoolArr32$_beg_$_end_)
    _1: Ref(ref$m_BoolArr32$_beg_$_end_)
    _2: Ref(ref$m_BoolArr32$_beg_$_end_)
    _3: Ref(m_BoolArr32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_156$3$13114848456984105119)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_159$3$5995690350403947267)
    _16: Ref(ref$usize)
    _17: Ref(ref$m_BoolArr32$_beg_$_end_)
    _18: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _19: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _20: Ref(bool)
    _21: Ref(ref$m_BoolArr32$_beg_$_end_)
    _22: Ref(usize)
    _23: Ref(bool)
    _24: Ref(ref$m_BoolArr32$_beg_$_end_)
    _25: Ref(usize)
    _26: Ref(ref$bool)
    _27: Ref(ref$m_BoolArr32$_beg_$_end_)
    _28: Ref(usize)
    _29: Ref(tuple2$usize$bool)
    _30: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#0}::and"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:345:5: 359:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_1)) && ((ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l23
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BoolArr32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BoolArr32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_a4b5898d9dec4933af8066d4616bb0a5_101: Int  :: (((0) <= (_2_forall_a4b5898d9dec4933af8066d4616bb0a5_101)) && (((_2_forall_a4b5898d9dec4933af8066d4616bb0a5_101) < (32)) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_a4b5898d9dec4933af8066d4616bb0a5_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$0, _2_forall_a4b5898d9dec4933af8066d4616bb0a5_101)) && (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$1, _2_forall_a4b5898d9dec4933af8066d4616bb0a5_101))))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BoolArr32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BoolArr32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BoolArr32::zero() -> [return: bb1, unwind: bb19]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101: Int  :: (((0) <= (_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)) && (((_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = const 0_usize
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy 0
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb18]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l2
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t16 := copy _7.val_bool
    GotoSwitch([(Local(__t16: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:30)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t17 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    _preserve$1 := ghost _2.val_ref
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101: Int  :: (((0) <= (_2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101)) && (((_2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101) < (_4.val_int)) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101)) && (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    __t8 := builtin$havoc_bool()
    _23 := builtin$havoc_ref()
    _21 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    _26 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    _20 := builtin$havoc_ref()
    _7 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    __t20 := builtin$havoc_bool()
    _27 := builtin$havoc_ref()
    __t13 := builtin$havoc_bool()
    _28 := builtin$havoc_ref()
    _4 := builtin$havoc_ref()
    __t19 := builtin$havoc_bool()
    __t2 := builtin$havoc_bool()
    _10 := builtin$havoc_ref()
    _29 := builtin$havoc_ref()
    _24 := builtin$havoc_ref()
    __t6 := builtin$havoc_bool()
    _25 := builtin$havoc_ref()
    _14 := builtin$havoc_ref()
    __t18 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    _22 := builtin$havoc_ref()
    _8 := builtin$havoc_ref()
    __t12 := builtin$havoc_bool()
    __t21 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    __t10 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101: Int  :: (((0) <= (_2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101)) && (((_2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101) < (_4.val_int)) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101)) && (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101))))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t18 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'_ (*_1)
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_ref, write)
    _21.val_ref := borrow _1.val_ref // L12
    label l5
    // [mir] StorageLive(_22)
    // [mir] _22 = _4
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_int, write)
    _22.val_int := copy _4.val_int
    label l6
    // [mir] _20 = BoolArr32::lookup(move _21, move _22) -> [return: bb13, unwind: bb18]
    label l7
    _20 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_20), write)
    inhale(Stmt) (_20.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_21.val_ref, _22.val_int))
    transfer perm _21.val_ref --> old[l7](_21.val_ref) // unchecked: false
    Goto(cfg:17)
  label l8 // 17
    // ========== l8 ==========
    // MIR edge bb12 --> bb13
    // Expire borrows
    expire_borrows ReborrowingDAG(L10,L12,)

    Goto(cfg:18)
  label loop2_group3_bb13 // 18
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] _24 = &'_ (*_2)
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(_24.val_ref, write)
    _24.val_ref := borrow _2.val_ref // L15
    label l9
    // [mir] StorageLive(_25)
    // [mir] _25 = _4
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_int, write)
    _25.val_int := copy _4.val_int
    label l10
    // [mir] _23 = BoolArr32::lookup(move _24, move _25) -> [return: bb14, unwind: bb18]
    label l11
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_23), write)
    inhale(Stmt) (_23.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _25.val_int))
    transfer perm _24.val_ref --> old[l11](_24.val_ref) // unchecked: false
    Goto(cfg:19)
  label l12 // 19
    // ========== l12 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    expire_borrows ReborrowingDAG(L11,L15,)

    Goto(cfg:20)
  label loop2_group3_bb14 // 20
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_25)
    // [mir] StorageDead(_24)
    // [mir] StorageLive(_26)
    // [mir] StorageLive(_27)
    // [mir] _27 = &'_ mut _3
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(_27.val_ref, write)
    _27.val_ref := mut borrow _3 // L5
    label l13
    // [mir] StorageLive(_28)
    // [mir] _28 = _4
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_int, write)
    _28.val_int := copy _4.val_int
    label l14
    // [mir] _26 = BoolArr32::index_mut(move _27, move _28) -> [return: bb15, unwind: bb18]
    label l15
    assert(Stmt) (((0) <= (_28.val_int)) && (((_28.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref))) && (true))) && (true)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_27)) && ((usize$inv<Ref(usize),Bool>(_28)) && (true))
    exhale (acc(_27.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_27.val_ref), write)) && ((acc(usize(_28), write)) && (true)))
    _26 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_26.val_ref, write)) && (acc(bool(_26.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_26)) && (true)
    inhale(Expr) ((_26.val_ref.val_bool) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _28.val_int)))) && (true)
    exhale true
    label l16
    Goto(cfg:21)
  label loop2_group3_bb15 // 21
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_28)
    // [mir] StorageDead(_27)
    // [mir] (*_26) = BitAnd(move _20, move _23)
    _26.val_ref.val_bool := copy (_20.val_bool) && (_23.val_bool)
    expire_borrows ReborrowingDAG(L13,L14,L5,)

    // [mir] StorageDead(_23)
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_26)
    // [mir] _29 = CheckedAdd(_4, const 1_usize)
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.tuple_0, write)
    inhale(Stmt) acc(_29.tuple_0.val_int, write)
    inhale(Stmt) acc(_29.tuple_1, write)
    inhale(Stmt) acc(_29.tuple_1.val_bool, write)
    _29.tuple_0.val_int := copy (_4.val_int) + (1)
    _29.tuple_1.val_bool := copy false
    // [mir] assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb16, unwind: bb18]
    __t19 := copy _29.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t19)
    Goto(cfg:22)
  label loop2_group3_bb16 // 22
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _4 = move (_29.0: usize)
    _4 := move _29.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:23)
  label loop2_group4_bb2 // 23
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb18]
    Goto(cfg:24)
  label loop2_group4_bb3 // 24
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l18
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t20 := copy _7.val_bool
    GotoSwitch([(Local(__t20: Bool, Position { line: 0, column: 0, id: 0 }), cfg:26)], cfg:25)
  label l19 // 25
    // ========== l19 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:30)
  label l20 // 26
    // ========== l20 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:27)
  label loop2_group5_bb4 // 27
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:28)
  label loop2_group5_bb6 // 28
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t21 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:29)
  label loop2_end_body // 29
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101: Int  :: (((0) <= (_2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101)) && (((_2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101) < (_4.val_int)) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101)) == ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101)) && (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_ff2f28a503c74a8e8b7db10b80a1cef7_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 30
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l21
    // [mir] StorageDead(_4)
    // [mir] drop(_3) -> [return: bb17, unwind: bb19]
    Goto(cfg:31)
  label bb17 // 31
    // ========== bb17 ==========
    __t15 := copy true
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_xor(2 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t18: Bool
    _old$l16$0: Ref(bool)
    __t19: Bool
    __t20: Bool
    __t21: Bool
    _old$pre$0: Ref(m_BoolArr32$_beg_$_end_)
    _old$pre$1: Ref(m_BoolArr32$_beg_$_end_)
    _1: Ref(ref$m_BoolArr32$_beg_$_end_)
    _2: Ref(ref$m_BoolArr32$_beg_$_end_)
    _3: Ref(m_BoolArr32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_170$3$13114848456984105119)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_173$3$5995690350403947267)
    _16: Ref(ref$usize)
    _17: Ref(ref$m_BoolArr32$_beg_$_end_)
    _18: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _19: Ref(ref$ref$m_BoolArr32$_beg_$_end_)
    _20: Ref(bool)
    _21: Ref(ref$m_BoolArr32$_beg_$_end_)
    _22: Ref(usize)
    _23: Ref(bool)
    _24: Ref(ref$m_BoolArr32$_beg_$_end_)
    _25: Ref(usize)
    _26: Ref(ref$bool)
    _27: Ref(ref$m_BoolArr32$_beg_$_end_)
    _28: Ref(usize)
    _29: Ref(tuple2$usize$bool)
    _30: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#0}::xor"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:366:5: 380:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_1)) && ((ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l23
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BoolArr32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BoolArr32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_6141c0bff5ec4e7b873ab30d99854094_101: Int  :: (((0) <= (_2_forall_6141c0bff5ec4e7b873ab30d99854094_101)) && (((_2_forall_6141c0bff5ec4e7b873ab30d99854094_101) < (32)) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_6141c0bff5ec4e7b873ab30d99854094_101)) == (!((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$0, _2_forall_6141c0bff5ec4e7b873ab30d99854094_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_old$pre$1, _2_forall_6141c0bff5ec4e7b873ab30d99854094_101)))))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BoolArr32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BoolArr32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BoolArr32::zero() -> [return: bb1, unwind: bb19]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101: Int  :: (((0) <= (_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)) && (((_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = const 0_usize
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy 0
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb18]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l2
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t16 := copy _7.val_bool
    GotoSwitch([(Local(__t16: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:30)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t17 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$1 := ghost _2.val_ref
    _preserve$0 := ghost _1.val_ref
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_6c9d0f511e42430691075c716aae94d9_101: Int  :: (((0) <= (_2_forall_6c9d0f511e42430691075c716aae94d9_101)) && (((_2_forall_6c9d0f511e42430691075c716aae94d9_101) < (_4.val_int)) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_6c9d0f511e42430691075c716aae94d9_101)) == (!((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_6c9d0f511e42430691075c716aae94d9_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_6c9d0f511e42430691075c716aae94d9_101)))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    __t3 := builtin$havoc_bool()
    _8 := builtin$havoc_ref()
    __t18 := builtin$havoc_bool()
    _27 := builtin$havoc_ref()
    __t5 := builtin$havoc_bool()
    _14 := builtin$havoc_ref()
    __t6 := builtin$havoc_bool()
    _28 := builtin$havoc_ref()
    _21 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    _4 := builtin$havoc_ref()
    _23 := builtin$havoc_ref()
    _24 := builtin$havoc_ref()
    __t21 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    _25 := builtin$havoc_ref()
    __t20 := builtin$havoc_bool()
    _26 := builtin$havoc_ref()
    __t19 := builtin$havoc_bool()
    __t8 := builtin$havoc_bool()
    _20 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    __t2 := builtin$havoc_bool()
    __t12 := builtin$havoc_bool()
    _29 := builtin$havoc_ref()
    _22 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    _10 := builtin$havoc_ref()
    _7 := builtin$havoc_ref()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_6c9d0f511e42430691075c716aae94d9_101: Int  :: (((0) <= (_2_forall_6c9d0f511e42430691075c716aae94d9_101)) && (((_2_forall_6c9d0f511e42430691075c716aae94d9_101) < (_4.val_int)) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_6c9d0f511e42430691075c716aae94d9_101)) == (!((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_6c9d0f511e42430691075c716aae94d9_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_6c9d0f511e42430691075c716aae94d9_101)))))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t18 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'_ (*_1)
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_ref, write)
    _21.val_ref := borrow _1.val_ref // L14
    label l5
    // [mir] StorageLive(_22)
    // [mir] _22 = _4
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_int, write)
    _22.val_int := copy _4.val_int
    label l6
    // [mir] _20 = BoolArr32::lookup(move _21, move _22) -> [return: bb13, unwind: bb18]
    label l7
    _20 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_20), write)
    inhale(Stmt) (_20.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_21.val_ref, _22.val_int))
    transfer perm _21.val_ref --> old[l7](_21.val_ref) // unchecked: false
    Goto(cfg:17)
  label l8 // 17
    // ========== l8 ==========
    // MIR edge bb12 --> bb13
    // Expire borrows
    expire_borrows ReborrowingDAG(L12,L14,)

    Goto(cfg:18)
  label loop2_group3_bb13 // 18
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] _24 = &'_ (*_2)
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(_24.val_ref, write)
    _24.val_ref := borrow _2.val_ref // L13
    label l9
    // [mir] StorageLive(_25)
    // [mir] _25 = _4
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_int, write)
    _25.val_int := copy _4.val_int
    label l10
    // [mir] _23 = BoolArr32::lookup(move _24, move _25) -> [return: bb14, unwind: bb18]
    label l11
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_23), write)
    inhale(Stmt) (_23.val_bool) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_24.val_ref, _25.val_int))
    transfer perm _24.val_ref --> old[l11](_24.val_ref) // unchecked: false
    Goto(cfg:19)
  label l12 // 19
    // ========== l12 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    expire_borrows ReborrowingDAG(L15,L13,)

    Goto(cfg:20)
  label loop2_group3_bb14 // 20
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_25)
    // [mir] StorageDead(_24)
    // [mir] StorageLive(_26)
    // [mir] StorageLive(_27)
    // [mir] _27 = &'_ mut _3
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(_27.val_ref, write)
    _27.val_ref := mut borrow _3 // L5
    label l13
    // [mir] StorageLive(_28)
    // [mir] _28 = _4
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_int, write)
    _28.val_int := copy _4.val_int
    label l14
    // [mir] _26 = BoolArr32::index_mut(move _27, move _28) -> [return: bb15, unwind: bb18]
    label l15
    assert(Stmt) (((0) <= (_28.val_int)) && (((_28.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_27.val_ref))) && (true))) && (true)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_27)) && ((usize$inv<Ref(usize),Bool>(_28)) && (true))
    exhale (acc(_27.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_27.val_ref), write)) && ((acc(usize(_28), write)) && (true)))
    _26 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_26.val_ref, write)) && (acc(bool(_26.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_26)) && (true)
    inhale(Expr) ((_26.val_ref.val_bool) == (old[l15](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_27.val_ref, _28.val_int)))) && (true)
    exhale true
    label l16
    Goto(cfg:21)
  label loop2_group3_bb15 // 21
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_28)
    // [mir] StorageDead(_27)
    // [mir] (*_26) = BitXor(move _20, move _23)
    _26.val_ref.val_bool := copy !((_20.val_bool) == (_23.val_bool))
    expire_borrows ReborrowingDAG(L10,L11,L5,)

    // [mir] StorageDead(_23)
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_26)
    // [mir] _29 = CheckedAdd(_4, const 1_usize)
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.tuple_0, write)
    inhale(Stmt) acc(_29.tuple_0.val_int, write)
    inhale(Stmt) acc(_29.tuple_1, write)
    inhale(Stmt) acc(_29.tuple_1.val_bool, write)
    _29.tuple_0.val_int := copy (_4.val_int) + (1)
    _29.tuple_1.val_bool := copy false
    // [mir] assert(!move (_29.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb16, unwind: bb18]
    __t19 := copy _29.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t19)
    Goto(cfg:22)
  label loop2_group3_bb16 // 22
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _4 = move (_29.0: usize)
    _4 := move _29.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:23)
  label loop2_group4_bb2 // 23
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb18]
    Goto(cfg:24)
  label loop2_group4_bb3 // 24
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l18
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t20 := copy _7.val_bool
    GotoSwitch([(Local(__t20: Bool, Position { line: 0, column: 0, id: 0 }), cfg:26)], cfg:25)
  label l19 // 25
    // ========== l19 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:30)
  label l20 // 26
    // ========== l20 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:27)
  label loop2_group5_bb4 // 27
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:28)
  label loop2_group5_bb6 // 28
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t21 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:29)
  label loop2_end_body // 29
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_6c9d0f511e42430691075c716aae94d9_101: Int  :: (((0) <= (_2_forall_6c9d0f511e42430691075c716aae94d9_101)) && (((_2_forall_6c9d0f511e42430691075c716aae94d9_101) < (_4.val_int)) && (true))) ==> ((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_6c9d0f511e42430691075c716aae94d9_101)) == (!((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_6c9d0f511e42430691075c716aae94d9_101)) == (m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_6c9d0f511e42430691075c716aae94d9_101)))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 30
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l21
    // [mir] StorageDead(_4)
    // [mir] drop(_3) -> [return: bb17, unwind: bb19]
    Goto(cfg:31)
  label bb17 // 31
    // ========== bb17 ==========
    __t15 := copy true
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


function m_main$$$opencur$impl$sharp$1$closecur$$$len(_1: Ref(m_BitVec32$_beg_$_end_)): Int
  requires (acc(m_BitVec32$_beg_$_end_(_1), read)) && (true)
  requires true
  ensures ((__result) == (32)) && (true)


function m_main$$$opencur$impl$sharp$1$closecur$$$lookup(_1: Ref(m_BitVec32$_beg_$_end_), _2: Int): Bool
  requires (acc(m_BitVec32$_beg_$_end_(_1), read)) && (true)
  requires (((0) <= (_2)) && (((_2) < (m_main$$$opencur$impl$sharp$1$closecur$$$len<Ref(m_BitVec32$_beg_$_end_),Int>(_1))) && (true))) && (true)
  ensures true


method m_reverse_bits_v(1 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    _preserve$0: Ref(AuxRef)
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    __t21: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(m_BitVec32$_beg_$_end_)
    _3: Ref(usize)
    _4: Ref(tuple0$)
    _5: Ref(tuple0$)
    _6: Ref(bool)
    _7: Ref(usize)
    _8: Ref(tuple0$)
    _9: Ref(bool)
    _10: Ref(closure$0_214$3$13114848456984105119)
    _11: Ref(ref$usize)
    _12: Ref(tuple0$)
    _13: Ref(bool)
    _14: Ref(closure$0_217$3$2331299993329797620)
    _15: Ref(ref$usize)
    _16: Ref(ref$m_BitVec32$_beg_$_end_)
    _17: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _18: Ref(tuple0$)
    _19: Ref(ref$m_BitVec32$_beg_$_end_)
    _20: Ref(usize)
    _21: Ref(bool)
    _22: Ref(ref$m_BitVec32$_beg_$_end_)
    _23: Ref(usize)
    _24: Ref(usize)
    _25: Ref(tuple2$usize$bool)
    _26: Ref(tuple2$usize$bool)
    _27: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#1}::reverse_bits_v"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:506:5: 526:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && (true))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && (true)
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l21
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_4200c771519b4853aa24783f5d76e2df_101: Int  :: (((0) <= (_2_forall_4200c771519b4853aa24783f5d76e2df_101)) && (((_2_forall_4200c771519b4853aa24783f5d76e2df_101) < (32)) && (true))) ==> ((!(false))?((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_0, _2_forall_4200c771519b4853aa24783f5d76e2df_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$0, (31) - (_2_forall_4200c771519b4853aa24783f5d76e2df_101)))):(false))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_2)
    // [mir] _2 = BitVec32::zero() -> [return: bb1, unwind: bb17]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _2 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_2), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_2)) && (true)
    inhale(Expr) (forall _2_forall_6e18d74b08724366806ddc03a6946ae9_101: Int  :: (((0) <= (_2_forall_6e18d74b08724366806ddc03a6946ae9_101)) && (((_2_forall_6e18d74b08724366806ddc03a6946ae9_101) < (32)) && (true))) ==> (!(m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2, _2_forall_6e18d74b08724366806ddc03a6946ae9_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _2)
    // [mir] StorageLive(_3)
    // [mir] _3 = const 0_usize
    _3 := builtin$havoc_ref()
    inhale(Stmt) acc(_3.val_int, write)
    _3.val_int := copy 0
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] _7 = _3
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_int, write)
    _7.val_int := copy _3.val_int
    label l2
    // [mir] _6 = Lt(move _7, const 32_usize)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_bool, write)
    _6.val_bool := copy (_7.val_int) < (32)
    // [mir] StorageDead(_7)
    // [mir] FakeRead(ForMatchedPlace, _6)
    // [mir] switchInt(_6) -> [false: bb5, otherwise: bb4]
    __t15 := copy _6.val_bool
    GotoSwitch([(Local(__t15: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:30)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_8)
    // [mir] StorageLive(_9)
    // [mir] _9 = const false
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy false
    // [mir] switchInt(move _9) -> [false: bb8, otherwise: bb7]
    __t16 := copy _9.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    obtain acc(bool(_6), write)
    obtain acc(usize(_3), write)
    obtain acc(m_BitVec32$_beg_$_end_(_2), write)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= (_3.val_int)) && (((_3.val_int) < (32)) && (true))) && ((forall _2_forall_8a3439d84ad248588294c52d2faa4353_101: Int  :: (((0) <= (_2_forall_8a3439d84ad248588294c52d2faa4353_101)) && (((_2_forall_8a3439d84ad248588294c52d2faa4353_101) < (_3.val_int)) && (true))) ==> ((!(false))?((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2, _2_forall_8a3439d84ad248588294c52d2faa4353_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, (31) - (_2_forall_8a3439d84ad248588294c52d2faa4353_101)))):(false))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_6), write)) && ((acc(usize(_3), write)) && ((acc(m_BitVec32$_beg_$_end_(_2), write)) && ((acc(_1.val_ref, read)) && (true))))
    __t7 := builtin$havoc_bool()
    _23 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    __t19 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    _13 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    __t2 := builtin$havoc_bool()
    _9 := builtin$havoc_ref()
    __t11 := builtin$havoc_bool()
    _18 := builtin$havoc_ref()
    _26 := builtin$havoc_ref()
    _19 := builtin$havoc_ref()
    _20 := builtin$havoc_ref()
    _25 := builtin$havoc_ref()
    __t18 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    __t21 := builtin$havoc_bool()
    _6 := builtin$havoc_ref()
    _24 := builtin$havoc_ref()
    _22 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    __t12 := builtin$havoc_bool()
    _3 := builtin$havoc_ref()
    __t20 := builtin$havoc_bool()
    _21 := builtin$havoc_ref()
    __t6 := builtin$havoc_bool()
    __t17 := builtin$havoc_bool()
    _7 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_6), write)) && ((acc(usize(_3), write)) && ((acc(m_BitVec32$_beg_$_end_(_2), write)) && ((acc(_1.val_ref, read)) && (true))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    inhale(Expr) (((0) <= (_3.val_int)) && (((_3.val_int) < (32)) && (true))) && ((forall _2_forall_8a3439d84ad248588294c52d2faa4353_101: Int  :: (((0) <= (_2_forall_8a3439d84ad248588294c52d2faa4353_101)) && (((_2_forall_8a3439d84ad248588294c52d2faa4353_101) < (_3.val_int)) && (true))) ==> ((!(false))?((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2, _2_forall_8a3439d84ad248588294c52d2faa4353_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, (31) - (_2_forall_8a3439d84ad248588294c52d2faa4353_101)))):(false))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _8 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_8)
    // [mir] StorageLive(_12)
    // [mir] StorageLive(_13)
    // [mir] _13 = const false
    _13 := builtin$havoc_ref()
    inhale(Stmt) acc(_13.val_bool, write)
    _13.val_bool := copy false
    // [mir] switchInt(move _13) -> [false: bb11, otherwise: bb10]
    __t17 := copy _13.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _12 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_13)
    // [mir] StorageDead(_12)
    // [mir] StorageLive(_18)
    // [mir] StorageLive(_19)
    // [mir] _19 = &'_ mut _2
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_ref, write)
    _19.val_ref := mut borrow _2 // L4
    label l5
    // [mir] StorageLive(_20)
    // [mir] _20 = _3
    _20 := builtin$havoc_ref()
    inhale(Stmt) acc(_20.val_int, write)
    _20.val_int := copy _3.val_int
    label l6
    // [mir] StorageLive(_21)
    // [mir] StorageLive(_22)
    // [mir] _22 = &'_ (*_1)
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_ref, write)
    _22.val_ref := borrow _1.val_ref // L8
    label l7
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] _24 = _3
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(_24.val_int, write)
    _24.val_int := copy _3.val_int
    label l8
    // [mir] _25 = CheckedSub(const 31_usize, _24)
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.tuple_0, write)
    inhale(Stmt) acc(_25.tuple_0.val_int, write)
    inhale(Stmt) acc(_25.tuple_1, write)
    inhale(Stmt) acc(_25.tuple_1.val_bool, write)
    _25.tuple_0.val_int := copy (31) - (_24.val_int)
    _25.tuple_1.val_bool := copy false
    // [mir] assert(!move (_25.1: bool), "attempt to compute `{} - {}`, which would overflow", const 31_usize, move _24) -> [success: bb13, unwind: bb17]
    __t18 := copy _25.tuple_1.val_bool
    // Rust assertion: attempt to subtract with overflow
    assert(Stmt) !(__t18)
    Goto(cfg:17)
  label loop2_group3_bb13 // 17
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] _23 = move (_25.0: usize)
    _23 := move _25.tuple_0
    label l9
    // [mir] StorageDead(_24)
    // [mir] _21 = BitVec32::lookup(move _22, move _23) -> [return: bb14, unwind: bb17]
    label l10
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_21), write)
    inhale(Stmt) (_21.val_bool) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_22.val_ref, _23.val_int))
    transfer perm _22.val_ref --> old[l10](_22.val_ref) // unchecked: false
    Goto(cfg:18)
  label l11 // 18
    // ========== l11 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    expire_borrows ReborrowingDAG(L9,L8,)

    Goto(cfg:19)
  label loop2_group3_bb14 // 19
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_22)
    // [mir] _18 = BitVec32::set_bit(move _19, move _20, move _21) -> [return: bb15, unwind: bb17]
    label l12
    assert(Stmt) (((0) <= (_20.val_int)) && (((_20.val_int) < (m_main$$$opencur$impl$sharp$1$closecur$$$len<Ref(m_BitVec32$_beg_$_end_),Int>(_19.val_ref))) && (true))) && (true)
    assert(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_19)) && ((usize$inv<Ref(usize),Bool>(_20)) && ((bool$inv<Ref(bool),Bool>(_21)) && (true)))
    exhale (acc(_19.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_19.val_ref), write)) && ((acc(usize(_20), write)) && ((acc(bool(_21), write)) && (true))))
    _18 := builtin$havoc_ref()
    inhale(Stmt) (acc(m_BitVec32$_beg_$_end_(old[l12](_19.val_ref)), write)) && (true)
    inhale(Stmt) acc(tuple0$(_18), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(old[l12](_19.val_ref))) && ((tuple0$$inv<Ref(tuple0$),Bool>(_18)) && (true))
    inhale(Expr) ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l12](_19.val_ref), old[l12](_20.val_int))) == (old[l12](_21.val_bool))) && ((forall _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101: Int  :: (((0) <= (_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101)) && (((_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101) < (32)) && ((!((_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101) == (old[l12](_20.val_int)))) && (true)))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l12](_19.val_ref), _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101)) == (old[l12](m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_19.val_ref, _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101))))) && (true))
    exhale true
    label l13
    Goto(cfg:20)
  label l14 // 20
    // ========== l14 ==========
    // MIR edge bb14 --> bb15
    // Expire borrows
    expire_borrows ReborrowingDAG(L10,L4,)

    Goto(cfg:21)
  label loop2_group3_bb15 // 21
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_21)
    // [mir] StorageDead(_20)
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_18)
    // [mir] _26 = CheckedAdd(_3, const 1_usize)
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.tuple_0, write)
    inhale(Stmt) acc(_26.tuple_0.val_int, write)
    inhale(Stmt) acc(_26.tuple_1, write)
    inhale(Stmt) acc(_26.tuple_1.val_bool, write)
    _26.tuple_0.val_int := copy (_3.val_int) + (1)
    _26.tuple_1.val_bool := copy false
    // [mir] assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_usize) -> [success: bb16, unwind: bb17]
    __t19 := copy _26.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t19)
    Goto(cfg:22)
  label loop2_group3_bb16 // 22
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _3 = move (_26.0: usize)
    _3 := move _26.tuple_0
    label l15
    // [mir] _5 = const ()
    // [mir] StorageDead(_6)
    // [mir] goto -> bb2
    Goto(cfg:23)
  label loop2_group4_bb2 // 23
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:24)
  label loop2_group4_bb3 // 24
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] _7 = _3
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_int, write)
    _7.val_int := copy _3.val_int
    label l16
    // [mir] _6 = Lt(move _7, const 32_usize)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_bool, write)
    _6.val_bool := copy (_7.val_int) < (32)
    // [mir] StorageDead(_7)
    // [mir] FakeRead(ForMatchedPlace, _6)
    // [mir] switchInt(_6) -> [false: bb5, otherwise: bb4]
    __t20 := copy _6.val_bool
    GotoSwitch([(Local(__t20: Bool, Position { line: 0, column: 0, id: 0 }), cfg:26)], cfg:25)
  label l17 // 25
    // ========== l17 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:30)
  label l18 // 26
    // ========== l18 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:27)
  label loop2_group5_bb4 // 27
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:28)
  label loop2_group5_bb6 // 28
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_8)
    // [mir] StorageLive(_9)
    // [mir] _9 = const false
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(_9.val_bool, write)
    _9.val_bool := copy false
    // [mir] switchInt(move _9) -> [false: bb8, otherwise: bb7]
    __t21 := copy _9.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:29)
  label loop2_end_body // 29
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    obtain acc(bool(_6), write)
    obtain acc(usize(_3), write)
    obtain acc(m_BitVec32$_beg_$_end_(_2), write)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= (_3.val_int)) && (((_3.val_int) < (32)) && (true))) && ((forall _2_forall_8a3439d84ad248588294c52d2faa4353_101: Int  :: (((0) <= (_2_forall_8a3439d84ad248588294c52d2faa4353_101)) && (((_2_forall_8a3439d84ad248588294c52d2faa4353_101) < (_3.val_int)) && (true))) ==> ((!(false))?((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2, _2_forall_8a3439d84ad248588294c52d2faa4353_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, (31) - (_2_forall_8a3439d84ad248588294c52d2faa4353_101)))):(false))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_6), write)) && ((acc(usize(_3), write)) && ((acc(m_BitVec32$_beg_$_end_(_2), write)) && ((acc(_1.val_ref, read)) && (true))))
    inhale(Stmt) false
    Return
  label bb5 // 30
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _4 = const ()
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_4)
    // [mir] _0 = move _2
    _0 := move _2
    label l19
    // [mir] StorageDead(_3)
    // [mir] StorageDead(_2)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_shl_v(2 args)
    returns (_0: Ref(m_BoolArr32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    __t21: Bool
    _preserve$0: Ref(AuxRef)
    __t22: Bool
    __t23: Bool
    __t24: Bool
    __t25: Bool
    _old$l15$0: Ref(bool)
    __t26: Bool
    __t27: Bool
    __t28: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(usize)
    _3: Ref(m_BoolArr32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_245$3$13114848456984105119)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_248$3$3859392265678673261)
    _16: Ref(ref$usize)
    _17: Ref(ref$usize)
    _18: Ref(tuple0$)
    _19: Ref(bool)
    _20: Ref(closure$0_252$3$2449336065822019816)
    _21: Ref(ref$usize)
    _22: Ref(ref$usize)
    _23: Ref(ref$m_BoolArr32$_beg_$_end_)
    _24: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _25: Ref(tuple0$)
    _26: Ref(bool)
    _27: Ref(closure$0_261$3$12351797966212270264)
    _28: Ref(ref$usize)
    _29: Ref(ref$m_BoolArr32$_beg_$_end_)
    _30: Ref(bool)
    _31: Ref(ref$m_BitVec32$_beg_$_end_)
    _32: Ref(usize)
    _33: Ref(usize)
    _34: Ref(usize)
    _35: Ref(tuple2$usize$bool)
    _36: Ref(ref$bool)
    _37: Ref(ref$m_BoolArr32$_beg_$_end_)
    _38: Ref(usize)
    _39: Ref(tuple2$usize$bool)
    _40: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#1}::shl_v"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:555:5: 585:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    __t16 := copy false
    __t17 := copy false
    __t18 := copy false
    __t19 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(usize(_2), write)) && (true)))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((usize$inv<Ref(usize),Bool>(_2)) && (true))
    inhale(Expr) ((0) <= (_2.val_int)) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l23
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_ff8e2998b11947cea980d4b7c5a0c4b0_101: Int  :: ((((0) <= (_2_forall_ff8e2998b11947cea980d4b7c5a0c4b0_101)) && (((_2_forall_ff8e2998b11947cea980d4b7c5a0c4b0_101) < (32)) && (true))) && ((((old[pre](_2.val_int)) <= (_2_forall_ff8e2998b11947cea980d4b7c5a0c4b0_101)) && (((!(false))?(((_2_forall_ff8e2998b11947cea980d4b7c5a0c4b0_101) - (old[pre](_2.val_int))) >= (0)):(false)) && (((!(false))?(((_2_forall_ff8e2998b11947cea980d4b7c5a0c4b0_101) - (old[pre](_2.val_int))) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_ff8e2998b11947cea980d4b7c5a0c4b0_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$0, (_2_forall_ff8e2998b11947cea980d4b7c5a0c4b0_101) - (old[pre](_2.val_int))))):(false))) && ((forall _2_forall_9740b3c02a394f0f87ba8c554487e436_101: Int  :: (((0) <= (_2_forall_9740b3c02a394f0f87ba8c554487e436_101)) && (((_2_forall_9740b3c02a394f0f87ba8c554487e436_101) < (old[pre](_2.val_int))) && (((_2_forall_9740b3c02a394f0f87ba8c554487e436_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_0, _2_forall_9740b3c02a394f0f87ba8c554487e436_101)))) && (true))
    // Assert type invariants
    assert(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BoolArr32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BoolArr32::zero() -> [return: bb1, unwind: bb25]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BoolArr32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BoolArr32$_beg_$_end_$inv<Ref(m_BoolArr32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101: Int  :: (((0) <= (_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)) && (((_2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101) < (32)) && (true))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_8ea3d130b2524ab3a2a8d11173125f9d_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = _2
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy _2.val_int
    label l2
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb24]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l3
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t20 := copy _7.val_bool
    GotoSwitch([(Local(__t20: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l4 // 7
    // ========== l4 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:33)
  label l5 // 8
    // ========== l5 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t21 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(usize(_2), read)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((((_2.val_int) <= (_4.val_int)) && (((!(false))?(((_4.val_int) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_4.val_int) - (_2.val_int)) < (32)):(false)) && (true)))) && ((forall _2_forall_977eda70ddb64558b9762160737aeda9_101: Int  :: ((((0) <= (_2_forall_977eda70ddb64558b9762160737aeda9_101)) && (((_2_forall_977eda70ddb64558b9762160737aeda9_101) < (_4.val_int)) && (((_2_forall_977eda70ddb64558b9762160737aeda9_101) >= (_2.val_int)) && (true)))) && ((((_2.val_int) <= (_2_forall_977eda70ddb64558b9762160737aeda9_101)) && (((!(false))?(((_2_forall_977eda70ddb64558b9762160737aeda9_101) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_2_forall_977eda70ddb64558b9762160737aeda9_101) - (_2.val_int)) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_977eda70ddb64558b9762160737aeda9_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, (_2_forall_977eda70ddb64558b9762160737aeda9_101) - (_2.val_int)))):(false))) && ((forall _2_forall_48ae03eed98344ae9367c48f0018be80_101: Int  :: (((0) <= (_2_forall_48ae03eed98344ae9367c48f0018be80_101)) && (((_2_forall_48ae03eed98344ae9367c48f0018be80_101) < (_2.val_int)) && (((_2_forall_48ae03eed98344ae9367c48f0018be80_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_48ae03eed98344ae9367c48f0018be80_101)))) && (true))))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    _30 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    _26 := builtin$havoc_ref()
    __t10 := builtin$havoc_bool()
    _35 := builtin$havoc_ref()
    _14 := builtin$havoc_ref()
    __t25 := builtin$havoc_bool()
    __t12 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    _4 := builtin$havoc_ref()
    __t5 := builtin$havoc_bool()
    _8 := builtin$havoc_ref()
    _19 := builtin$havoc_ref()
    _37 := builtin$havoc_ref()
    __t27 := builtin$havoc_bool()
    __t2 := builtin$havoc_bool()
    __t28 := builtin$havoc_bool()
    __t6 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    _38 := builtin$havoc_ref()
    __t17 := builtin$havoc_bool()
    _36 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    _39 := builtin$havoc_ref()
    __t14 := builtin$havoc_bool()
    __t22 := builtin$havoc_bool()
    _10 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    __t16 := builtin$havoc_bool()
    __t26 := builtin$havoc_bool()
    _31 := builtin$havoc_ref()
    _32 := builtin$havoc_ref()
    __t24 := builtin$havoc_bool()
    __t23 := builtin$havoc_bool()
    __t7 := builtin$havoc_bool()
    __t15 := builtin$havoc_bool()
    _7 := builtin$havoc_ref()
    _34 := builtin$havoc_ref()
    _33 := builtin$havoc_ref()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    inhale(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((((_2.val_int) <= (_4.val_int)) && (((!(false))?(((_4.val_int) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_4.val_int) - (_2.val_int)) < (32)):(false)) && (true)))) && ((forall _2_forall_977eda70ddb64558b9762160737aeda9_101: Int  :: ((((0) <= (_2_forall_977eda70ddb64558b9762160737aeda9_101)) && (((_2_forall_977eda70ddb64558b9762160737aeda9_101) < (_4.val_int)) && (((_2_forall_977eda70ddb64558b9762160737aeda9_101) >= (_2.val_int)) && (true)))) && ((((_2.val_int) <= (_2_forall_977eda70ddb64558b9762160737aeda9_101)) && (((!(false))?(((_2_forall_977eda70ddb64558b9762160737aeda9_101) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_2_forall_977eda70ddb64558b9762160737aeda9_101) - (_2.val_int)) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_977eda70ddb64558b9762160737aeda9_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, (_2_forall_977eda70ddb64558b9762160737aeda9_101) - (_2.val_int)))):(false))) && ((forall _2_forall_48ae03eed98344ae9367c48f0018be80_101: Int  :: (((0) <= (_2_forall_48ae03eed98344ae9367c48f0018be80_101)) && (((_2_forall_48ae03eed98344ae9367c48f0018be80_101) < (_2.val_int)) && (((_2_forall_48ae03eed98344ae9367c48f0018be80_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_48ae03eed98344ae9367c48f0018be80_101)))) && (true))))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t22 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_18)
    // [mir] StorageLive(_19)
    // [mir] _19 = const false
    _19 := builtin$havoc_ref()
    inhale(Stmt) acc(_19.val_bool, write)
    _19.val_bool := copy false
    // [mir] switchInt(move _19) -> [false: bb14, otherwise: bb13]
    __t23 := copy _19.val_bool
    // Ignore default target bb13, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:17)
  label loop2_group3_bb14 // 17
    // ========== loop2_group3_bb14 ==========
    __t10 := copy true
    // [mir] _18 = const ()
    // [mir] goto -> bb15
    Goto(cfg:18)
  label loop2_group3_bb15 // 18
    // ========== loop2_group3_bb15 ==========
    __t11 := copy true
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_18)
    // [mir] StorageLive(_25)
    // [mir] StorageLive(_26)
    // [mir] _26 = const false
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.val_bool, write)
    _26.val_bool := copy false
    // [mir] switchInt(move _26) -> [false: bb17, otherwise: bb16]
    __t24 := copy _26.val_bool
    // Ignore default target bb16, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:19)
  label loop2_group3_bb17 // 19
    // ========== loop2_group3_bb17 ==========
    __t12 := copy true
    // [mir] _25 = const ()
    // [mir] goto -> bb18
    Goto(cfg:20)
  label loop2_group3_bb18 // 20
    // ========== loop2_group3_bb18 ==========
    __t13 := copy true
    // [mir] StorageDead(_26)
    // [mir] StorageDead(_25)
    // [mir] StorageLive(_30)
    // [mir] StorageLive(_31)
    // [mir] _31 = &'_ (*_1)
    _31 := builtin$havoc_ref()
    inhale(Stmt) acc(_31.val_ref, write)
    _31.val_ref := borrow _1.val_ref // L13
    label l6
    // [mir] StorageLive(_32)
    // [mir] StorageLive(_33)
    // [mir] _33 = _4
    _33 := builtin$havoc_ref()
    inhale(Stmt) acc(_33.val_int, write)
    _33.val_int := copy _4.val_int
    label l7
    // [mir] StorageLive(_34)
    // [mir] _34 = _2
    _34 := builtin$havoc_ref()
    inhale(Stmt) acc(_34.val_int, write)
    _34.val_int := copy _2.val_int
    label l8
    // [mir] _35 = CheckedSub(_33, _34)
    _35 := builtin$havoc_ref()
    inhale(Stmt) acc(_35.tuple_0, write)
    inhale(Stmt) acc(_35.tuple_0.val_int, write)
    inhale(Stmt) acc(_35.tuple_1, write)
    inhale(Stmt) acc(_35.tuple_1.val_bool, write)
    _35.tuple_0.val_int := copy (_33.val_int) - (_34.val_int)
    _35.tuple_1.val_bool := copy false
    // [mir] assert(!move (_35.1: bool), "attempt to compute `{} - {}`, which would overflow", move _33, move _34) -> [success: bb19, unwind: bb24]
    __t25 := copy _35.tuple_1.val_bool
    // Rust assertion: attempt to subtract with overflow
    assert(Stmt) !(__t25)
    Goto(cfg:21)
  label loop2_group3_bb19 // 21
    // ========== loop2_group3_bb19 ==========
    __t14 := copy true
    // [mir] _32 = move (_35.0: usize)
    _32 := move _35.tuple_0
    label l9
    // [mir] StorageDead(_34)
    // [mir] StorageDead(_33)
    // [mir] _30 = BitVec32::lookup(move _31, move _32) -> [return: bb20, unwind: bb24]
    label l10
    _30 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_30), write)
    inhale(Stmt) (_30.val_bool) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_31.val_ref, _32.val_int))
    transfer perm _31.val_ref --> old[l10](_31.val_ref) // unchecked: false
    Goto(cfg:22)
  label l11 // 22
    // ========== l11 ==========
    // MIR edge bb19 --> bb20
    // Expire borrows
    expire_borrows ReborrowingDAG(L14,L13,)

    Goto(cfg:23)
  label loop2_group3_bb20 // 23
    // ========== loop2_group3_bb20 ==========
    __t15 := copy true
    // [mir] StorageDead(_32)
    // [mir] StorageDead(_31)
    // [mir] StorageLive(_36)
    // [mir] StorageLive(_37)
    // [mir] _37 = &'_ mut _3
    _37 := builtin$havoc_ref()
    inhale(Stmt) acc(_37.val_ref, write)
    _37.val_ref := mut borrow _3 // L9
    label l12
    // [mir] StorageLive(_38)
    // [mir] _38 = _4
    _38 := builtin$havoc_ref()
    inhale(Stmt) acc(_38.val_int, write)
    _38.val_int := copy _4.val_int
    label l13
    // [mir] _36 = BoolArr32::index_mut(move _37, move _38) -> [return: bb21, unwind: bb24]
    label l14
    assert(Stmt) (((0) <= (_38.val_int)) && (((_38.val_int) < (m_len<Ref(m_BoolArr32$_beg_$_end_),Int>(_37.val_ref))) && (true))) && (true)
    assert(Stmt) (ref$m_BoolArr32$_beg_$_end_$inv<Ref(ref$m_BoolArr32$_beg_$_end_),Bool>(_37)) && ((usize$inv<Ref(usize),Bool>(_38)) && (true))
    exhale (acc(_37.val_ref, write)) && ((acc(m_BoolArr32$_beg_$_end_(_37.val_ref), write)) && ((acc(usize(_38), write)) && (true)))
    _36 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) (acc(_36.val_ref, write)) && (acc(bool(_36.val_ref), write))
    inhale(Stmt) (ref$bool$inv<Ref(ref$bool),Bool>(_36)) && (true)
    inhale(Expr) ((_36.val_ref.val_bool) == (old[l14](m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_37.val_ref, _38.val_int)))) && (true)
    exhale true
    label l15
    Goto(cfg:24)
  label loop2_group3_bb21 // 24
    // ========== loop2_group3_bb21 ==========
    __t16 := copy true
    // [mir] StorageDead(_38)
    // [mir] StorageDead(_37)
    // [mir] (*_36) = move _30
    _36.val_ref := move _30
    label l16
    expire_borrows ReborrowingDAG(L15,L16,L9,)

    // [mir] StorageDead(_30)
    // [mir] StorageDead(_36)
    // [mir] _39 = CheckedAdd(_4, const 1_usize)
    _39 := builtin$havoc_ref()
    inhale(Stmt) acc(_39.tuple_0, write)
    inhale(Stmt) acc(_39.tuple_0.val_int, write)
    inhale(Stmt) acc(_39.tuple_1, write)
    inhale(Stmt) acc(_39.tuple_1.val_bool, write)
    _39.tuple_0.val_int := copy (_4.val_int) + (1)
    _39.tuple_1.val_bool := copy false
    // [mir] assert(!move (_39.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb22, unwind: bb24]
    __t26 := copy _39.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t26)
    Goto(cfg:25)
  label loop2_group3_bb22 // 25
    // ========== loop2_group3_bb22 ==========
    __t17 := copy true
    // [mir] _4 = move (_39.0: usize)
    _4 := move _39.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:26)
  label loop2_group4_bb2 // 26
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb24]
    Goto(cfg:27)
  label loop2_group4_bb3 // 27
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l18
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t27 := copy _7.val_bool
    GotoSwitch([(Local(__t27: Bool, Position { line: 0, column: 0, id: 0 }), cfg:29)], cfg:28)
  label l19 // 28
    // ========== l19 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:33)
  label l20 // 29
    // ========== l20 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:30)
  label loop2_group5_bb4 // 30
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:31)
  label loop2_group5_bb6 // 31
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t28 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:32)
  label loop2_end_body // 32
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BoolArr32$_beg_$_end_(_3), write)
    obtain acc(usize(_2), read)
    obtain acc(_1.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((((_2.val_int) <= (_4.val_int)) && (((!(false))?(((_4.val_int) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_4.val_int) - (_2.val_int)) < (32)):(false)) && (true)))) && ((forall _2_forall_977eda70ddb64558b9762160737aeda9_101: Int  :: ((((0) <= (_2_forall_977eda70ddb64558b9762160737aeda9_101)) && (((_2_forall_977eda70ddb64558b9762160737aeda9_101) < (_4.val_int)) && (((_2_forall_977eda70ddb64558b9762160737aeda9_101) >= (_2.val_int)) && (true)))) && ((((_2.val_int) <= (_2_forall_977eda70ddb64558b9762160737aeda9_101)) && (((!(false))?(((_2_forall_977eda70ddb64558b9762160737aeda9_101) - (_2.val_int)) >= (0)):(false)) && (((!(false))?(((_2_forall_977eda70ddb64558b9762160737aeda9_101) - (_2.val_int)) < (32)):(false)) && (true)))) && (true))) ==> ((!(false))?((m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_977eda70ddb64558b9762160737aeda9_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, (_2_forall_977eda70ddb64558b9762160737aeda9_101) - (_2.val_int)))):(false))) && ((forall _2_forall_48ae03eed98344ae9367c48f0018be80_101: Int  :: (((0) <= (_2_forall_48ae03eed98344ae9367c48f0018be80_101)) && (((_2_forall_48ae03eed98344ae9367c48f0018be80_101) < (_2.val_int)) && (((_2_forall_48ae03eed98344ae9367c48f0018be80_101) < (32)) && (true)))) ==> (!(m_lookup<Ref(m_BoolArr32$_beg_$_end_), Int,Bool>(_3, _2_forall_48ae03eed98344ae9367c48f0018be80_101)))) && (true))))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (true)
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BoolArr32$_beg_$_end_(_3), write)) && ((acc(usize(_2), read)) && ((acc(_1.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 33
    // ========== bb5 ==========
    __t18 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l21
    // [mir] StorageDead(_4)
    // [mir] drop(_3) -> [return: bb23, unwind: bb25]
    Goto(cfg:34)
  label bb23 // 34
    // ========== bb23 ==========
    __t19 := copy true
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_or_v(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _old$pre$1: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(ref$m_BitVec32$_beg_$_end_)
    _3: Ref(m_BitVec32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_290$3$13114848456984105119)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_293$3$8125425184230690860)
    _16: Ref(ref$usize)
    _17: Ref(ref$m_BitVec32$_beg_$_end_)
    _18: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _19: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _20: Ref(tuple0$)
    _21: Ref(ref$m_BitVec32$_beg_$_end_)
    _22: Ref(usize)
    _23: Ref(bool)
    _24: Ref(bool)
    _25: Ref(ref$m_BitVec32$_beg_$_end_)
    _26: Ref(usize)
    _27: Ref(bool)
    _28: Ref(ref$m_BitVec32$_beg_$_end_)
    _29: Ref(usize)
    _30: Ref(tuple2$usize$bool)
    _31: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#1}::or_v"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:672:5: 686:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l24
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BitVec32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_ac19743804eb42efb3ab27e61ebb36b6_101: Int  :: (((0) <= (_2_forall_ac19743804eb42efb3ab27e61ebb36b6_101)) && (((_2_forall_ac19743804eb42efb3ab27e61ebb36b6_101) < (32)) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_0, _2_forall_ac19743804eb42efb3ab27e61ebb36b6_101)) == ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$0, _2_forall_ac19743804eb42efb3ab27e61ebb36b6_101)) || (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$1, _2_forall_ac19743804eb42efb3ab27e61ebb36b6_101))))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BitVec32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BitVec32::zero() -> [return: bb1, unwind: bb17]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_6e18d74b08724366806ddc03a6946ae9_101: Int  :: (((0) <= (_2_forall_6e18d74b08724366806ddc03a6946ae9_101)) && (((_2_forall_6e18d74b08724366806ddc03a6946ae9_101) < (32)) && (true))) ==> (!(m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_6e18d74b08724366806ddc03a6946ae9_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = const 0_usize
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy 0
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l2
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t15 := copy _7.val_bool
    GotoSwitch([(Local(__t15: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t16 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$1 := ghost _2.val_ref
    _preserve$0 := ghost _1.val_ref
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_7392d10ce94c40ce83334fc5297c310f_101: Int  :: (((0) <= (_2_forall_7392d10ce94c40ce83334fc5297c310f_101)) && (((_2_forall_7392d10ce94c40ce83334fc5297c310f_101) < (_4.val_int)) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_7392d10ce94c40ce83334fc5297c310f_101)) == ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_7392d10ce94c40ce83334fc5297c310f_101)) || (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_7392d10ce94c40ce83334fc5297c310f_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    __t5 := builtin$havoc_bool()
    _8 := builtin$havoc_ref()
    __t18 := builtin$havoc_bool()
    _30 := builtin$havoc_ref()
    _29 := builtin$havoc_ref()
    __t13 := builtin$havoc_bool()
    _10 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    __t10 := builtin$havoc_bool()
    _7 := builtin$havoc_ref()
    __t11 := builtin$havoc_bool()
    _24 := builtin$havoc_ref()
    __t12 := builtin$havoc_bool()
    _23 := builtin$havoc_ref()
    _26 := builtin$havoc_ref()
    _21 := builtin$havoc_ref()
    _4 := builtin$havoc_ref()
    __t6 := builtin$havoc_bool()
    __t8 := builtin$havoc_bool()
    __t3 := builtin$havoc_bool()
    _22 := builtin$havoc_ref()
    _25 := builtin$havoc_ref()
    __t17 := builtin$havoc_bool()
    _14 := builtin$havoc_ref()
    _20 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    __t20 := builtin$havoc_bool()
    __t19 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    _27 := builtin$havoc_ref()
    _28 := builtin$havoc_ref()
    __t2 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_7392d10ce94c40ce83334fc5297c310f_101: Int  :: (((0) <= (_2_forall_7392d10ce94c40ce83334fc5297c310f_101)) && (((_2_forall_7392d10ce94c40ce83334fc5297c310f_101) < (_4.val_int)) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_7392d10ce94c40ce83334fc5297c310f_101)) == ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_7392d10ce94c40ce83334fc5297c310f_101)) || (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_7392d10ce94c40ce83334fc5297c310f_101))))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t17 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'_ mut _3
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_ref, write)
    _21.val_ref := mut borrow _3 // L5
    label l5
    // [mir] StorageLive(_22)
    // [mir] _22 = _4
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_int, write)
    _22.val_int := copy _4.val_int
    label l6
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] StorageLive(_25)
    // [mir] _25 = &'_ (*_1)
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_ref, write)
    _25.val_ref := borrow _1.val_ref // L11
    label l7
    // [mir] StorageLive(_26)
    // [mir] _26 = _4
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.val_int, write)
    _26.val_int := copy _4.val_int
    label l8
    // [mir] _24 = BitVec32::lookup(move _25, move _26) -> [return: bb13, unwind: bb17]
    label l9
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_24), write)
    inhale(Stmt) (_24.val_bool) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_25.val_ref, _26.val_int))
    transfer perm _25.val_ref --> old[l9](_25.val_ref) // unchecked: false
    Goto(cfg:17)
  label l10 // 17
    // ========== l10 ==========
    // MIR edge bb12 --> bb13
    // Expire borrows
    expire_borrows ReborrowingDAG(L10,L11,)

    Goto(cfg:18)
  label loop2_group3_bb13 // 18
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_26)
    // [mir] StorageDead(_25)
    // [mir] StorageLive(_27)
    // [mir] StorageLive(_28)
    // [mir] _28 = &'_ (*_2)
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_ref, write)
    _28.val_ref := borrow _2.val_ref // L12
    label l11
    // [mir] StorageLive(_29)
    // [mir] _29 = _4
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.val_int, write)
    _29.val_int := copy _4.val_int
    label l12
    // [mir] _27 = BitVec32::lookup(move _28, move _29) -> [return: bb14, unwind: bb17]
    label l13
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_27), write)
    inhale(Stmt) (_27.val_bool) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_28.val_ref, _29.val_int))
    transfer perm _28.val_ref --> old[l13](_28.val_ref) // unchecked: false
    Goto(cfg:19)
  label l14 // 19
    // ========== l14 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    expire_borrows ReborrowingDAG(L13,L12,)

    Goto(cfg:20)
  label loop2_group3_bb14 // 20
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_29)
    // [mir] StorageDead(_28)
    // [mir] _23 = BitOr(move _24, move _27)
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(_23.val_bool, write)
    _23.val_bool := copy (_24.val_bool) || (_27.val_bool)
    // [mir] StorageDead(_27)
    // [mir] StorageDead(_24)
    // [mir] _20 = BitVec32::set_bit(move _21, move _22, move _23) -> [return: bb15, unwind: bb17]
    label l15
    assert(Stmt) (((0) <= (_22.val_int)) && (((_22.val_int) < (m_main$$$opencur$impl$sharp$1$closecur$$$len<Ref(m_BitVec32$_beg_$_end_),Int>(_21.val_ref))) && (true))) && (true)
    assert(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_21)) && ((usize$inv<Ref(usize),Bool>(_22)) && ((bool$inv<Ref(bool),Bool>(_23)) && (true)))
    exhale (acc(_21.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_21.val_ref), write)) && ((acc(usize(_22), write)) && ((acc(bool(_23), write)) && (true))))
    _20 := builtin$havoc_ref()
    inhale(Stmt) (acc(m_BitVec32$_beg_$_end_(old[l15](_21.val_ref)), write)) && (true)
    inhale(Stmt) acc(tuple0$(_20), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(old[l15](_21.val_ref))) && ((tuple0$$inv<Ref(tuple0$),Bool>(_20)) && (true))
    inhale(Expr) ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l15](_21.val_ref), old[l15](_22.val_int))) == (old[l15](_23.val_bool))) && ((forall _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101: Int  :: (((0) <= (_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101)) && (((_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101) < (32)) && ((!((_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101) == (old[l15](_22.val_int)))) && (true)))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l15](_21.val_ref), _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101)) == (old[l15](m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_21.val_ref, _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101))))) && (true))
    exhale true
    label l16
    Goto(cfg:21)
  label l17 // 21
    // ========== l17 ==========
    // MIR edge bb14 --> bb15
    // Expire borrows
    expire_borrows ReborrowingDAG(L14,L5,)

    Goto(cfg:22)
  label loop2_group3_bb15 // 22
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageDead(_20)
    // [mir] _30 = CheckedAdd(_4, const 1_usize)
    _30 := builtin$havoc_ref()
    inhale(Stmt) acc(_30.tuple_0, write)
    inhale(Stmt) acc(_30.tuple_0.val_int, write)
    inhale(Stmt) acc(_30.tuple_1, write)
    inhale(Stmt) acc(_30.tuple_1.val_bool, write)
    _30.tuple_0.val_int := copy (_4.val_int) + (1)
    _30.tuple_1.val_bool := copy false
    // [mir] assert(!move (_30.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb16, unwind: bb17]
    __t18 := copy _30.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t18)
    Goto(cfg:23)
  label loop2_group3_bb16 // 23
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _4 = move (_30.0: usize)
    _4 := move _30.tuple_0
    label l18
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:24)
  label loop2_group4_bb2 // 24
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:25)
  label loop2_group4_bb3 // 25
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l19
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t19 := copy _7.val_bool
    GotoSwitch([(Local(__t19: Bool, Position { line: 0, column: 0, id: 0 }), cfg:27)], cfg:26)
  label l20 // 26
    // ========== l20 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l21 // 27
    // ========== l21 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:28)
  label loop2_group5_bb4 // 28
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:29)
  label loop2_group5_bb6 // 29
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t20 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:30)
  label loop2_end_body // 30
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_7392d10ce94c40ce83334fc5297c310f_101: Int  :: (((0) <= (_2_forall_7392d10ce94c40ce83334fc5297c310f_101)) && (((_2_forall_7392d10ce94c40ce83334fc5297c310f_101) < (_4.val_int)) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_7392d10ce94c40ce83334fc5297c310f_101)) == ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_7392d10ce94c40ce83334fc5297c310f_101)) || (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_7392d10ce94c40ce83334fc5297c310f_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 31
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l22
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_and_v(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _old$pre$1: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(ref$m_BitVec32$_beg_$_end_)
    _3: Ref(m_BitVec32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_310$3$13114848456984105119)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_313$3$8125425184230690860)
    _16: Ref(ref$usize)
    _17: Ref(ref$m_BitVec32$_beg_$_end_)
    _18: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _19: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _20: Ref(tuple0$)
    _21: Ref(ref$m_BitVec32$_beg_$_end_)
    _22: Ref(usize)
    _23: Ref(bool)
    _24: Ref(bool)
    _25: Ref(ref$m_BitVec32$_beg_$_end_)
    _26: Ref(usize)
    _27: Ref(bool)
    _28: Ref(ref$m_BitVec32$_beg_$_end_)
    _29: Ref(usize)
    _30: Ref(tuple2$usize$bool)
    _31: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#1}::and_v"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:704:5: 718:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l24
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BitVec32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_4db936164c6c46ce900e7b58d4485a2f_101: Int  :: (((0) <= (_2_forall_4db936164c6c46ce900e7b58d4485a2f_101)) && (((_2_forall_4db936164c6c46ce900e7b58d4485a2f_101) < (32)) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_0, _2_forall_4db936164c6c46ce900e7b58d4485a2f_101)) == ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$0, _2_forall_4db936164c6c46ce900e7b58d4485a2f_101)) && (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$1, _2_forall_4db936164c6c46ce900e7b58d4485a2f_101))))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BitVec32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BitVec32::zero() -> [return: bb1, unwind: bb17]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_6e18d74b08724366806ddc03a6946ae9_101: Int  :: (((0) <= (_2_forall_6e18d74b08724366806ddc03a6946ae9_101)) && (((_2_forall_6e18d74b08724366806ddc03a6946ae9_101) < (32)) && (true))) ==> (!(m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_6e18d74b08724366806ddc03a6946ae9_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = const 0_usize
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy 0
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l2
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t15 := copy _7.val_bool
    GotoSwitch([(Local(__t15: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t16 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$1 := ghost _2.val_ref
    _preserve$0 := ghost _1.val_ref
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101: Int  :: (((0) <= (_2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101)) && (((_2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101) < (_4.val_int)) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101)) == ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101)) && (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    _8 := builtin$havoc_ref()
    __t20 := builtin$havoc_bool()
    __t5 := builtin$havoc_bool()
    _22 := builtin$havoc_ref()
    _7 := builtin$havoc_ref()
    _21 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    _27 := builtin$havoc_ref()
    _26 := builtin$havoc_ref()
    _28 := builtin$havoc_ref()
    _10 := builtin$havoc_ref()
    __t18 := builtin$havoc_bool()
    _20 := builtin$havoc_ref()
    __t6 := builtin$havoc_bool()
    __t4 := builtin$havoc_bool()
    __t17 := builtin$havoc_bool()
    __t3 := builtin$havoc_bool()
    __t2 := builtin$havoc_bool()
    _24 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    _4 := builtin$havoc_ref()
    _23 := builtin$havoc_ref()
    _30 := builtin$havoc_ref()
    __t12 := builtin$havoc_bool()
    __t10 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    _25 := builtin$havoc_ref()
    _14 := builtin$havoc_ref()
    _29 := builtin$havoc_ref()
    __t19 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101: Int  :: (((0) <= (_2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101)) && (((_2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101) < (_4.val_int)) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101)) == ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101)) && (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101))))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t17 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'_ mut _3
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_ref, write)
    _21.val_ref := mut borrow _3 // L5
    label l5
    // [mir] StorageLive(_22)
    // [mir] _22 = _4
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_int, write)
    _22.val_int := copy _4.val_int
    label l6
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] StorageLive(_25)
    // [mir] _25 = &'_ (*_1)
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_ref, write)
    _25.val_ref := borrow _1.val_ref // L13
    label l7
    // [mir] StorageLive(_26)
    // [mir] _26 = _4
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.val_int, write)
    _26.val_int := copy _4.val_int
    label l8
    // [mir] _24 = BitVec32::lookup(move _25, move _26) -> [return: bb13, unwind: bb17]
    label l9
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_24), write)
    inhale(Stmt) (_24.val_bool) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_25.val_ref, _26.val_int))
    transfer perm _25.val_ref --> old[l9](_25.val_ref) // unchecked: false
    Goto(cfg:17)
  label l10 // 17
    // ========== l10 ==========
    // MIR edge bb12 --> bb13
    // Expire borrows
    expire_borrows ReborrowingDAG(L11,L13,)

    Goto(cfg:18)
  label loop2_group3_bb13 // 18
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_26)
    // [mir] StorageDead(_25)
    // [mir] StorageLive(_27)
    // [mir] StorageLive(_28)
    // [mir] _28 = &'_ (*_2)
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_ref, write)
    _28.val_ref := borrow _2.val_ref // L14
    label l11
    // [mir] StorageLive(_29)
    // [mir] _29 = _4
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.val_int, write)
    _29.val_int := copy _4.val_int
    label l12
    // [mir] _27 = BitVec32::lookup(move _28, move _29) -> [return: bb14, unwind: bb17]
    label l13
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_27), write)
    inhale(Stmt) (_27.val_bool) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_28.val_ref, _29.val_int))
    transfer perm _28.val_ref --> old[l13](_28.val_ref) // unchecked: false
    Goto(cfg:19)
  label l14 // 19
    // ========== l14 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    expire_borrows ReborrowingDAG(L12,L14,)

    Goto(cfg:20)
  label loop2_group3_bb14 // 20
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_29)
    // [mir] StorageDead(_28)
    // [mir] _23 = BitAnd(move _24, move _27)
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(_23.val_bool, write)
    _23.val_bool := copy (_24.val_bool) && (_27.val_bool)
    // [mir] StorageDead(_27)
    // [mir] StorageDead(_24)
    // [mir] _20 = BitVec32::set_bit(move _21, move _22, move _23) -> [return: bb15, unwind: bb17]
    label l15
    assert(Stmt) (((0) <= (_22.val_int)) && (((_22.val_int) < (m_main$$$opencur$impl$sharp$1$closecur$$$len<Ref(m_BitVec32$_beg_$_end_),Int>(_21.val_ref))) && (true))) && (true)
    assert(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_21)) && ((usize$inv<Ref(usize),Bool>(_22)) && ((bool$inv<Ref(bool),Bool>(_23)) && (true)))
    exhale (acc(_21.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_21.val_ref), write)) && ((acc(usize(_22), write)) && ((acc(bool(_23), write)) && (true))))
    _20 := builtin$havoc_ref()
    inhale(Stmt) (acc(m_BitVec32$_beg_$_end_(old[l15](_21.val_ref)), write)) && (true)
    inhale(Stmt) acc(tuple0$(_20), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(old[l15](_21.val_ref))) && ((tuple0$$inv<Ref(tuple0$),Bool>(_20)) && (true))
    inhale(Expr) ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l15](_21.val_ref), old[l15](_22.val_int))) == (old[l15](_23.val_bool))) && ((forall _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101: Int  :: (((0) <= (_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101)) && (((_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101) < (32)) && ((!((_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101) == (old[l15](_22.val_int)))) && (true)))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l15](_21.val_ref), _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101)) == (old[l15](m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_21.val_ref, _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101))))) && (true))
    exhale true
    label l16
    Goto(cfg:21)
  label l17 // 21
    // ========== l17 ==========
    // MIR edge bb14 --> bb15
    // Expire borrows
    expire_borrows ReborrowingDAG(L10,L5,)

    Goto(cfg:22)
  label loop2_group3_bb15 // 22
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageDead(_20)
    // [mir] _30 = CheckedAdd(_4, const 1_usize)
    _30 := builtin$havoc_ref()
    inhale(Stmt) acc(_30.tuple_0, write)
    inhale(Stmt) acc(_30.tuple_0.val_int, write)
    inhale(Stmt) acc(_30.tuple_1, write)
    inhale(Stmt) acc(_30.tuple_1.val_bool, write)
    _30.tuple_0.val_int := copy (_4.val_int) + (1)
    _30.tuple_1.val_bool := copy false
    // [mir] assert(!move (_30.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb16, unwind: bb17]
    __t18 := copy _30.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t18)
    Goto(cfg:23)
  label loop2_group3_bb16 // 23
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _4 = move (_30.0: usize)
    _4 := move _30.tuple_0
    label l18
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:24)
  label loop2_group4_bb2 // 24
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:25)
  label loop2_group4_bb3 // 25
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l19
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t19 := copy _7.val_bool
    GotoSwitch([(Local(__t19: Bool, Position { line: 0, column: 0, id: 0 }), cfg:27)], cfg:26)
  label l20 // 26
    // ========== l20 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l21 // 27
    // ========== l21 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:28)
  label loop2_group5_bb4 // 28
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:29)
  label loop2_group5_bb6 // 29
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t20 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:30)
  label loop2_end_body // 30
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101: Int  :: (((0) <= (_2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101)) && (((_2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101) < (_4.val_int)) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101)) == ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101)) && (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_a66d6d289c0e49e3ace44f3cc0a1e1b6_101))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 31
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l22
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_xor_v(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _old$pre$1: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(ref$m_BitVec32$_beg_$_end_)
    _3: Ref(m_BitVec32$_beg_$_end_)
    _4: Ref(usize)
    _5: Ref(tuple0$)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(tuple0$)
    _10: Ref(bool)
    _11: Ref(closure$0_330$3$13114848456984105119)
    _12: Ref(ref$usize)
    _13: Ref(tuple0$)
    _14: Ref(bool)
    _15: Ref(closure$0_333$3$8125425184230690860)
    _16: Ref(ref$usize)
    _17: Ref(ref$m_BitVec32$_beg_$_end_)
    _18: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _19: Ref(ref$ref$m_BitVec32$_beg_$_end_)
    _20: Ref(tuple0$)
    _21: Ref(ref$m_BitVec32$_beg_$_end_)
    _22: Ref(usize)
    _23: Ref(bool)
    _24: Ref(bool)
    _25: Ref(ref$m_BitVec32$_beg_$_end_)
    _26: Ref(usize)
    _27: Ref(bool)
    _28: Ref(ref$m_BitVec32$_beg_$_end_)
    _29: Ref(usize)
    _30: Ref(tuple2$usize$bool)
    _31: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#1}::xor_v"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:735:5: 749:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l24
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BitVec32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) (forall _2_forall_5a5dda3e6eca4fe5bec20545ad95f63f_101: Int  :: (((0) <= (_2_forall_5a5dda3e6eca4fe5bec20545ad95f63f_101)) && (((_2_forall_5a5dda3e6eca4fe5bec20545ad95f63f_101) < (32)) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_0, _2_forall_5a5dda3e6eca4fe5bec20545ad95f63f_101)) == (!((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$0, _2_forall_5a5dda3e6eca4fe5bec20545ad95f63f_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_old$pre$1, _2_forall_5a5dda3e6eca4fe5bec20545ad95f63f_101)))))) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BitVec32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = BitVec32::zero() -> [return: bb1, unwind: bb17]
    label l0
    assert(Stmt) true
    assert(Stmt) true
    exhale true
    _3 := builtin$havoc_ref()
    inhale(Stmt) true
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_3), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_3)) && (true)
    inhale(Expr) (forall _2_forall_6e18d74b08724366806ddc03a6946ae9_101: Int  :: (((0) <= (_2_forall_6e18d74b08724366806ddc03a6946ae9_101)) && (((_2_forall_6e18d74b08724366806ddc03a6946ae9_101) < (32)) && (true))) ==> (!(m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_6e18d74b08724366806ddc03a6946ae9_101)))) && (true)
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] _4 = const 0_usize
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy 0
    // [mir] FakeRead(ForLet, _4)
    // [mir] StorageLive(_5)
    // [mir] goto -> bb2
    Goto(cfg:4)
  label loop2_start // 4
    // ========== loop2_start ==========
    Goto(cfg:5)
  label loop2_group1_bb2 // 5
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:6)
  label loop2_group1_bb3 // 6
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l2
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t15 := copy _7.val_bool
    GotoSwitch([(Local(__t15: Bool, Position { line: 0, column: 0, id: 0 }), cfg:8)], cfg:7)
  label l3 // 7
    // ========== l3 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l4 // 8
    // ========== l4 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:9)
  label loop2_group2_bb4 // 9
    // ========== loop2_group2_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:10)
  label loop2_group2_bb6 // 10
    // ========== loop2_group2_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t16 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:11)
  label loop2_inv_pre // 11
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$1 := ghost _2.val_ref
    _preserve$0 := ghost _1.val_ref
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101: Int  :: (((0) <= (_2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)) && (((_2_forall_3cc6a46f084549f7a91e5db4e86abe09_101) < (_4.val_int)) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)) == (!((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    _4 := builtin$havoc_ref()
    __t20 := builtin$havoc_bool()
    _29 := builtin$havoc_ref()
    _21 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    _8 := builtin$havoc_ref()
    __t12 := builtin$havoc_bool()
    _28 := builtin$havoc_ref()
    _14 := builtin$havoc_ref()
    __t6 := builtin$havoc_bool()
    __t9 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    __t18 := builtin$havoc_bool()
    _7 := builtin$havoc_ref()
    _20 := builtin$havoc_ref()
    _22 := builtin$havoc_ref()
    __t2 := builtin$havoc_bool()
    _26 := builtin$havoc_ref()
    _24 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    __t19 := builtin$havoc_bool()
    _30 := builtin$havoc_ref()
    __t5 := builtin$havoc_bool()
    _25 := builtin$havoc_ref()
    _10 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    _23 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    __t10 := builtin$havoc_bool()
    _27 := builtin$havoc_ref()
    __t17 := builtin$havoc_bool()
    Goto(cfg:12)
  label loop2_inv_post // 12
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101: Int  :: (((0) <= (_2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)) && (((_2_forall_3cc6a46f084549f7a91e5db4e86abe09_101) < (_4.val_int)) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)) == (!((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)))))) && (true))
    Goto(cfg:13)
  label loop2_group3_bb8 // 13
    // ========== loop2_group3_bb8 ==========
    __t6 := copy true
    // [mir] _9 = const ()
    // [mir] goto -> bb9
    Goto(cfg:14)
  label loop2_group3_bb9 // 14
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] _14 = const false
    _14 := builtin$havoc_ref()
    inhale(Stmt) acc(_14.val_bool, write)
    _14.val_bool := copy false
    // [mir] switchInt(move _14) -> [false: bb11, otherwise: bb10]
    __t17 := copy _14.val_bool
    // Ignore default target bb10, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:15)
  label loop2_group3_bb11 // 15
    // ========== loop2_group3_bb11 ==========
    __t8 := copy true
    // [mir] _13 = const ()
    // [mir] goto -> bb12
    Goto(cfg:16)
  label loop2_group3_bb12 // 16
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'_ mut _3
    _21 := builtin$havoc_ref()
    inhale(Stmt) acc(_21.val_ref, write)
    _21.val_ref := mut borrow _3 // L5
    label l5
    // [mir] StorageLive(_22)
    // [mir] _22 = _4
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_int, write)
    _22.val_int := copy _4.val_int
    label l6
    // [mir] StorageLive(_23)
    // [mir] StorageLive(_24)
    // [mir] StorageLive(_25)
    // [mir] _25 = &'_ (*_1)
    _25 := builtin$havoc_ref()
    inhale(Stmt) acc(_25.val_ref, write)
    _25.val_ref := borrow _1.val_ref // L13
    label l7
    // [mir] StorageLive(_26)
    // [mir] _26 = _4
    _26 := builtin$havoc_ref()
    inhale(Stmt) acc(_26.val_int, write)
    _26.val_int := copy _4.val_int
    label l8
    // [mir] _24 = BitVec32::lookup(move _25, move _26) -> [return: bb13, unwind: bb17]
    label l9
    _24 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_24), write)
    inhale(Stmt) (_24.val_bool) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_25.val_ref, _26.val_int))
    transfer perm _25.val_ref --> old[l9](_25.val_ref) // unchecked: false
    Goto(cfg:17)
  label l10 // 17
    // ========== l10 ==========
    // MIR edge bb12 --> bb13
    // Expire borrows
    expire_borrows ReborrowingDAG(L10,L13,)

    Goto(cfg:18)
  label loop2_group3_bb13 // 18
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_26)
    // [mir] StorageDead(_25)
    // [mir] StorageLive(_27)
    // [mir] StorageLive(_28)
    // [mir] _28 = &'_ (*_2)
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_ref, write)
    _28.val_ref := borrow _2.val_ref // L11
    label l11
    // [mir] StorageLive(_29)
    // [mir] _29 = _4
    _29 := builtin$havoc_ref()
    inhale(Stmt) acc(_29.val_int, write)
    _29.val_int := copy _4.val_int
    label l12
    // [mir] _27 = BitVec32::lookup(move _28, move _29) -> [return: bb14, unwind: bb17]
    label l13
    _27 := builtin$havoc_ref()
    inhale(Stmt) acc(bool(_27), write)
    inhale(Stmt) (_27.val_bool) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_28.val_ref, _29.val_int))
    transfer perm _28.val_ref --> old[l13](_28.val_ref) // unchecked: false
    Goto(cfg:19)
  label l14 // 19
    // ========== l14 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    expire_borrows ReborrowingDAG(L12,L11,)

    Goto(cfg:20)
  label loop2_group3_bb14 // 20
    // ========== loop2_group3_bb14 ==========
    __t11 := copy true
    // [mir] StorageDead(_29)
    // [mir] StorageDead(_28)
    // [mir] _23 = BitXor(move _24, move _27)
    _23 := builtin$havoc_ref()
    inhale(Stmt) acc(_23.val_bool, write)
    _23.val_bool := copy !((_24.val_bool) == (_27.val_bool))
    // [mir] StorageDead(_27)
    // [mir] StorageDead(_24)
    // [mir] _20 = BitVec32::set_bit(move _21, move _22, move _23) -> [return: bb15, unwind: bb17]
    label l15
    assert(Stmt) (((0) <= (_22.val_int)) && (((_22.val_int) < (m_main$$$opencur$impl$sharp$1$closecur$$$len<Ref(m_BitVec32$_beg_$_end_),Int>(_21.val_ref))) && (true))) && (true)
    assert(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_21)) && ((usize$inv<Ref(usize),Bool>(_22)) && ((bool$inv<Ref(bool),Bool>(_23)) && (true)))
    exhale (acc(_21.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_21.val_ref), write)) && ((acc(usize(_22), write)) && ((acc(bool(_23), write)) && (true))))
    _20 := builtin$havoc_ref()
    inhale(Stmt) (acc(m_BitVec32$_beg_$_end_(old[l15](_21.val_ref)), write)) && (true)
    inhale(Stmt) acc(tuple0$(_20), write)
    inhale(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(old[l15](_21.val_ref))) && ((tuple0$$inv<Ref(tuple0$),Bool>(_20)) && (true))
    inhale(Expr) ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l15](_21.val_ref), old[l15](_22.val_int))) == (old[l15](_23.val_bool))) && ((forall _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101: Int  :: (((0) <= (_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101)) && (((_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101) < (32)) && ((!((_2_forall_29f87f4c22e94919a150b8de9db5a9f8_101) == (old[l15](_22.val_int)))) && (true)))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(old[l15](_21.val_ref), _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101)) == (old[l15](m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_21.val_ref, _2_forall_29f87f4c22e94919a150b8de9db5a9f8_101))))) && (true))
    exhale true
    label l16
    Goto(cfg:21)
  label l17 // 21
    // ========== l17 ==========
    // MIR edge bb14 --> bb15
    // Expire borrows
    expire_borrows ReborrowingDAG(L14,L5,)

    Goto(cfg:22)
  label loop2_group3_bb15 // 22
    // ========== loop2_group3_bb15 ==========
    __t12 := copy true
    // [mir] StorageDead(_23)
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageDead(_20)
    // [mir] _30 = CheckedAdd(_4, const 1_usize)
    _30 := builtin$havoc_ref()
    inhale(Stmt) acc(_30.tuple_0, write)
    inhale(Stmt) acc(_30.tuple_0.val_int, write)
    inhale(Stmt) acc(_30.tuple_1, write)
    inhale(Stmt) acc(_30.tuple_1.val_bool, write)
    _30.tuple_0.val_int := copy (_4.val_int) + (1)
    _30.tuple_1.val_bool := copy false
    // [mir] assert(!move (_30.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, const 1_usize) -> [success: bb16, unwind: bb17]
    __t18 := copy _30.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t18)
    Goto(cfg:23)
  label loop2_group3_bb16 // 23
    // ========== loop2_group3_bb16 ==========
    __t13 := copy true
    // [mir] _4 = move (_30.0: usize)
    _4 := move _30.tuple_0
    label l18
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:24)
  label loop2_group4_bb2 // 24
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb17]
    Goto(cfg:25)
  label loop2_group4_bb3 // 25
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _4
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _4.val_int
    label l19
    // [mir] _7 = Lt(move _8, const 32_usize)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (32)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb5, otherwise: bb4]
    __t19 := copy _7.val_bool
    GotoSwitch([(Local(__t19: Bool, Position { line: 0, column: 0, id: 0 }), cfg:27)], cfg:26)
  label l20 // 26
    // ========== l20 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:31)
  label l21 // 27
    // ========== l21 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:28)
  label loop2_group5_bb4 // 28
    // ========== loop2_group5_bb4 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb5]
    Goto(cfg:29)
  label loop2_group5_bb6 // 29
    // ========== loop2_group5_bb6 ==========
    __t5 := copy true
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = const false
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_bool, write)
    _10.val_bool := copy false
    // [mir] switchInt(move _10) -> [false: bb8, otherwise: bb7]
    __t20 := copy _10.val_bool
    // Ignore default target bb7, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:30)
  label loop2_end_body // 30
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    obtain acc(bool(_7), write)
    obtain acc(usize(_4), write)
    obtain acc(m_BitVec32$_beg_$_end_(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_4.val_int)) && (((_4.val_int) < (32)) && (true))) && ((forall _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101: Int  :: (((0) <= (_2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)) && (((_2_forall_3cc6a46f084549f7a91e5db4e86abe09_101) < (_4.val_int)) && (true))) ==> ((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_3, _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)) == (!((m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_1.val_ref, _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)) == (m_main$$$opencur$impl$sharp$1$closecur$$$lookup<Ref(m_BitVec32$_beg_$_end_), Int,Bool>(_2.val_ref, _2_forall_3cc6a46f084549f7a91e5db4e86abe09_101)))))) && (true))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_4), write)) && ((acc(m_BitVec32$_beg_$_end_(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb5 // 31
    // ========== bb5 ==========
    __t14 := copy true
    // [mir] _5 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_5)
    // [mir] _0 = move _3
    _0 := move _3
    label l22
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_mul(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _old$pre$1: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(ref$m_BitVec32$_beg_$_end_)
    _3: Ref(u32)
    _4: Ref(u32)
    _5: Ref(u32)
    _6: Ref(tuple2$u32$bool)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#1}::mul"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:766:5: 768:6 (#0)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l5
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BitVec32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) ((!(false))?((_0.f$v.val_int) == ((_old$pre$0.f$v.val_int) * (_old$pre$1.f$v.val_int))):(false)) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BitVec32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] _4 = ((*_1).0: u32)
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy _1.val_ref.f$v.val_int
    label l0
    // [mir] StorageLive(_5)
    // [mir] _5 = ((*_2).0: u32)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_int, write)
    _5.val_int := copy _2.val_ref.f$v.val_int
    label l1
    // [mir] _6 = CheckedMul(_4, _5)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.tuple_0, write)
    inhale(Stmt) acc(_6.tuple_0.val_int, write)
    inhale(Stmt) acc(_6.tuple_1, write)
    inhale(Stmt) acc(_6.tuple_1.val_bool, write)
    _6.tuple_0.val_int := copy (_4.val_int) * (_5.val_int)
    _6.tuple_1.val_bool := copy false
    // [mir] assert(!move (_6.1: bool), "attempt to compute `{} * {}`, which would overflow", move _4, move _5) -> [success: bb1, unwind: bb2]
    __t2 := copy _6.tuple_1.val_bool
    // Rust assertion: attempt to multiply with overflow
    assert(Stmt) !(__t2)
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] _3 = move (_6.0: u32)
    _3 := move _6.tuple_0
    label l2
    // [mir] StorageDead(_5)
    // [mir] StorageDead(_4)
    // [mir] _0 = BitVec32 { v: move _3 }
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_0), write)
    _0.f$v := move _3
    label l3
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_div(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _old$pre$1: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(ref$m_BitVec32$_beg_$_end_)
    _3: Ref(u32)
    _4: Ref(u32)
    _5: Ref(u32)
    _6: Ref(bool)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#1}::div"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:772:5: 774:6 (#0)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) (!((_2.val_ref.f$v.val_int) == (0))) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l4
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BitVec32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) ((!((_old$pre$1.f$v.val_int) == (0)))?((_0.f$v.val_int) == ((_old$pre$0.f$v.val_int) \ (_old$pre$1.f$v.val_int))):(false)) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BitVec32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] _4 = ((*_1).0: u32)
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy _1.val_ref.f$v.val_int
    label l0
    // [mir] StorageLive(_5)
    // [mir] _5 = ((*_2).0: u32)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_int, write)
    _5.val_int := copy _2.val_ref.f$v.val_int
    label l1
    // [mir] _6 = Eq(_5, const 0_u32)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_bool, write)
    _6.val_bool := copy (_5.val_int) == (0)
    // [mir] assert(!move _6, "attempt to divide `{}` by zero", _4) -> [success: bb1, unwind: bb2]
    __t2 := copy _6.val_bool
    // Rust assertion: attempt to divide by zero
    assert(Stmt) !(__t2)
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] _3 = Div(move _4, move _5)
    _3 := builtin$havoc_ref()
    inhale(Stmt) acc(_3.val_int, write)
    _3.val_int := copy (_4.val_int) \ (_5.val_int)
    // [mir] StorageDead(_5)
    // [mir] StorageDead(_4)
    // [mir] _0 = BitVec32 { v: move _3 }
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_0), write)
    _0.f$v := move _3
    label l2
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_checked_div(2 args)
    returns (_0: Ref(m_BitVec32$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    _old$pre$0: Ref(m_BitVec32$_beg_$_end_)
    _old$pre$1: Ref(m_BitVec32$_beg_$_end_)
    _1: Ref(ref$m_BitVec32$_beg_$_end_)
    _2: Ref(ref$m_BitVec32$_beg_$_end_)
    _3: Ref(u32)
    _4: Ref(u32)
    _5: Ref(u32)
    _6: Ref(bool)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#1}::checked_div"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:780:5: 782:6 (#0)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_1.val_ref), read)) && ((acc(_2.val_ref, write)) && ((acc(m_BitVec32$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_1)) && ((ref$m_BitVec32$_beg_$_end_$inv<Ref(ref$m_BitVec32$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) (!((_2.val_ref.f$v.val_int) == (0))) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l4
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_BitVec32$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_BitVec32$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(m_BitVec32$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) ((!((_old$pre$1.f$v.val_int) == (0)))?((_0.f$v.val_int) == ((_old$pre$0.f$v.val_int) \ (_old$pre$1.f$v.val_int))):(false)) && (true)
    // Assert type invariants
    assert(Stmt) (m_BitVec32$_beg_$_end_$inv<Ref(m_BitVec32$_beg_$_end_),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_BitVec32$_beg_$_end_(_old$pre$0), read)) && ((acc(m_BitVec32$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_BitVec32$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] _4 = ((*_1).0: u32)
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(_4.val_int, write)
    _4.val_int := copy _1.val_ref.f$v.val_int
    label l0
    // [mir] StorageLive(_5)
    // [mir] _5 = ((*_2).0: u32)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_int, write)
    _5.val_int := copy _2.val_ref.f$v.val_int
    label l1
    // [mir] _6 = Eq(_5, const 0_u32)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_bool, write)
    _6.val_bool := copy (_5.val_int) == (0)
    // [mir] assert(!move _6, "attempt to divide `{}` by zero", _4) -> [success: bb1, unwind: bb2]
    __t2 := copy _6.val_bool
    // Rust assertion: attempt to divide by zero
    assert(Stmt) !(__t2)
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] _3 = Div(move _4, move _5)
    _3 := builtin$havoc_ref()
    inhale(Stmt) acc(_3.val_int, write)
    _3.val_int := copy (_4.val_int) \ (_5.val_int)
    // [mir] StorageDead(_5)
    // [mir] StorageDead(_4)
    // [mir] _0 = BitVec32 { v: move _3 }
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(m_BitVec32$_beg_$_end_(_0), write)
    _0.f$v := move _3
    label l2
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


function m_main$$$opencur$impl$sharp$2$closecur$$$len(_1: Ref(m_PrustiVec$_beg_$_end_)): Int
  requires (acc(m_PrustiVec$_beg_$_end_(_1), read)) && (true)
  requires true
  ensures ((0) <= (__result)) && (true)


function m_main$$$opencur$impl$sharp$2$closecur$$$lookup(_1: Ref(m_PrustiVec$_beg_$_end_), _2: Int): Int
  requires (acc(m_PrustiVec$_beg_$_end_(_1), read)) && (true)
  requires (((0) <= (_2)) && (((_2) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1))) && (true))) && (true)
  ensures true


method m_pop(2 args)
    returns (_0: Ref(u8))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    _old$pre$0: Ref(m_PrustiVec$_beg_$_end_)
    _1: Ref(ref$m_PrustiVec$_beg_$_end_)
    _2: Ref(usize)
    _3: Ref(usize)
    _4: Ref(usize)
    _5: Ref(ref$m_PrustiVec$_beg_$_end_)
    _6: Ref(tuple2$usize$bool)
    _7: Ref(ref$m_PrustiVec$_beg_$_end_)
    _8: Ref(usize)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#2}::pop"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:868:5: 871:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write)) && ((acc(usize(_2), write)) && (true)))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_PrustiVec$_beg_$_end_$inv<Ref(ref$m_PrustiVec$_beg_$_end_),Bool>(_1)) && ((usize$inv<Ref(usize),Bool>(_2)) && (true))
    inhale(Expr) ((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)) >= (1)) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l10
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(u8(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) ((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_old$pre$0)) == ((old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))) - (1))):(false)) && (((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_old$pre$0)) >= (0)) && (((!(false))?((_0.val_int) == (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)) - (1))))):(false)) && ((forall _2_forall_164e1a02575f4a81ac646e8c0a9d0463_101: Int  :: (((0) <= (_2_forall_164e1a02575f4a81ac646e8c0a9d0463_101)) && (((_2_forall_164e1a02575f4a81ac646e8c0a9d0463_101) < (old[pre](_2.val_int))) && (((_2_forall_164e1a02575f4a81ac646e8c0a9d0463_101) < (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)))) && (((_2_forall_164e1a02575f4a81ac646e8c0a9d0463_101) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_old$pre$0))) && (true))))) ==> ((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_old$pre$0, _2_forall_164e1a02575f4a81ac646e8c0a9d0463_101)) == (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, _2_forall_164e1a02575f4a81ac646e8c0a9d0463_101))))) && (true))))
    // Assert type invariants
    assert(Stmt) (m_PrustiVec$_beg_$_end_$inv<Ref(m_PrustiVec$_beg_$_end_),Bool>(_old$pre$0)) && ((u8$inv<Ref(u8),Bool>(_0)) && (true))
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_PrustiVec$_beg_$_end_(_old$pre$0), write)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(u8(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = &'_ (*_1)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_ref, write)
    _5.val_ref := borrow _1.val_ref // L0
    label l0
    // [mir] _4 = PrustiVec::len(move _5) -> [return: bb1, unwind: bb4]
    label l1
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(usize(_4), write)
    inhale(Stmt) (_4.val_int) == (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_5.val_ref))
    transfer perm _5.val_ref --> old[l1](_5.val_ref) // unchecked: false
    Goto(cfg:3)
  label l2 // 3
    // ========== l2 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    expire_borrows ReborrowingDAG(L6,L0,)

    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_5)
    // [mir] _6 = CheckedSub(_4, const 1_usize)
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.tuple_0, write)
    inhale(Stmt) acc(_6.tuple_0.val_int, write)
    inhale(Stmt) acc(_6.tuple_1, write)
    inhale(Stmt) acc(_6.tuple_1.val_bool, write)
    _6.tuple_0.val_int := copy (_4.val_int) - (1)
    _6.tuple_1.val_bool := copy false
    // [mir] assert(!move (_6.1: bool), "attempt to compute `{} - {}`, which would overflow", move _4, const 1_usize) -> [success: bb2, unwind: bb4]
    __t4 := copy _6.tuple_1.val_bool
    // Rust assertion: attempt to subtract with overflow
    assert(Stmt) !(__t4)
    Goto(cfg:5)
  label bb2 // 5
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] _3 = move (_6.0: usize)
    _3 := move _6.tuple_0
    label l3
    // [mir] StorageDead(_4)
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_7)
    // [mir] _7 = &'_ mut (*_1)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_ref, write)
    _7.val_ref := mut borrow _1.val_ref // L1
    label l4
    // [mir] StorageLive(_8)
    // [mir] _8 = _3
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _3.val_int
    label l5
    // [mir] _0 = PrustiVec::remove(move _7, move _8) -> [return: bb3, unwind: bb4]
    label l6
    assert(Stmt) (((0) <= (_8.val_int)) && (((_8.val_int) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_7.val_ref))) && (true))) && (true)
    assert(Stmt) (ref$m_PrustiVec$_beg_$_end_$inv<Ref(ref$m_PrustiVec$_beg_$_end_),Bool>(_7)) && ((usize$inv<Ref(usize),Bool>(_8)) && (true))
    exhale (acc(_7.val_ref, write)) && ((acc(m_PrustiVec$_beg_$_end_(_7.val_ref), write)) && ((acc(usize(_8), write)) && (true)))
    _0 := builtin$havoc_ref()
    inhale(Stmt) (acc(m_PrustiVec$_beg_$_end_(old[l6](_7.val_ref)), write)) && (true)
    inhale(Stmt) acc(u8(_0), write)
    inhale(Stmt) (m_PrustiVec$_beg_$_end_$inv<Ref(m_PrustiVec$_beg_$_end_),Bool>(old[l6](_7.val_ref))) && ((u8$inv<Ref(u8),Bool>(_0)) && (true))
    inhale(Expr) ((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(old[l6](_7.val_ref))) == ((old[l6](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_7.val_ref))) - (1))):(false)) && (((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(old[l6](_7.val_ref))) >= (0)) && (((_0.val_int) == (old[l6](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_7.val_ref, _8.val_int)))) && ((forall _2_forall_15f0f478e164462ba34426e913276433_101: Int  :: (((0) <= (_2_forall_15f0f478e164462ba34426e913276433_101)) && (((_2_forall_15f0f478e164462ba34426e913276433_101) < (old[l6](_8.val_int))) && (((_2_forall_15f0f478e164462ba34426e913276433_101) < (old[l6](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_7.val_ref)))) && (((_2_forall_15f0f478e164462ba34426e913276433_101) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(old[l6](_7.val_ref)))) && (true))))) ==> ((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(old[l6](_7.val_ref), _2_forall_15f0f478e164462ba34426e913276433_101)) == (old[l6](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_7.val_ref, _2_forall_15f0f478e164462ba34426e913276433_101))))) && ((forall _2_forall_6291b57a8391489b9939551ad5a39a45_101: Int  :: (((1) <= (_2_forall_6291b57a8391489b9939551ad5a39a45_101)) && (((old[l6](_8.val_int)) <= (_2_forall_6291b57a8391489b9939551ad5a39a45_101)) && (((_2_forall_6291b57a8391489b9939551ad5a39a45_101) < (old[l6](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_7.val_ref)))) && (((_2_forall_6291b57a8391489b9939551ad5a39a45_101) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(old[l6](_7.val_ref)))) && (true))))) ==> ((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(old[l6](_7.val_ref), (_2_forall_6291b57a8391489b9939551ad5a39a45_101) - (1))) == (old[l6](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_7.val_ref, _2_forall_6291b57a8391489b9939551ad5a39a45_101)))):(false))) && (true)))))
    exhale true
    label l7
    Goto(cfg:6)
  label l8 // 6
    // ========== l8 ==========
    // MIR edge bb2 --> bb3
    // Expire borrows
    expire_borrows ReborrowingDAG(L5,L1,)

    Goto(cfg:7)
  label bb3 // 7
    // ========== bb3 ==========
    __t3 := copy true
    // [mir] StorageDead(_8)
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_append(2 args)
    returns (_0: Ref(tuple0$))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    _preserve$0: Ref(AuxRef)
    _preserve$1: Ref(AuxRef)
    __t21: Bool
    __t22: Bool
    __t23: Bool
    __t24: Bool
    __t25: Bool
    __t26: Bool
    _old$pre$0: Ref(m_PrustiVec$_beg_$_end_)
    _old$pre$1: Ref(m_PrustiVec$_beg_$_end_)
    _1: Ref(ref$m_PrustiVec$_beg_$_end_)
    _2: Ref(ref$m_PrustiVec$_beg_$_end_)
    _3: Ref(usize)
    _4: Ref(usize)
    _5: Ref(ref$m_PrustiVec$_beg_$_end_)
    _6: Ref(tuple0$)
    _7: Ref(bool)
    _8: Ref(usize)
    _9: Ref(usize)
    _10: Ref(ref$m_PrustiVec$_beg_$_end_)
    _11: Ref(tuple0$)
    _12: Ref(bool)
    _13: Ref(closure$0_429$3$11337997195384638765)
    _14: Ref(ref$usize)
    _15: Ref(ref$ref$m_PrustiVec$_beg_$_end_)
    _16: Ref(tuple0$)
    _17: Ref(bool)
    _18: Ref(closure$0_432$3$10808428406900332318)
    _19: Ref(ref$ref$m_PrustiVec$_beg_$_end_)
    _20: Ref(ref$usize)
    _21: Ref(tuple0$)
    _22: Ref(bool)
    _23: Ref(closure$0_434$3$6168722008047593507)
    _24: Ref(ref$usize)
    _25: Ref(ref$ref$m_PrustiVec$_beg_$_end_)
    _26: Ref(ref$ref$m_PrustiVec$_beg_$_end_)
    _27: Ref(tuple0$)
    _28: Ref(bool)
    _29: Ref(closure$0_442$3$3110356988240756096)
    _30: Ref(ref$ref$m_PrustiVec$_beg_$_end_)
    _31: Ref(tuple0$)
    _32: Ref(ref$m_PrustiVec$_beg_$_end_)
    _33: Ref(u8)
    _34: Ref(ref$m_PrustiVec$_beg_$_end_)
    _35: Ref(usize)
    _36: Ref(tuple2$usize$bool)
    _37: Ref(never)
  label start // 0
    // ========== start ==========
    // Def path: "main::{impl#2}::append"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:886:5: 909:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    __t16 := copy false
    __t17 := copy false
    __t18 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write)) && ((acc(_2.val_ref, write)) && ((acc(m_PrustiVec$_beg_$_end_(_2.val_ref), read)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$m_PrustiVec$_beg_$_end_$inv<Ref(ref$m_PrustiVec$_beg_$_end_),Bool>(_1)) && ((ref$m_PrustiVec$_beg_$_end_$inv<Ref(ref$m_PrustiVec$_beg_$_end_),Bool>(_2)) && (true))
    inhale(Expr) true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l25
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(m_PrustiVec$_beg_$_end_(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(tuple0$(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) ((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_old$pre$0)) == ((old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))) + (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_old$pre$1)))):(false)) && ((forall _2_forall_3ea8b7088ef64adab11ff9fe1d39ff27_101: Int  :: (((0) <= (_2_forall_3ea8b7088ef64adab11ff9fe1d39ff27_101)) && (((_2_forall_3ea8b7088ef64adab11ff9fe1d39ff27_101) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_old$pre$1))) && (true))) ==> ((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_old$pre$0, (_2_forall_3ea8b7088ef64adab11ff9fe1d39ff27_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))))) == (m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_old$pre$1, _2_forall_3ea8b7088ef64adab11ff9fe1d39ff27_101))):(false))) && ((forall _2_forall_c5ec806e7a184c158060318d6d45f205_101: Int  :: (((0) <= (_2_forall_c5ec806e7a184c158060318d6d45f205_101)) && (((_2_forall_c5ec806e7a184c158060318d6d45f205_101) < (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)))) && (true))) ==> ((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_old$pre$0, _2_forall_c5ec806e7a184c158060318d6d45f205_101)) == (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, _2_forall_c5ec806e7a184c158060318d6d45f205_101))))) && (true)))
    // Assert type invariants
    assert(Stmt) (m_PrustiVec$_beg_$_end_$inv<Ref(m_PrustiVec$_beg_$_end_),Bool>(_old$pre$0)) && ((tuple0$$inv<Ref(tuple0$),Bool>(_0)) && (true))
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_PrustiVec$_beg_$_end_(_old$pre$0), write)) && ((acc(m_PrustiVec$_beg_$_end_(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(tuple0$(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = const 0_usize
    _3 := builtin$havoc_ref()
    inhale(Stmt) acc(_3.val_int, write)
    _3.val_int := copy 0
    // [mir] FakeRead(ForLet, _3)
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = &'_ (*_1)
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_ref, write)
    _5.val_ref := borrow _1.val_ref // L0
    label l0
    // [mir] _4 = PrustiVec::len(move _5) -> [return: bb1, unwind: bb23]
    label l1
    _4 := builtin$havoc_ref()
    inhale(Stmt) acc(usize(_4), write)
    inhale(Stmt) (_4.val_int) == (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_5.val_ref))
    transfer perm _5.val_ref --> old[l1](_5.val_ref) // unchecked: false
    Goto(cfg:3)
  label l2 // 3
    // ========== l2 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    expire_borrows ReborrowingDAG(L19,L0,)

    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_5)
    // [mir] FakeRead(ForLet, _4)
    // [mir] goto -> bb2
    Goto(cfg:5)
  label loop2_start // 5
    // ========== loop2_start ==========
    Goto(cfg:6)
  label loop2_group1_bb2 // 6
    // ========== loop2_group1_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb23]
    Goto(cfg:7)
  label loop2_group1_bb3 // 7
    // ========== loop2_group1_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _3
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _3.val_int
    label l3
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = &'_ (*_2)
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_ref, write)
    _10.val_ref := borrow _2.val_ref // L18
    label l4
    // [mir] _9 = PrustiVec::len(move _10) -> [return: bb4, unwind: bb23]
    label l5
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(usize(_9), write)
    inhale(Stmt) (_9.val_int) == (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_10.val_ref))
    transfer perm _10.val_ref --> old[l5](_10.val_ref) // unchecked: false
    Goto(cfg:8)
  label l6 // 8
    // ========== l6 ==========
    // MIR edge bb3 --> bb4
    // Expire borrows
    expire_borrows ReborrowingDAG(L14,L18,)

    Goto(cfg:9)
  label loop2_group1_bb4 // 9
    // ========== loop2_group1_bb4 ==========
    __t4 := copy true
    // [mir] StorageDead(_10)
    // [mir] _7 = Lt(move _8, move _9)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (_9.val_int)
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb6, otherwise: bb5]
    __t19 := copy _7.val_bool
    GotoSwitch([(Local(__t19: Bool, Position { line: 0, column: 0, id: 0 }), cfg:11)], cfg:10)
  label l7 // 10
    // ========== l7 ==========
    // MIR edge bb4 --> bb6
    Goto(cfg:38)
  label l8 // 11
    // ========== l8 ==========
    // MIR edge bb4 --> bb5
    Goto(cfg:12)
  label loop2_group2_bb5 // 12
    // ========== loop2_group2_bb5 ==========
    __t5 := copy true
    // [mir] falseEdge -> [real: bb7, imaginary: bb6]
    Goto(cfg:13)
  label loop2_group2_bb7 // 13
    // ========== loop2_group2_bb7 ==========
    __t6 := copy true
    // [mir] StorageLive(_11)
    // [mir] StorageLive(_12)
    // [mir] _12 = const false
    _12 := builtin$havoc_ref()
    inhale(Stmt) acc(_12.val_bool, write)
    _12.val_bool := copy false
    // [mir] switchInt(move _12) -> [false: bb9, otherwise: bb8]
    __t20 := copy _12.val_bool
    // Ignore default target bb8, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:14)
  label loop2_inv_pre // 14
    // ========== loop2_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    _preserve$0 := ghost _1.val_ref
    _preserve$1 := ghost _2.val_ref
    obtain acc(bool(_7), write)
    obtain acc(usize(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_3.val_int)) && (((_3.val_int) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_2.val_ref))) && (true))) && (((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)) == ((old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))) + (_3.val_int))):(false)) && ((forall _2_forall_67396f83e8cd4801ae45e414c98ae16e_101: Int  :: ((((0) <= (_2_forall_67396f83e8cd4801ae45e414c98ae16e_101)) && (((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) < (_3.val_int)) && (true))) && ((((!(false))?((0) <= ((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))))):(false)) && (((!(false))?(((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)))) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))):(false)) && (true))) && (((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_2.val_ref))) && (true)))) ==> ((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, (_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))))) == (m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_2.val_ref, _2_forall_67396f83e8cd4801ae45e414c98ae16e_101))):(false))) && ((forall _2_forall_86902255ca344ade8030c17ca05d40aa_101: Int  :: (((0) <= (_2_forall_86902255ca344ade8030c17ca05d40aa_101)) && (((_2_forall_86902255ca344ade8030c17ca05d40aa_101) < (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)))) && (true))) ==> ((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, _2_forall_86902255ca344ade8030c17ca05d40aa_101)) == (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, _2_forall_86902255ca344ade8030c17ca05d40aa_101))))) && (true))))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write)) && ((acc(_2.val_ref, read)) && (true)))))
    __t10 := builtin$havoc_bool()
    __t11 := builtin$havoc_bool()
    _35 := builtin$havoc_ref()
    __t25 := builtin$havoc_bool()
    _33 := builtin$havoc_ref()
    __t15 := builtin$havoc_bool()
    _12 := builtin$havoc_ref()
    __t2 := builtin$havoc_bool()
    _7 := builtin$havoc_ref()
    __t26 := builtin$havoc_bool()
    _31 := builtin$havoc_ref()
    __t22 := builtin$havoc_bool()
    __t21 := builtin$havoc_bool()
    __t14 := builtin$havoc_bool()
    _9 := builtin$havoc_ref()
    __t8 := builtin$havoc_bool()
    __t16 := builtin$havoc_bool()
    _34 := builtin$havoc_ref()
    __t12 := builtin$havoc_bool()
    _28 := builtin$havoc_ref()
    _32 := builtin$havoc_ref()
    __t4 := builtin$havoc_bool()
    __t17 := builtin$havoc_bool()
    _17 := builtin$havoc_ref()
    __t6 := builtin$havoc_bool()
    __t23 := builtin$havoc_bool()
    _36 := builtin$havoc_ref()
    __t5 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    _10 := builtin$havoc_ref()
    __t7 := builtin$havoc_bool()
    _22 := builtin$havoc_ref()
    __t3 := builtin$havoc_bool()
    _8 := builtin$havoc_ref()
    __t24 := builtin$havoc_bool()
    _3 := builtin$havoc_ref()
    __t9 := builtin$havoc_bool()
    Goto(cfg:15)
  label loop2_inv_post // 15
    // ========== loop2_inv_post ==========
    // Inhale the loop invariant of block bb2
    inhale(Stmt) (acc(bool(_7), write)) && ((acc(usize(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    inhale(Expr) (((0) <= (_3.val_int)) && (((_3.val_int) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_2.val_ref))) && (true))) && (((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)) == ((old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))) + (_3.val_int))):(false)) && ((forall _2_forall_67396f83e8cd4801ae45e414c98ae16e_101: Int  :: ((((0) <= (_2_forall_67396f83e8cd4801ae45e414c98ae16e_101)) && (((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) < (_3.val_int)) && (true))) && ((((!(false))?((0) <= ((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))))):(false)) && (((!(false))?(((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)))) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))):(false)) && (true))) && (((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_2.val_ref))) && (true)))) ==> ((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, (_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))))) == (m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_2.val_ref, _2_forall_67396f83e8cd4801ae45e414c98ae16e_101))):(false))) && ((forall _2_forall_86902255ca344ade8030c17ca05d40aa_101: Int  :: (((0) <= (_2_forall_86902255ca344ade8030c17ca05d40aa_101)) && (((_2_forall_86902255ca344ade8030c17ca05d40aa_101) < (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)))) && (true))) ==> ((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, _2_forall_86902255ca344ade8030c17ca05d40aa_101)) == (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, _2_forall_86902255ca344ade8030c17ca05d40aa_101))))) && (true))))
    Goto(cfg:16)
  label loop2_group3_bb9 // 16
    // ========== loop2_group3_bb9 ==========
    __t7 := copy true
    // [mir] _11 = const ()
    // [mir] goto -> bb10
    Goto(cfg:17)
  label loop2_group3_bb10 // 17
    // ========== loop2_group3_bb10 ==========
    __t8 := copy true
    // [mir] StorageDead(_12)
    // [mir] StorageDead(_11)
    // [mir] StorageLive(_16)
    // [mir] StorageLive(_17)
    // [mir] _17 = const false
    _17 := builtin$havoc_ref()
    inhale(Stmt) acc(_17.val_bool, write)
    _17.val_bool := copy false
    // [mir] switchInt(move _17) -> [false: bb12, otherwise: bb11]
    __t21 := copy _17.val_bool
    // Ignore default target bb11, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:18)
  label loop2_group3_bb12 // 18
    // ========== loop2_group3_bb12 ==========
    __t9 := copy true
    // [mir] _16 = const ()
    // [mir] goto -> bb13
    Goto(cfg:19)
  label loop2_group3_bb13 // 19
    // ========== loop2_group3_bb13 ==========
    __t10 := copy true
    // [mir] StorageDead(_17)
    // [mir] StorageDead(_16)
    // [mir] StorageLive(_21)
    // [mir] StorageLive(_22)
    // [mir] _22 = const false
    _22 := builtin$havoc_ref()
    inhale(Stmt) acc(_22.val_bool, write)
    _22.val_bool := copy false
    // [mir] switchInt(move _22) -> [false: bb15, otherwise: bb14]
    __t22 := copy _22.val_bool
    // Ignore default target bb14, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:20)
  label loop2_group3_bb15 // 20
    // ========== loop2_group3_bb15 ==========
    __t11 := copy true
    // [mir] _21 = const ()
    // [mir] goto -> bb16
    Goto(cfg:21)
  label loop2_group3_bb16 // 21
    // ========== loop2_group3_bb16 ==========
    __t12 := copy true
    // [mir] StorageDead(_22)
    // [mir] StorageDead(_21)
    // [mir] StorageLive(_27)
    // [mir] StorageLive(_28)
    // [mir] _28 = const false
    _28 := builtin$havoc_ref()
    inhale(Stmt) acc(_28.val_bool, write)
    _28.val_bool := copy false
    // [mir] switchInt(move _28) -> [false: bb18, otherwise: bb17]
    __t23 := copy _28.val_bool
    // Ignore default target bb17, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:22)
  label loop2_group3_bb18 // 22
    // ========== loop2_group3_bb18 ==========
    __t13 := copy true
    // [mir] _27 = const ()
    // [mir] goto -> bb19
    Goto(cfg:23)
  label loop2_group3_bb19 // 23
    // ========== loop2_group3_bb19 ==========
    __t14 := copy true
    // [mir] StorageDead(_28)
    // [mir] StorageDead(_27)
    // [mir] StorageLive(_31)
    // [mir] StorageLive(_32)
    // [mir] _32 = &'_ mut (*_1)
    _32 := builtin$havoc_ref()
    inhale(Stmt) acc(_32.val_ref, write)
    _32.val_ref := mut borrow _1.val_ref // L9
    label l9
    // [mir] StorageLive(_33)
    // [mir] StorageLive(_34)
    // [mir] _34 = &'_ (*_2)
    _34 := builtin$havoc_ref()
    inhale(Stmt) acc(_34.val_ref, write)
    _34.val_ref := borrow _2.val_ref // L15
    label l10
    // [mir] StorageLive(_35)
    // [mir] _35 = _3
    _35 := builtin$havoc_ref()
    inhale(Stmt) acc(_35.val_int, write)
    _35.val_int := copy _3.val_int
    label l11
    // [mir] _33 = PrustiVec::lookup(move _34, move _35) -> [return: bb20, unwind: bb23]
    label l12
    _33 := builtin$havoc_ref()
    inhale(Stmt) acc(u8(_33), write)
    inhale(Stmt) (_33.val_int) == (m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_34.val_ref, _35.val_int))
    transfer perm _34.val_ref --> old[l12](_34.val_ref) // unchecked: false
    Goto(cfg:24)
  label l13 // 24
    // ========== l13 ==========
    // MIR edge bb19 --> bb20
    // Expire borrows
    expire_borrows ReborrowingDAG(L16,L15,)

    Goto(cfg:25)
  label loop2_group3_bb20 // 25
    // ========== loop2_group3_bb20 ==========
    __t15 := copy true
    // [mir] StorageDead(_35)
    // [mir] StorageDead(_34)
    // [mir] _31 = PrustiVec::push(move _32, move _33) -> [return: bb21, unwind: bb23]
    label l14
    assert(Stmt) true
    assert(Stmt) (ref$m_PrustiVec$_beg_$_end_$inv<Ref(ref$m_PrustiVec$_beg_$_end_),Bool>(_32)) && ((u8$inv<Ref(u8),Bool>(_33)) && (true))
    exhale (acc(_32.val_ref, write)) && ((acc(m_PrustiVec$_beg_$_end_(_32.val_ref), write)) && ((acc(u8(_33), write)) && (true)))
    _31 := builtin$havoc_ref()
    inhale(Stmt) (acc(m_PrustiVec$_beg_$_end_(old[l14](_32.val_ref)), write)) && (true)
    inhale(Stmt) acc(tuple0$(_31), write)
    inhale(Stmt) (m_PrustiVec$_beg_$_end_$inv<Ref(m_PrustiVec$_beg_$_end_),Bool>(old[l14](_32.val_ref))) && ((tuple0$$inv<Ref(tuple0$),Bool>(_31)) && (true))
    inhale(Expr) ((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(old[l14](_32.val_ref))) == ((old[l14](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_32.val_ref))) + (1))):(false)) && (((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(old[l14](_32.val_ref))) >= (1)) && (((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(old[l14](_32.val_ref), (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(old[l14](_32.val_ref))) - (1))) == (old[l14](_33.val_int))):(false)) && ((forall _2_forall_44a22c27490449b4b921e331e47dcb60_101: Int  :: (((0) <= (_2_forall_44a22c27490449b4b921e331e47dcb60_101)) && (((_2_forall_44a22c27490449b4b921e331e47dcb60_101) < (old[l14](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_32.val_ref)))) && (true))) ==> ((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(old[l14](_32.val_ref), _2_forall_44a22c27490449b4b921e331e47dcb60_101)) == (old[l14](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_32.val_ref, _2_forall_44a22c27490449b4b921e331e47dcb60_101))))) && (true))))
    exhale true
    label l15
    Goto(cfg:26)
  label l16 // 26
    // ========== l16 ==========
    // MIR edge bb20 --> bb21
    // Expire borrows
    expire_borrows ReborrowingDAG(L17,L9,)

    Goto(cfg:27)
  label loop2_group3_bb21 // 27
    // ========== loop2_group3_bb21 ==========
    __t16 := copy true
    // [mir] StorageDead(_33)
    // [mir] StorageDead(_32)
    // [mir] StorageDead(_31)
    // [mir] _36 = CheckedAdd(_3, const 1_usize)
    _36 := builtin$havoc_ref()
    inhale(Stmt) acc(_36.tuple_0, write)
    inhale(Stmt) acc(_36.tuple_0.val_int, write)
    inhale(Stmt) acc(_36.tuple_1, write)
    inhale(Stmt) acc(_36.tuple_1.val_bool, write)
    _36.tuple_0.val_int := copy (_3.val_int) + (1)
    _36.tuple_1.val_bool := copy false
    // [mir] assert(!move (_36.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_usize) -> [success: bb22, unwind: bb23]
    __t24 := copy _36.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert(Stmt) !(__t24)
    Goto(cfg:28)
  label loop2_group3_bb22 // 28
    // ========== loop2_group3_bb22 ==========
    __t17 := copy true
    // [mir] _3 = move (_36.0: usize)
    _3 := move _36.tuple_0
    label l17
    // [mir] _6 = const ()
    // [mir] StorageDead(_7)
    // [mir] goto -> bb2
    Goto(cfg:29)
  label loop2_group4_bb2 // 29
    // ========== loop2_group4_bb2 ==========
    // This is a loop head
    __t2 := copy true
    // [mir] falseUnwind -> [real: bb3, cleanup: bb23]
    Goto(cfg:30)
  label loop2_group4_bb3 // 30
    // ========== loop2_group4_bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _3
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_int, write)
    _8.val_int := copy _3.val_int
    label l18
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = &'_ (*_2)
    _10 := builtin$havoc_ref()
    inhale(Stmt) acc(_10.val_ref, write)
    _10.val_ref := borrow _2.val_ref // L18
    label l19
    // [mir] _9 = PrustiVec::len(move _10) -> [return: bb4, unwind: bb23]
    label l20
    _9 := builtin$havoc_ref()
    inhale(Stmt) acc(usize(_9), write)
    inhale(Stmt) (_9.val_int) == (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_10.val_ref))
    transfer perm _10.val_ref --> old[l20](_10.val_ref) // unchecked: false
    Goto(cfg:31)
  label l21 // 31
    // ========== l21 ==========
    // MIR edge bb3 --> bb4
    // Expire borrows
    expire_borrows ReborrowingDAG(L14,L18,)

    Goto(cfg:32)
  label loop2_group4_bb4 // 32
    // ========== loop2_group4_bb4 ==========
    __t4 := copy true
    // [mir] StorageDead(_10)
    // [mir] _7 = Lt(move _8, move _9)
    _7 := builtin$havoc_ref()
    inhale(Stmt) acc(_7.val_bool, write)
    _7.val_bool := copy (_8.val_int) < (_9.val_int)
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForMatchedPlace, _7)
    // [mir] switchInt(_7) -> [false: bb6, otherwise: bb5]
    __t25 := copy _7.val_bool
    GotoSwitch([(Local(__t25: Bool, Position { line: 0, column: 0, id: 0 }), cfg:34)], cfg:33)
  label l22 // 33
    // ========== l22 ==========
    // MIR edge bb4 --> bb6
    Goto(cfg:38)
  label l23 // 34
    // ========== l23 ==========
    // MIR edge bb4 --> bb5
    Goto(cfg:35)
  label loop2_group5_bb5 // 35
    // ========== loop2_group5_bb5 ==========
    __t5 := copy true
    // [mir] falseEdge -> [real: bb7, imaginary: bb6]
    Goto(cfg:36)
  label loop2_group5_bb7 // 36
    // ========== loop2_group5_bb7 ==========
    __t6 := copy true
    // [mir] StorageLive(_11)
    // [mir] StorageLive(_12)
    // [mir] _12 = const false
    _12 := builtin$havoc_ref()
    inhale(Stmt) acc(_12.val_bool, write)
    _12.val_bool := copy false
    // [mir] switchInt(move _12) -> [false: bb9, otherwise: bb8]
    __t26 := copy _12.val_bool
    // Ignore default target bb8, as it is only used by Prusti to type-check a loop invariant.
    Goto(cfg:37)
  label loop2_end_body // 37
    // ========== loop2_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb2)
    obtain acc(bool(_7), write)
    obtain acc(usize(_3), write)
    obtain acc(_1.val_ref, read)
    obtain acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write)
    obtain acc(_2.val_ref, read)
    assert(Expr) (((0) <= (_3.val_int)) && (((_3.val_int) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_2.val_ref))) && (true))) && (((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)) == ((old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))) + (_3.val_int))):(false)) && ((forall _2_forall_67396f83e8cd4801ae45e414c98ae16e_101: Int  :: ((((0) <= (_2_forall_67396f83e8cd4801ae45e414c98ae16e_101)) && (((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) < (_3.val_int)) && (true))) && ((((!(false))?((0) <= ((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))))):(false)) && (((!(false))?(((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)))) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))):(false)) && (true))) && (((_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_2.val_ref))) && (true)))) ==> ((!(false))?((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, (_2_forall_67396f83e8cd4801ae45e414c98ae16e_101) + (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref))))) == (m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_2.val_ref, _2_forall_67396f83e8cd4801ae45e414c98ae16e_101))):(false))) && ((forall _2_forall_86902255ca344ade8030c17ca05d40aa_101: Int  :: (((0) <= (_2_forall_86902255ca344ade8030c17ca05d40aa_101)) && (((_2_forall_86902255ca344ade8030c17ca05d40aa_101) < (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1.val_ref)))) && (true))) ==> ((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, _2_forall_86902255ca344ade8030c17ca05d40aa_101)) == (old[pre](m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1.val_ref, _2_forall_86902255ca344ade8030c17ca05d40aa_101))))) && (true))))
    assert(Expr) ((_preserve$0) == (_1.val_ref)) && (((_preserve$1) == (_2.val_ref)) && (true))
    exhale (acc(bool(_7), write)) && ((acc(usize(_3), write)) && ((acc(_1.val_ref, read)) && ((acc(m_PrustiVec$_beg_$_end_(_1.val_ref), write)) && ((acc(_2.val_ref, read)) && (true)))))
    inhale(Stmt) false
    Return
  label bb6 // 38
    // ========== bb6 ==========
    __t18 := copy true
    // [mir] _0 = const ()
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


function m_contains(_1: Ref(m_PrustiVec$_beg_$_end_), _2: Int): Bool
  requires (acc(m_PrustiVec$_beg_$_end_(_1), read)) && (true)
  requires true
  ensures ((__result) && ((forall _2_forall_470556b7f97a447c822e656db6f37b1d_102: Int  :: (((0) <= (_2_forall_470556b7f97a447c822e656db6f37b1d_102)) && (((_2_forall_470556b7f97a447c822e656db6f37b1d_102) < (m_main$$$opencur$impl$sharp$2$closecur$$$len<Ref(m_PrustiVec$_beg_$_end_),Int>(_1))) && (true))) ==> (!((m_main$$$opencur$impl$sharp$2$closecur$$$lookup<Ref(m_PrustiVec$_beg_$_end_), Int,Int>(_1, _2_forall_470556b7f97a447c822e656db6f37b1d_102)) == (_2)))) && (true))) && (true)


method m_closure$$$opencur$closure$sharp$0$closecur$(3 args)
    returns (_0: Ref(u8))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    _old$pre$0: Ref(closure$0_178$3$4476728821056422335)
    _1: Ref(ref$closure$0_178$3$4476728821056422335)
    _2: Ref(u8)
    _3: Ref(u8)
    _4: Ref(tuple0$)
    _5: Ref(bool)
    _6: Ref(u8)
    _7: Ref(tuple0$)
    _8: Ref(bool)
  label start // 0
    // ========== start ==========
    // Def path: "main::closure::{closure#0}"
    // Span: /home/philippe/VSCodeProjects/prusti_0/src/main.rs:426:15: 430:6 (#90)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    // Preconditions:
    inhale(Stmt) (acc(_1.val_ref, write)) && ((acc(closure$0_178$3$4476728821056422335(_1.val_ref), read)) && ((acc(u8(_2), write)) && ((acc(u8(_3), write)) && (true))))
    inhale(Stmt) true
    inhale(Stmt) (ref$closure$0_178$3$4476728821056422335$inv<Ref(ref$closure$0_178$3$4476728821056422335),Bool>(_1)) && ((u8$inv<Ref(u8),Bool>(_2)) && ((u8$inv<Ref(u8),Bool>(_3)) && (true)))
    inhale(Expr) ((_2.val_int) > (_3.val_int)) && (true)
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l7
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(closure$0_178$3$4476728821056422335(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(u8(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert(Expr) ((_0.val_int) > (old[pre](_3.val_int))) && (true)
    // Assert type invariants
    assert(Stmt) (u8$inv<Ref(u8),Bool>(_0)) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(closure$0_178$3$4476728821056422335(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(u8(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = const false
    _5 := builtin$havoc_ref()
    inhale(Stmt) acc(_5.val_bool, write)
    _5.val_bool := copy false
    // [mir] switchInt(move _5) -> [false: bb2, otherwise: bb1]
    __t7 := copy _5.val_bool
    GotoSwitch([(UnaryOp(Not, Local(__t7: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:4)], cfg:3)
  label l0 // 3
    // ========== l0 ==========
    // MIR edge bb0 --> bb1
    Goto(cfg:5)
  label l1 // 4
    // ========== l1 ==========
    // MIR edge bb0 --> bb2
    Goto(cfg:6)
  label bb1 // 5
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] _4 = const ()
    // [mir] goto -> bb3
    Goto(cfg:7)
  label bb2 // 6
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] _4 = const ()
    // [mir] goto -> bb3
    Goto(cfg:7)
  label bb3 // 7
    // ========== bb3 ==========
    __t3 := copy true
    // [mir] StorageDead(_5)
    // [mir] StorageDead(_4)
    // [mir] StorageLive(_6)
    // [mir] _6 = _2
    _6 := builtin$havoc_ref()
    inhale(Stmt) acc(_6.val_int, write)
    _6.val_int := copy _2.val_int
    label l2
    // [mir] FakeRead(ForLet, _6)
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = const false
    _8 := builtin$havoc_ref()
    inhale(Stmt) acc(_8.val_bool, write)
    _8.val_bool := copy false
    // [mir] switchInt(move _8) -> [false: bb5, otherwise: bb4]
    __t8 := copy _8.val_bool
    GotoSwitch([(UnaryOp(Not, Local(__t8: Bool, Position { line: 0, column: 0, id: 0 }), Position { line: 0, column: 0, id: 0 }), cfg:9)], cfg:8)
  label l3 // 8
    // ========== l3 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:10)
  label l4 // 9
    // ========== l4 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:11)
  label bb4 // 10
    // ========== bb4 ==========
    __t4 := copy true
    // [mir] _7 = const ()
    // [mir] goto -> bb6
    Goto(cfg:12)
  label bb5 // 11
    // ========== bb5 ==========
    __t5 := copy true
    // [mir] _7 = const ()
    // [mir] goto -> bb6
    Goto(cfg:12)
  label bb6 // 12
    // ========== bb6 ==========
    __t6 := copy true
    // [mir] StorageDead(_8)
    // [mir] StorageDead(_7)
    // [mir] _0 = _6
    _0 := builtin$havoc_ref()
    inhale(Stmt) acc(_0.val_int, write)
    _0.val_int := copy _6.val_int
    label l5
    // [mir] StorageDead(_6)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


